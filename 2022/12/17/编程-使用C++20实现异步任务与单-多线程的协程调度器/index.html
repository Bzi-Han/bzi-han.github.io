<!DOCTYPE html><html class="appearance-auto" lang="zh-CN"><head><meta charset="UTF-8"><title>[编程] 使用C++20实现异步任务与单/多线程的协程调度器</title><meta name="description" content="Bzi-Han's blog, Bzi-Han的博客"><meta name="viewport" content="width=device-width, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no, initial-scale=1"><!-- Google Analytics --><script>(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q || []).push(arguments)},i[r].l=1 * new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

ga('create', 'G-PDQ9KC0268', 'www.googletagmanager.com');
ga('send', 'pageview');</script><!-- End Google Analytics -->
<!-- Baidu Analytics --><script>var _hmt = _hmt || [];
(function() {
var hm = document.createElement("script");
hm.src = "//hm.baidu.com/hm.js?" + 'acc600f52de48f3cdbea41a9971e8278';
var s = document.getElementsByTagName("script")[0];
s.parentNode.insertBefore(hm, s);
})();</script><!-- End Baidu Analytics --><link rel="icon" href="/images/favicon.png"><link rel="stylesheet" href="/style/common/bulma.css"><link rel="stylesheet" href="/style/base.css"><link rel="stylesheet" href="/style/common/helper.css"><script src="/js/common.js"></script><link rel="stylesheet" href="/style/post.css"><link rel="stylesheet" href="/style/themes/highlight-theme-light.css"><script src="/js/highlight.pack.js"></script><meta name="description" content="对C++ Coroutine feature的后续展开。
前言本文仅供学习探讨之用，如果侵犯了您的权益请联系我删除。
工具
Visual Studio Code

基本介绍协程这玩意我觉得其实没必要多做什么介绍，现在流行的语言基本上都有这玩意，网上也有很多相关的文章。如果你还没听过的话我觉得你可以先谷歌或百度查查相关资料。

从C++推出协程特性都已经两年了。虽说刚出的时候就造了个异步任务的轮子，不过一直没什么机会用，后来也就扔一边了。
最近想起又拿出来试了试，发现有点难用。加上我想写篇文章记录一下一些设计思路，索性就直接重构了一下，并增加一些新的功能。
进入正题，因为本期代码比较长所以本文中应该不会出现完整的代码，只会把基本写法和一些关键的设计部分拿出来解释说明。
至于完整的代码实现与简单测试都已上传至我.."><meta name="generator" content="Hexo 6.1.0"><link rel="alternate" href="/atom.xml" title="Bzi-Han的博客" type="application/atom+xml">
</head><body class="is-flex is-flex-direction-column"><header class="header-widget is-flex-shrink-0 is-hidden-mobile"><div class="container is-fullhd is-flex is-justify-content-space-between is-align-items-center is-full-height"><section class="is-hidden-mobile is-flex-shrink-0"><h2><a href="/">Bzi-Han's blog</a></h2></section><h3 class="is-hidden-mobile is-family-serif is-full-height is-flex is-align-items-center is-flex-shrink-0"><div class="is-full-height" id="postTopic"><p class="is-full-height is-flex-shrink-0 is-flex is-align-items-center is-justify-content-center">[编程] 使用C++20实现异步任务与单/多线程的协程调度器</p><p class="is-full-height is-flex-shrink-0 is-flex is-align-items-center is-justify-content-center">点击返回顶部</p></div></h3><aside class="is-flex-shrink-0"><h3 class="is-inline-block"><a href="/">首页</a></h3><h3 class="is-inline-block"><a href="/about">关于</a></h3><h3 class="is-inline-block"><a href="/archives">归档</a></h3></aside></div></header><header class="is-flex header-widget is-flex-shrink-0 is-align-items-center is-justify-content-center is-hidden-tablet"><h3 class="is-inline-block"><a href="/">首页</a></h3><h3 class="is-inline-block"><a href="/about">关于</a></h3><h3 class="is-inline-block"><a href="/archives">归档</a></h3></header><main><main class="container is-max-widescreen content section post-page pt-4 px-4"><div class="columns is-flex-desktop is-justify-content-center is-flex-direction-row-reverse"><div class="column is-3 is-hidden-mobile"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%89%8D%E8%A8%80"><span class="toc-text">前言</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B7%A5%E5%85%B7"><span class="toc-text">工具</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E4%BB%8B%E7%BB%8D"><span class="toc-text">基本介绍</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BC%96%E8%AF%91%E5%99%A8%E6%94%AF%E6%8C%81"><span class="toc-text">编译器支持</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9F%BA%E7%A1%80%E5%8D%8F%E7%A8%8B"><span class="toc-text">基础协程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8D%8F%E7%A8%8B%E4%BB%BB%E5%8A%A1%E8%AE%BE%E8%AE%A1"><span class="toc-text">协程任务设计</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E7%A1%80%E7%BB%93%E6%9E%84"><span class="toc-text">基础结构</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#TaskBase"><span class="toc-text">TaskBase</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#task-promise-type-base"><span class="toc-text">task_promise_type_base</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#final-suspend"><span class="toc-text">final_suspend</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#yield-value"><span class="toc-text">yield_value</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#task-promise-type"><span class="toc-text">task_promise_type</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Task"><span class="toc-text">Task</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#co-delay%E8%AF%AD%E6%B3%95"><span class="toc-text">co_delay语法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#co-switch%E8%AF%AD%E6%B3%95"><span class="toc-text">co_switch语法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#co-finally%E8%AF%AD%E6%B3%95"><span class="toc-text">co_finally语法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%B0%83%E5%BA%A6%E5%99%A8%E8%AE%BE%E8%AE%A1"><span class="toc-text">调度器设计</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8D%95%E7%BA%BF%E7%A8%8B%E8%B0%83%E5%BA%A6%E5%99%A8"><span class="toc-text">单线程调度器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%9A%E7%BA%BF%E7%A8%8B%E8%B0%83%E5%BA%A6%E5%99%A8"><span class="toc-text">多线程调度器</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%93%E8%AF%AD"><span class="toc-text">结语</span></a></li></ol></div><div class="column is-9"><header class="my-4"></header><h1 class="mt-0 mb-1 is-family-serif" id="postTitle">[编程] 使用C++20实现异步任务与单/多线程的协程调度器</h1><time class="has-text-grey" datetime="2022-12-17T04:59:49.000Z">2022-12-17</time><article class="mt-2 post-content"><p>对C++ Coroutine feature的后续展开。</p>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本文仅供学习探讨之用，如果侵犯了您的权益请联系我删除。</p>
<h2 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h2><ol>
<li><a target="_blank" rel="noopener" href="https://code.visualstudio.com/" title="Visual Studio Code Official">Visual Studio Code</a></li>
</ol>
<h2 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h2><p>协程这玩意我觉得其实没必要多做什么介绍，现在流行的语言基本上都有这玩意，网上也有很多相关的文章。如果你还没听过的话我觉得你可以先谷歌或百度查查相关资料。</p>
<p><img src="/images/sticker_darksee.jpg" alt="暗中观察"></p>
<p>从<code>C++</code>推出协程特性都已经两年了。虽说刚出的时候就造了个异步任务的轮子，不过一直没什么机会用，后来也就扔一边了。</p>
<p>最近想起又拿出来试了试，发现有点难用。加上我想写篇文章记录一下一些设计思路，索性就直接重构了一下，并增加一些新的功能。</p>
<p>进入正题，因为本期代码比较长所以本文中应该不会出现完整的代码，只会把基本写法和一些关键的设计部分拿出来解释说明。</p>
<p>至于完整的代码实现与简单测试都已上传至我的Github仓库中，如果你感兴趣可以自行跳转查看。</p>
<p><a target="_blank" rel="noopener" href="https://github.com/Bzi-Han/coroutine">仓库地址</a>：<a target="_blank" rel="noopener" href="https://github.com/Bzi-Han/coroutine">https://github.com/Bzi-Han/coroutine</a></p>
<h2 id="编译器支持"><a href="#编译器支持" class="headerlink" title="编译器支持"></a>编译器支持</h2><p>使用本协程库的一些限制条件</p>
<p>MSVC: <code>19.29.30145^</code></p>
<p>GCC: <code>12.2^</code></p>
<p>CLANG: <code>15.0.0^</code></p>
<p>如果你的编译器版本低于以上版本的请自行测试。</p>
<h2 id="基础协程"><a href="#基础协程" class="headerlink" title="基础协程"></a>基础协程</h2><p>一个基础的协程是由一个类或结构体包含着一个公开的名字固定为<code>promise_type</code>的结构体或类构成的，只要你的<code>promise_type</code>必要的成员都是公开的就行。</p>
<p>必要的成员有以下几个</p>
<ol>
<li><code>get_return_object()</code>用于返回实际的协程对象。</li>
<li><code>initial_suspend()</code>协程对象创建后的初始暂停点。</li>
<li><code>final_suspend()</code>协程执行完的最终暂停点。</li>
<li><code>return_value()</code>或<code>return_void()</code>用于接收协程的返回值。</li>
<li><code>unhandled_exception()</code>用于处理协程中抛出的未在内部处理的异常。</li>
</ol>
<p>可选的成员有以下几个</p>
<ol>
<li><code>yield_value()</code>用于接收<code>co_yield</code>的值。</li>
<li><code>await_transform()</code>或<code>operator co_await</code>用于对<code>co_await</code>语法的重载。</li>
<li><code>get_return_object_on_allocation_failure()</code>用于接管协程分配内存失败时默认抛出<code>std::bad_alloc</code>异常的操作。</li>
</ol>
<p>接下来我们来看以下一个最简单的协程该怎么写，上代码</p>
<pre><code>struct task_promise_type;

struct task : std::coroutine_handle&lt;task_promise_type&gt;
&#123;
    using promise_type = task_promise_type;
&#125;;

struct task_promise_type
&#123;
    task get_return_object() &#123; return &#123;task::from_promise(*this)&#125;; &#125;

    std::suspend_always initial_suspend() noexcept &#123; return &#123;&#125;; &#125;

    std::suspend_always final_suspend() noexcept &#123; return &#123;&#125;; &#125;

    void return_void() &#123;&#125;

    void unhandled_exception() &#123;&#125;
&#125;;
</code></pre>
<p>这里<code>task</code>继承<code>std::coroutine_handle</code>属于偷懒写法，由父类来接收协程句柄并使用父类的接口进行管理，实际在<code>get_return_object()</code>时协程的句柄可有你自己自行分配。</p>
<p>例如不继承<code>std::coroutine_handle</code>并在<code>task</code>的构造函数中接收协程句柄并存入私有成员等待后续使用，然后在析构函数中去销毁协程(<code>handle.destroy()</code>)就可实现通过<code>RAII</code>自动管理协程的生命周期，后面介绍库的时候会说到。</p>
<p><strong>需要了解</strong>的是<code>initial_suspend</code>与<code>final_suspend</code>的返回值均为一个<code>awaitable</code>。</p>
<p><code>awaitable</code>决定了当前协程后续的流程走向，这里使用的<code>std::suspend_always</code>为语言提供的默认<code>awaitable</code>之一，此外还有个<code>std::suspend_never</code>表示不暂停。</p>
<p><code>awaitable</code>也可以自己实现，与<code>promise_type</code>相似，其必须包含以下成员</p>
<ol>
<li><code>await_ready()</code>用于决定当前协程是否暂停。</li>
<li><code>await_suspend()</code>如当前协程决定暂停，则会进入此函数。</li>
<li><code>await_resume()</code>当前协程准备继续执行时会进入此函数，其返回值就是<code>co_await</code>的返回值。</li>
</ol>
<p>那么怎么用</p>
<pre><code>task test01()
&#123;
    std::cout &lt;&lt; &quot;黑之契约者给我整破防了&quot; &lt;&lt; std::endl;
    co_await std::suspend_always&#123;&#125;;
    std::cout &lt;&lt; &quot;继续破防&quot; &lt;&lt; std::endl;
&#125;

int main()
&#123;
    auto coro01 = test01();

    coro01.resume();
    std::cout &lt;&lt; &quot;先缓缓&quot; &lt;&lt; std::endl;
    coro01.resume();
    coro01.destroy();

    return 0;
&#125;
</code></pre>
<hr>
<pre><code>黑之契约者给我整破防了
先缓缓
继续破防
</code></pre>
<p>还是很简单的，接下看一下可选的三个成员怎么使用</p>
<p>添加一个结构体<code>normal_function_transform</code>用于将普通的无参函数转成支持我们协程执行流程的<code>awaitable</code></p>
<p>并修改<code>promise_type</code>添加我们需要的三个成员函数</p>
<pre><code>template &lt;typename runable_t, typename return_t&gt;
struct normal_function_transform
&#123;
    runable_t runable;
    return_t result;

    constexpr bool await_ready() const noexcept &#123; return false; &#125;
    constexpr void await_suspend(std::coroutine_handle&lt;&gt; resumePoint) noexcept
    &#123;
        result = runable();
        // resumePoint.resume()
        //   这里可以直接在这里释放继续执行当前协程，也可以等待外部调度。
        //   如果在这里继续执行当前协程则不会交出调度权。
    &#125;
    constexpr return_t await_resume() const noexcept
    &#123;
        return result;
    &#125;
&#125;;

template &lt;typename runable_t&gt;
struct normal_function_transform&lt;runable_t, void&gt;
&#123;
    runable_t runable;

    constexpr bool await_ready() const noexcept &#123; return false; &#125;
    constexpr void await_suspend(std::coroutine_handle&lt;&gt; resumePoint) const noexcept
    &#123;
        runable();
    &#125;
    constexpr void await_resume() const noexcept &#123;&#125;
&#125;;

struct task_promise_type
&#123;
    task get_return_object() &#123; return &#123;task::from_promise(*this)&#125;; &#125;

    std::suspend_always initial_suspend() noexcept &#123; return &#123;&#125;; &#125;

    std::suspend_always final_suspend() noexcept &#123; return &#123;&#125;; &#125;

    void return_void() &#123;&#125;

    void unhandled_exception() &#123;&#125;

    std::suspend_always yield_value(const std::string_view &amp;data)
    &#123;
        std::cout &lt;&lt; &quot;[task_promise_type::yield_value] yield value: &quot; &lt;&lt; data &lt;&lt; std::endl;
        return &#123;&#125;;
    &#125;

    template &lt;typename runable_t&gt;
    auto await_transform(runable_t runable)
    &#123;
        return normal_function_transform&lt;runable_t, std::invoke_result_t&lt;runable_t&gt;&gt;&#123;runable&#125;;
    &#125;

    static task get_return_object_on_allocation_failure()
    &#123;
        std::cout &lt;&lt; &quot;[task_promise_type::get_return_object_on_allocation_failure] boom&quot; &lt;&lt; std::endl;
        return &#123;nullptr&#125;;
    &#125;
&#125;;
</code></pre>
<p>然后我们来看一下使用的代码以及效果</p>
<pre><code>int test00()
&#123;
    std::cout &lt;&lt; &quot;[test00] test00 called&quot; &lt;&lt; std::endl;
    return 233;
&#125;

task test01()
&#123;
    std::cout &lt;&lt; &quot;[test01] 黑之契约者给我整破防了&quot; &lt;&lt; std::endl;
    auto result = co_await test00;
    std::cout &lt;&lt; &quot;[test01] co_await result: &quot; &lt;&lt; result &lt;&lt; std::endl;
    std::cout &lt;&lt; &quot;[test01] 继续破防&quot; &lt;&lt; std::endl;
    co_yield &quot;提交一个值并交出调度权&quot;;
    std::cout &lt;&lt; &quot;[test01] 继续结束&quot; &lt;&lt; std::endl;
&#125;

int main()
&#123;
    auto coro01 = test01();

    coro01.resume();
    std::cout &lt;&lt; &quot;[main] 先缓缓&quot; &lt;&lt; std::endl;
    coro01.resume();
    std::cout &lt;&lt; &quot;[main] 又回来了&quot; &lt;&lt; std::endl;
    coro01(); //coro01.resume();
    coro01.destroy();

    return 0;
&#125;
</code></pre>
<hr>
<pre><code>[test01] 黑之契约者给我整破防了
[test00] test00 called
[main] 先缓缓
[test01] co_await result: 233
[test01] 继续破防
[task_promise_type::yield_value] yield value: 提交一个值并交出调度权
[main] 又回来了
[test01] 继续结束
</code></pre>
<p>那么到这里我觉得基础的协程也差不多了，接下来就来看一下这个库的协程与调度器的一些设计。</p>
<h2 id="协程任务设计"><a href="#协程任务设计" class="headerlink" title="协程任务设计"></a>协程任务设计</h2><h3 id="基础结构"><a href="#基础结构" class="headerlink" title="基础结构"></a>基础结构</h3><h4 id="TaskBase"><a href="#TaskBase" class="headerlink" title="TaskBase"></a>TaskBase</h4><p>这个类中包含了4个<code>static</code>类型的成员，全部为<code>thread_local</code>属性。</p>
<ol>
<li><code>m_taskQueue</code> 通用任务的执行队列。</li>
<li><code>m_delayQueue</code> 延迟任务的执行队列。</li>
<li><code>m_resumeQueue</code> 保存子协程运行结束的返回点队列。</li>
<li><code>m_finallyQueue</code> 保存当前协程运行结束后<code>co_finally</code>语法所执行的协程。</li>
</ol>
<h4 id="task-promise-type-base"><a href="#task-promise-type-base" class="headerlink" title="task_promise_type_base"></a>task_promise_type_base</h4><h5 id="final-suspend"><a href="#final-suspend" class="headerlink" title="final_suspend"></a>final_suspend</h5><p>这个函数有两个分支，一个是开启<code>co_finally</code>语法的分支，另一个是没开启的分支。</p>
<p>未开启<code>co_finally</code>语法的执行流程</p>
<ul>
<li>检测当前协程在<code>m_resumeQueue</code>中是否存在返回点，如果存在则将返回点放入<code>m_taskQueue</code>中，并将<code>m_resumeQueue</code>中的返回点抹除。</li>
</ul>
<p>开启<code>co_finally</code>语法的执行流程</p>
<ol>
<li>检测当前协程在<code>m_resumeQueue</code>中是否存在返回点，如果存在则将返回点取出，并将<code>m_resumeQueue</code>中的返回点抹除。</li>
<li>通过取出的返回点判断当前协程是不是<code>finally</code>协程，如果是则将返回点放入<code>m_taskQueue</code>并返回。</li>
<li>如果不是则检测当前协程是否存在<code>finally</code>协程，如果存在则将所有<code>finally</code>协程放入<code>m_taskQueue</code>并将返回点放入<code>m_resumeQueue</code>中。</li>
<li>如果当前协程不存在<code>finally</code>协程，则将取出的返回点放入<code>m_taskQueue</code>中。</li>
</ol>
<h5 id="yield-value"><a href="#yield-value" class="headerlink" title="yield_value"></a>yield_value</h5><p>这个函数有一个接收<code>yield_t</code>类型的默认函数与一个接收延迟任务类型参数的重载。</p>
<p>默认函数<code>yield_value(const std::conditional_t&lt;std::is_same_v&lt;void, yield_t&gt;, uint8_t, yield_t&gt; &amp;result)</code>的执行流程</p>
<ol>
<li>将提交上来的<code>result</code>存入预定的<code>std::vector</code>中。</li>
<li>将自身协程放入<code>m_taskQueue</code>中等待再次调度。</li>
</ol>
<p>重载函数<code>yield_value(deferrable &amp;&amp;defer)</code>的执行流程</p>
<ul>
<li>根据传进的参数构造延迟任务并放入<code>m_delayQueue</code>中等待调度。</li>
</ul>
<h4 id="task-promise-type"><a href="#task-promise-type" class="headerlink" title="task_promise_type"></a>task_promise_type</h4><p>这个类继承于<code>task_promise_type_base</code>，有一个默认入口与一个类型偏特化入口。</p>
<p>默认入口接收任何类型的<code>return_t</code>。</p>
<p>偏特化入口只接收<code>void</code>类型的<code>return_t</code>。</p>
<p>这样做的目的是用于实现无返回值<code>promise_type</code>与有返回值<code>promise_type</code>的同时兼容。</p>
<h4 id="Task"><a href="#Task" class="headerlink" title="Task"></a>Task</h4><p>这个类继承于<code>TaskBase</code>，是实际协程的实现类，实际协程调度时操作的就是当前<code>Task</code>继承于<code>TaskBase</code>的4个任务队列。</p>
<p>该类使用<code>using alias</code>对<code>promise_type</code>进行定义并使用私有成员<code>std::coroutine_handle&lt;promise_type&gt; m_coroutineHandle</code>对<code>promise_type</code>初始化的协程句柄进行保存。</p>
<h3 id="co-delay语法"><a href="#co-delay语法" class="headerlink" title="co_delay语法"></a>co_delay语法</h3><p><code>co_delay</code>语法的实现为</p>
<pre><code>#define co_delay co_yield coroutine::task_implement::deferrable&#123;&#125; =
</code></pre>
<p>其中<code>deferrable</code>为一个用来标识和存储延迟任务的结构体，他的定义如下</p>
<pre><code>struct deferrable
&#123;
    void *task = nullptr;
    std::chrono::milliseconds timeout;

    deferrable &amp;&amp;operator=(size_t timeout)
    &#123;
        this-&gt;timeout = std::chrono::milliseconds&#123;timeout&#125;;

        return std::move(*this);
    &#125;
&#125;;
</code></pre>
<p>可以看到它实际上是使用<code>co_yield</code>语法对当前协程提交了一个<code>deferrable</code>，而延迟执行的毫秒数为<code>co_delay</code>后面跟的立即数。如：<code>co_delay 233;</code>的延迟时间为233毫秒啊。</p>
<h3 id="co-switch语法"><a href="#co-switch语法" class="headerlink" title="co_switch语法"></a>co_switch语法</h3><p><code>co_switch</code>语法的实现为</p>
<pre><code>#define co_switch co_yield &#123;&#125;
</code></pre>
<p>与<code>co_delay</code>一样，不过提交的是一个<code>initialize list</code>，实际走的是一个<code>uint8_t</code>类型的<code>0</code>。</p>
<h3 id="co-finally语法"><a href="#co-finally语法" class="headerlink" title="co_finally语法"></a>co_finally语法</h3><p>它的使用方法为</p>
<pre><code>co_finally
&#123;
    // write any code...
&#125;;
</code></pre>
<p><code>co_finally</code>语法的实现为</p>
<pre><code>#define _COROMAKELAMBDA(x, y) x##y
#define COROMAKELAMBDA(x, y) _COROMAKELAMBDA(x, y)
#define co_finally coroutine::task_implement::__CoroFinally COROMAKELAMBDA(lambda, __COUNTER__) = [&amp;]() -&gt; coroutine::task_implement::Task&lt;void, void&gt;
</code></pre>
<p>这里<code>COROMAKELAMBDA</code>宏用于实现随机的变量名，其实际名为<code>lambda</code>+<code>序号</code>，序号由编译器提供的宏<code>__COUNTER__</code>提供，它的值是它使用的第几次次数的值，从<code>0</code>开始。</p>
<p><code>__CoroFinally</code>类的定义如下</p>
<pre><code>template &lt;typename coro_t&gt;
class __CoroFinally
&#123;
public:
    __CoroFinally(coro_t coro)
        : m_coro(std::move(coro))
    &#123;
    &#125;
    ~__CoroFinally()
    &#123;
        TaskBase::m_finallyQueue.push(&#123;m_coro(), false&#125;);
    &#125;

private:
    coro_t m_coro;
&#125;;
</code></pre>
<p>可以看到，这里实际上是声明了一个名为<code>lambda</code>+<code>x</code>的<code>__CoroFinally</code>类型的局部变量。</p>
<p>在初始化的时候传入一个返回值和提交值都为<code>void</code>的一个不完整的<code>lambda</code>表达式，<br>其使用用户所编写的代码块进行补全，变成一个完整的<code>lambda</code>表达式。</p>
<p>在当前协程运行完走出作用域时，由于<code>RAII</code>的作用<code>__CoroFinally</code>会将自身持有的协程放入<code>m_finallyQueue</code>中，然后等待调度器的执行并完成<code>finally</code>所要执行的工作。</p>
<h2 id="调度器设计"><a href="#调度器设计" class="headerlink" title="调度器设计"></a>调度器设计</h2><p>基于上面设计的结构，在编写调度器时我们只需要关注与维护<code>TaskBase</code>的4个静态成员即可。</p>
<h3 id="单线程调度器"><a href="#单线程调度器" class="headerlink" title="单线程调度器"></a>单线程调度器</h3><p>对于单线程调度器，我们只需要在调用<code>run</code>函数时检测<code>m_taskQueue</code>与<code>m_delayQueue</code>是否为空，如果不为空则将协程取出并执行清空即可。</p>
<p>普通任务与延迟任务的调度优先级取决于个人，这里写的流程为</p>
<ol>
<li>检测<code>m_delayQueue</code>与<code>m_taskQueue</code>是否为空，如果都为空则跳出死循环并结束此次的运行。</li>
<li>如果<code>m_delayQueue</code>不为空，取出头部任务并判断是否已超时，如果已超时则执行取出的任务并从<code>m_delayQueue</code>中抹除。</li>
<li>检测<code>m_taskQueue</code>是否为空，如果为空则使用<code>continue</code>回到死循环的头部开始执行。</li>
<li>如果<code>m_taskQeueu</code>不为空，取出头部的任务执行，并从<code>m_taskQueue</code>中抹除。</li>
</ol>
<h3 id="多线程调度器"><a href="#多线程调度器" class="headerlink" title="多线程调度器"></a>多线程调度器</h3><p>先来看一下多线程调度器的成员与任务的转移流程</p>
<pre><code>using channel_t = std::promise&lt;std::pair&lt;void *, void *&gt;&gt; *;
using future_t = std::future&lt;std::pair&lt;void *, void *&gt;&gt;;

constexpr static size_t m_minTasks = 2, m_maxTasks = 3; // 本地任务队列任务数量的最大值与最小值
static size_t m_maxWokers;                              // 最大工作线程数量
static bool m_work;                                     // 用于控制线程池的开关
static std::mutex m_globalMutex, m_localMutex;          // 队列锁
static std::vector&lt;std::thread&gt; m_workers;              // 工作线程池
static std::queue&lt;void *&gt; m_globalQueue;                // 全局任务队列，给调度器添加任务时会添加到此队列中
static std::queue&lt;channel_t&gt; m_channels;                // 用于偷取其他工作线程中的本地任务的通信通道
</code></pre>
<p>当我们给调度器添加一个任务时，首先会被添加到<code>m_globalQueue</code>全局任务队列中，然后每个工作线程会在<code>m_globalQueue</code>中获取属于自己的任务。</p>
<p>获取到的任务会添加到当前线程的本地队列中，也就是<code>TaskBase</code>的4个静态成员。</p>
<p>当有空闲线程出现时，它会往<code>m_channels</code>中添加自己接收其他线程”施舍”的任务的<code>promise</code>，如果其他线程的本地队列过长，就会将自己的头部任务交给其他在空闲中的线程来执行，自己则执行下一个任务。</p>
<p><code>run</code>函数的执行流程</p>
<ul>
<li>检测当前工作线程数量是否大于<code>m_maxWokers</code>，如果还不足则添加工作线程至可以执行本次<code>m_globalQueue</code>队列中任务数量的工作线程数量(最多不超过上限)。</li>
</ul>
<p><code>worker</code>函数的执行流程</p>
<p>由于基础流程与单线程调度器基本一致，所以我们只讲不同的部分。</p>
<ol>
<li>检测<code>m_globalQueue</code>是否为不为空且<code>m_taskQueue</code>本地任务队列存在的任务数量是否小于<code>m_minTasks</code>。</li>
<li>如果小于这个数量则从<code>m_globalQueue</code>获取一个任务并放入<code>m_taskQueue</code>中。</li>
<li>当<code>m_globalQueue</code>与<code>m_taskQueue</code>都为空，而<code>m_work</code>不为<code>false</code>时，创建一个<code>promise</code>并放入<code>m_channels</code>中。</li>
<li>每隔1s检测一次<code>promise</code>是否已经准备就绪，若已经准备就绪(已经偷到别的线程的本地任务)，则从中取出偷取的到的任务并加入<code>m_taskQueue</code>中。</li>
</ol>
<p>至此，对于这个协程库的介绍就完了。</p>
<h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>这篇文章咕咕咕了好久</p>
<p><img src="/images/sticker_qiqidao.png" alt="qiqi"></p>
<p>那就这样了，有缘再见~</p>
</article><section class="jump-container is-flex is-justify-content-space-between my-6"><!-- em is empty placeholder--><a class="button is-default" href="/2023/03/16/%E6%BC%94%E7%A4%BA-%E4%BD%BF%E7%94%A8Github-Pages%E9%85%8D%E7%BD%AEAndroid6-0-Termux%E6%97%A7%E4%BB%93%E5%BA%93-%E5%AE%98%E6%96%B9%E4%B8%8D%E5%86%8D%E7%BB%B4%E6%8A%A4/" title="[演示] 使用Github Pages配置Android6.0 Termux旧仓库(官方不再维护)"><i class="iconfont icon-prev mr-2 has-text-grey"></i><span class="has-text-weight-semibold">上一页: [演示] 使用Github Pages配置Android6.0 Termux旧仓库(官方不再维护)</span></a><a class="button is-default" href="/2022/10/16/%E7%BC%96%E7%A8%8B-%E8%AE%BAC++%E6%96%B0%E8%AF%AD%E6%B3%95-finally%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0/" title="[编程] 论C++&quot;新语法&quot;-finally如何实现"><span class="has-text-weight-semibold">下一页: [编程] 论C++&quot;新语法&quot;-finally如何实现</span><i class="iconfont icon-next ml-2 has-text-grey"></i></a></section><article class="mt-6 comment-container"><script async repo="Bzi-Han/bzi-han.github.io" src="https://utteranc.es/client.js" issue-term="pathname" theme="preferred-color-scheme"></script></article></div></div></main></main><footer class="is-flex is-flex-direction-column is-align-items-center is-flex-shrink-0 is-family-serif"><section class="sns-container"><!-- Github--><a title="github" target="_blank" rel="noopener nofollow" href="//github.com/Bzi-Han"><i class="iconfont icon-github"></i></a><!-- Ins--><!-- RSS--><!-- 知乎--><!-- 领英--><!-- 脸书--></section><p><span>Copyright ©</span><span> Bzi-Han 2023</span></p><div class="is-flex is-justify-content-center is-flex-wrap-wrap"><p>Powered by Hexo &verbar;&nbsp;</p><p class="is-flex is-justify-content-center"><a title="Hexo theme author" target="_blank" rel="noopener" href="//github.com/haojen">Theme by Haojen&nbsp;</a></p><div style="margin-top: 2px"><a class="github-button" title="github-button" target="_blank" rel="noopener" href="https://github.com/haojen/hexo-theme-Claudia" data-color-scheme="no-preference: light; light: light; dark: dark;" data-show-count="true"></a></div></div><div><span></span></div></footer><script async defer src="https://buttons.github.io/buttons.js"></script><script src="/js/post.js"></script></body></html>