<!DOCTYPE html><html class="appearance-auto" lang="zh-CN"><head><meta charset="UTF-8"><title>[编程] 在C++中实现一个内存池与几种垃圾回收机制(GC策略)</title><meta name="description" content="Bzi-Han's blog, Bzi-Han的博客"><meta name="viewport" content="width=device-width, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no, initial-scale=1"><!-- Google Analytics --><!-- End Google Analytics -->
<!-- Baidu Analytics --><!-- End Baidu Analytics --><link rel="icon" href="/images/favicon.png"><link rel="stylesheet" href="/style/common/bulma.css"><link rel="stylesheet" href="/style/base.css"><link rel="stylesheet" href="/style/common/helper.css"><script src="/js/common.js"></script><link rel="stylesheet" href="/style/post.css"><link rel="stylesheet" href="/style/themes/highlight-theme-light.css"><script src="/js/highlight.pack.js"></script><meta name="description" content="在特定情况下使用内存池可显著提高性能。
前言本文仅供学习探讨之用，如果侵犯了您的权益请联系我删除。
工具
Visual Studio Code
Graphviz

需求与思考
可限定内存池最大可向系统申请的内存大小
尽量保证池中的内存单元都在连续的内存上
内存池每次可申请任意大小的内存
进行内存的申请时若内存池的空闲空间不足且所需内存未超过内存池最大限定可申请的内存时将进行动态扩容
内存单元释放的同时进行临近内存碎片的合并
当前需要申请的内存加上已申请的内存若超过限定最大可向系统申请的内存大小时抛出异常


Garbage Collection
内存标记算法
内存标记整理算法
内存分代标记整理算法


当前需要申请的内存加上已申请的内存若超过限定最大可向系统申请的内存大小时启动GC进行垃圾回收
若启动GC后.."><meta name="generator" content="Hexo 6.1.0"><link rel="alternate" href="/atom.xml" title="Bzi-Han的博客" type="application/atom+xml">
</head><body class="is-flex is-flex-direction-column"><header class="header-widget is-flex-shrink-0 is-hidden-mobile"><div class="container is-fullhd is-flex is-justify-content-space-between is-align-items-center is-full-height"><section class="is-hidden-mobile is-flex-shrink-0"><h2><a href="/">Bzi-Han's blog</a></h2></section><h3 class="is-hidden-mobile is-family-serif is-full-height is-flex is-align-items-center is-flex-shrink-0"><div class="is-full-height" id="postTopic"><p class="is-full-height is-flex-shrink-0 is-flex is-align-items-center is-justify-content-center">[编程] 在C++中实现一个内存池与几种垃圾回收机制(GC策略)</p><p class="is-full-height is-flex-shrink-0 is-flex is-align-items-center is-justify-content-center">点击返回顶部</p></div></h3><aside class="is-flex-shrink-0"><h3 class="is-inline-block"><a href="/">首页</a></h3><h3 class="is-inline-block"><a href="/about">关于</a></h3><h3 class="is-inline-block"><a href="/archives">归档</a></h3></aside></div></header><header class="is-flex header-widget is-flex-shrink-0 is-align-items-center is-justify-content-center is-hidden-tablet"><h3 class="is-inline-block"><a href="/">首页</a></h3><h3 class="is-inline-block"><a href="/about">关于</a></h3><h3 class="is-inline-block"><a href="/archives">归档</a></h3></header><main><main class="container is-max-widescreen content section post-page pt-4 px-4"><div class="columns is-flex-desktop is-justify-content-center is-flex-direction-row-reverse"><div class="column is-3 is-hidden-mobile"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%89%8D%E8%A8%80"><span class="toc-text">前言</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B7%A5%E5%85%B7"><span class="toc-text">工具</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9C%80%E6%B1%82%E4%B8%8E%E6%80%9D%E8%80%83"><span class="toc-text">需求与思考</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E6%B1%A0%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="toc-text">内存池数据结构</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9C%80%E6%B1%82%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88"><span class="toc-text">需求的解决方案</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E6%B1%A0%E4%BB%A3%E7%A0%81%E5%AE%9A%E4%B9%89%E4%B8%8E%E5%AE%9E%E7%8E%B0"><span class="toc-text">内存池代码定义与实现</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%A7%E8%83%BD%E5%AF%B9%E6%AF%94"><span class="toc-text">性能对比</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E6%B1%A0%E9%87%8A%E6%94%BE%E5%8D%95%E5%85%83%E6%97%B6%E7%9A%84Graphviz%E5%9B%BE"><span class="toc-text">内存池释放单元时的Graphviz图</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Garbage-Collection"><span class="toc-text">Garbage Collection</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8E%9F%E5%A7%8B%E6%8C%87%E9%92%88%E7%9A%84%E5%B0%81%E8%A3%85"><span class="toc-text">原始指针的封装</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E6%A0%87%E8%AE%B0%E7%AE%97%E6%B3%95"><span class="toc-text">内存标记算法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E6%A0%87%E8%AE%B0%E6%95%B4%E7%90%86%E7%AE%97%E6%B3%95"><span class="toc-text">内存标记整理算法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E5%88%86%E4%BB%A3%E6%A0%87%E8%AE%B0%E6%95%B4%E7%90%86%E7%AE%97%E6%B3%95"><span class="toc-text">内存分代标记整理算法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#GC%E5%89%8D%E5%90%8E%E7%9A%84%E6%93%8D%E4%BD%9C"><span class="toc-text">GC前后的操作</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#C-%E4%BD%BF%E7%94%A8%E7%89%B9%E5%8C%96"><span class="toc-text">C++使用特化</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%93%E8%AF%AD"><span class="toc-text">结语</span></a></li></ol></div><div class="column is-9"><header class="my-4"></header><h1 class="mt-0 mb-1 is-family-serif" id="postTitle">[编程] 在C++中实现一个内存池与几种垃圾回收机制(GC策略)</h1><time class="has-text-grey" datetime="2022-04-28T04:04:16.000Z">2022-04-28</time><article class="mt-2 post-content"><p>在特定情况下使用内存池可显著提高性能。</p>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本文仅供学习探讨之用，如果侵犯了您的权益请联系我删除。</p>
<h2 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h2><ol>
<li><a target="_blank" rel="noopener" href="https://code.visualstudio.com/" title="Visual Studio Code Official">Visual Studio Code</a></li>
<li><a target="_blank" rel="noopener" href="http://graphviz.org/" title="Graphviz Official">Graphviz</a></li>
</ol>
<h2 id="需求与思考"><a href="#需求与思考" class="headerlink" title="需求与思考"></a>需求与思考</h2><ol>
<li>可限定内存池最大可向系统申请的内存大小</li>
<li>尽量保证池中的内存单元都在连续的内存上</li>
<li>内存池每次可申请任意大小的内存</li>
<li>进行内存的申请时若内存池的空闲空间不足且所需内存未超过内存池最大限定可申请的内存时将进行动态扩容</li>
<li>内存单元释放的同时进行临近内存碎片的合并</li>
<li>当前需要申请的内存加上已申请的内存若超过限定最大可向系统申请的内存大小时抛出异常</li>
</ol>
<ul>
<li>Garbage Collection<ul>
<li>内存标记算法</li>
<li>内存标记整理算法</li>
<li>内存分代标记整理算法</li>
</ul>
</li>
<li>当前需要申请的内存加上已申请的内存若超过限定最大可向系统申请的内存大小时启动GC进行垃圾回收</li>
<li>若启动GC后仍无法分配内存则抛出异常</li>
</ul>
<h2 id="内存池数据结构"><a href="#内存池数据结构" class="headerlink" title="内存池数据结构"></a>内存池数据结构</h2><pre><code>// 内存单元
struct MemoryUnit
&#123;
    uint8_t *data;        // 内存单元的数据地址
    size_t size;          // 内存的数据大小
    MemoryBlock *block;   // 内存单元所属的内存块
    MemoryUnit *nextUnit; // 下一个内存单元
    MemoryUnit *prevUnit; // 上一个内存单元
&#125;;

// 内存块
struct MemoryBlock
&#123;
    uint8_t *data;          // 内存块的数据地址
    size_t size;            // 内存块的数据大小
    size_t freeTotal;       // 内存块中剩余的空闲内存大小
    MemoryUnit *freeList;   // 内存块中的空闲内存单元
    MemoryUnit *usedList;   // 内存块中的已使用内存单元
    MemoryBlock *nextBlock; // 下一个内存块
    MemoryBlock *prevBlock; // 上一个内存块
&#125;;

// 内存池
struct MemoryPool
&#123;
    size_t systemPageSize; // 当前操作系统的内存页定义大小
    size_t blockMinSize;   // 申请内存块时至少申请不能小于块最小大小
    size_t poolMaxSize;    // 内存池的最大可向系统申请的内存大小
    size_t poolSize;       // 内存池的当前大小
    MemoryBlock *blocks;   // 内存块单向循环链表
&#125;;
</code></pre>
<h2 id="需求的解决方案"><a href="#需求的解决方案" class="headerlink" title="需求的解决方案"></a>需求的解决方案</h2><ol>
<li>结构体<code>MemoryPool</code>的成员<code>poolMaxSize</code>与<code>poolSize</code>用于对比并限定最大可申请的内存大小</li>
<li>结构体<code>MemoryPool</code>的成员<code>blockMinSize</code>用于确保单次申请过小的内存单元导致过多的不连续内存块</li>
<li>结构体<code>MemoryUnit</code>的成员<code>size</code>用于存放当前内存单元所使用的内存大小</li>
<li>若当前条件满足动态扩容的条件时，向系统申请新的内存块并使用头插法插入结构体<code>MemoryPool</code>的成员<code>blocks</code>链表中，这也是将其设计为单项循环链表的原因。与此同此还要更新成员<code>poolSize</code>的数值。</li>
<li>内存碎片的合并将会在内存单元释放时自动进行<strong>临近</strong>单元合并，这也是结构体<code>MemoryUnit</code>设计为双向链表的原因之一</li>
<li>使用当前想要申请的内存大小加上结构体<code>MemoryPool</code>的成员<code>poolSize</code>的数值进行判断即可</li>
</ol>
<h2 id="内存池代码定义与实现"><a href="#内存池代码定义与实现" class="headerlink" title="内存池代码定义与实现"></a>内存池代码定义与实现</h2><p>类<code>MemoryPool</code>的定义</p>
<pre><code>class MemoryPool
&#123;
public:
    struct MemoryBlock;

    struct MemoryUnit
    &#123;
        uint8_t *data;
        size_t size;
        MemoryBlock *block;
        MemoryUnit *nextUnit;
        MemoryUnit *prevUnit;
    &#125;;

    struct MemoryBlock
    &#123;
        uint8_t *data;
        size_t size;
        size_t freeTotal;
        MemoryUnit *freeList;
        MemoryUnit *usedList;
        MemoryBlock *nextBlock;
        MemoryBlock *prevBlock;
    &#125;;

    using unit_t = MemoryUnit;
    using block_t = MemoryBlock;

public:
    MemoryPool(size_t poolMaxSize = 128 * 1024 * 1024, size_t blockMinSize = 4 * 1024 * 1024);
    ~MemoryPool();

    void *alloc(size_t size);
    void free(void *data);

private:
    block_t *allocBlock(size_t size);
    void freeBlock(block_t *block);

    unit_t *allocUnit(size_t size);
    void freeUnit(unit_t *unit);

private:
    size_t m_systemPageSize = 0;
    size_t m_poolMaxSize = 0;
    size_t m_blockMinSize = 0;
    size_t m_poolSize = 0;
    block_t *m_blocks = nullptr;
&#125;;
</code></pre>
<p>对于<code>MemoryPool::allocBlock</code>方法的实现</p>
<pre><code>MemoryPool::block_t *MemoryPool::allocBlock(size_t size)
&#123;
    // allocate memory block
    auto alignedSize = size + sizeof(block_t) + sizeof(unit_t);
    alignedSize = (alignedSize + (m_systemPageSize - 1)) &amp; ~(m_systemPageSize - 1); // align to system page size
    if (m_blockMinSize &gt; alignedSize)
        alignedSize = m_blockMinSize;

    auto block = reinterpret_cast&lt;block_t *&gt;(::VirtualAlloc(nullptr, alignedSize, MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE));
    if (nullptr == block)
        return nullptr;

    // initialize memory block
    block-&gt;data = reinterpret_cast&lt;uint8_t *&gt;(block) + sizeof(block_t);
    block-&gt;size = alignedSize - sizeof(block_t);
    auto dataPosition = block-&gt;data;

    // initialize memory used unit
    block-&gt;usedList = nullptr;

    // initialize memory free unit
    block-&gt;freeList = reinterpret_cast&lt;unit_t *&gt;(dataPosition);
    dataPosition += sizeof(unit_t);

    block-&gt;freeList-&gt;data = dataPosition;
    block-&gt;freeList-&gt;size = block-&gt;size - (dataPosition - block-&gt;data);
    block-&gt;freeList-&gt;nextUnit = block-&gt;freeList;
    block-&gt;freeList-&gt;prevUnit = block-&gt;freeList;
    block-&gt;freeList-&gt;block = block;

    block-&gt;freeTotal = block-&gt;freeList-&gt;size;

    // add to block list
    if (nullptr != m_blocks)
    &#123;
        block-&gt;prevBlock = m_blocks-&gt;prevBlock;
        block-&gt;nextBlock = m_blocks;
        m_blocks-&gt;prevBlock-&gt;nextBlock = block;
        m_blocks-&gt;prevBlock = block;
    &#125;
    else
    &#123;
        block-&gt;prevBlock = block;
        block-&gt;nextBlock = block;
        m_blocks = block;
    &#125;

    // update pool size
    m_poolSize += block-&gt;size + sizeof(block_t);

    return block;
&#125;
</code></pre>
<p>这里在申请内存时确保与当前操作系统内存页定义大小对齐。</p>
<p>对于<code>MemoryPool::freeBlock</code>方法的实现</p>
<pre><code>void MemoryPool::freeBlock(block_t *block)
&#123;
    // remove from block list
    if (m_blocks-&gt;prevBlock == block &amp;&amp; m_blocks-&gt;nextBlock == block)
        m_blocks = nullptr;
    else
    &#123;
        block-&gt;prevBlock-&gt;nextBlock = block-&gt;nextBlock;
        block-&gt;nextBlock-&gt;prevBlock = block-&gt;prevBlock;
        if (m_blocks == block)
            m_blocks = block-&gt;nextBlock;
    &#125;

    // update pool size
    m_poolSize -= block-&gt;size + sizeof(block_t);

    // free memory block
    ::VirtualFree(block, 0, MEM_RELEASE);
&#125;
</code></pre>
<p>对于<code>MemoryPool::allocUnit</code>方法的实现</p>
<pre><code>MemoryPool::unit_t *MemoryPool::allocUnit(size_t size)
&#123;
    // check if no block is available
    if (nullptr == m_blocks)
        return nullptr;

    // allocate memory unit
    auto block = m_blocks; // first block

    do
    &#123;
        // check if is there no enough memory in the block
        if (size &gt; block-&gt;freeTotal)
        &#123;
            block = block-&gt;nextBlock;
            continue;
        &#125;

        auto unit = block-&gt;freeList; // first free unit

        do
        &#123;
            // check if is there no enough memory in the unit
            if (size &gt; unit-&gt;size)
            &#123;
                unit = unit-&gt;nextUnit;
                continue;
            &#125;

            // check if unit size is more than wanted size, split unit
            if (unit-&gt;size &gt; size + sizeof(unit_t))
            &#123;
                auto newUnit = reinterpret_cast&lt;unit_t *&gt;(unit-&gt;data + size);
                newUnit-&gt;data = unit-&gt;data + size + sizeof(unit_t);
                newUnit-&gt;size = unit-&gt;size - size - sizeof(unit_t);
                newUnit-&gt;nextUnit = unit-&gt;nextUnit;
                newUnit-&gt;prevUnit = unit;
                newUnit-&gt;block = unit-&gt;block;
                unit-&gt;nextUnit-&gt;prevUnit = newUnit;
                unit-&gt;nextUnit = newUnit;
                unit-&gt;size = size;
            &#125;

            // remove unit from free list
            unit-&gt;prevUnit-&gt;nextUnit = unit-&gt;nextUnit;
            unit-&gt;nextUnit-&gt;prevUnit = unit-&gt;prevUnit;
            if (block-&gt;freeList == unit)
                block-&gt;freeList = unit-&gt;nextUnit;

            // add unit to used list
            if (nullptr == block-&gt;usedList)
            &#123;
                block-&gt;usedList = unit;
                unit-&gt;nextUnit = unit;
                unit-&gt;prevUnit = unit;
            &#125;
            else
            &#123;
                unit-&gt;nextUnit = block-&gt;usedList;
                unit-&gt;prevUnit = block-&gt;usedList-&gt;prevUnit;
                block-&gt;usedList-&gt;prevUnit-&gt;nextUnit = unit;
                block-&gt;usedList-&gt;prevUnit = unit;
            &#125;

            // update free total
            block-&gt;freeTotal -= unit-&gt;size;

            return unit;
        &#125; while (unit != block-&gt;freeList);

    &#125; while (block != m_blocks);

    return nullptr;
&#125;
</code></pre>
<p>对于<code>MemoryPool::freeUnit</code>方法的实现</p>
<pre><code>void MemoryPool::freeUnit(unit_t *unit)
&#123;
    auto freeSize = unit-&gt;size;

    // remove unit from used list
    if (unit-&gt;prevUnit == unit &amp;&amp; unit-&gt;nextUnit == unit)
        unit-&gt;block-&gt;usedList = nullptr;
    else
    &#123;
        unit-&gt;prevUnit-&gt;nextUnit = unit-&gt;nextUnit;
        unit-&gt;nextUnit-&gt;prevUnit = unit-&gt;prevUnit;
        if (unit-&gt;block-&gt;usedList == unit)
            unit-&gt;block-&gt;usedList = unit-&gt;nextUnit;
    &#125;

    // add the unit to the free list, order by address
    if (nullptr == unit-&gt;block-&gt;freeList)
    &#123;
        unit-&gt;nextUnit = unit;
        unit-&gt;prevUnit = unit;
        unit-&gt;block-&gt;freeList = unit;
    &#125;
    else
    &#123;
        auto prevUnit = unit-&gt;block-&gt;freeList;
        auto nextUnit = unit-&gt;block-&gt;freeList-&gt;nextUnit;

        if (prevUnit == prevUnit-&gt;prevUnit &amp;&amp; prevUnit == prevUnit-&gt;nextUnit)
        &#123;
            // combine units if is there near units
            if (unit-&gt;data + unit-&gt;size == reinterpret_cast&lt;uint8_t *&gt;(nextUnit)) // combine next unit
            &#123;
                unit-&gt;size += nextUnit-&gt;size + sizeof(unit_t);
                unit-&gt;nextUnit = unit;
                unit-&gt;prevUnit = unit;
                unit-&gt;block-&gt;freeList = unit;
            &#125;
            else if (prevUnit-&gt;data + prevUnit-&gt;size == reinterpret_cast&lt;uint8_t *&gt;(unit)) // combine prev unit
                prevUnit-&gt;size += unit-&gt;size + sizeof(unit_t);
            else // add unit to free list
            &#123;
                unit-&gt;nextUnit = nextUnit;
                unit-&gt;prevUnit = nextUnit;
                nextUnit-&gt;prevUnit = unit;
                nextUnit-&gt;nextUnit = unit;

                unit-&gt;block-&gt;freeList = nextUnit &lt; unit ? nextUnit : unit;
            &#125;
        &#125;
        else
        &#123;
            // find insert position
            while (nextUnit != unit-&gt;block-&gt;freeList &amp;&amp; nextUnit &lt; unit)
            &#123;
                prevUnit = nextUnit;
                nextUnit = nextUnit-&gt;nextUnit;
            &#125;

            // combine the units if is there are near units
            if (unit-&gt;data + unit-&gt;size == reinterpret_cast&lt;uint8_t *&gt;(nextUnit)) // combine next unit
            &#123;
                unit-&gt;size += nextUnit-&gt;size + sizeof(unit_t);
                unit-&gt;nextUnit = nextUnit-&gt;nextUnit;
                unit-&gt;prevUnit = nextUnit-&gt;prevUnit;
                nextUnit-&gt;prevUnit-&gt;nextUnit = unit;
                nextUnit-&gt;nextUnit-&gt;prevUnit = unit;
                nextUnit = nextUnit-&gt;nextUnit;
            &#125;

            if (prevUnit-&gt;data + prevUnit-&gt;size == reinterpret_cast&lt;uint8_t *&gt;(unit)) // combine prev unit
            &#123;
                prevUnit-&gt;size += unit-&gt;size + sizeof(unit_t);
                prevUnit-&gt;nextUnit = nextUnit;
                nextUnit-&gt;prevUnit = prevUnit;
            &#125;
        &#125;
    &#125;

    // update free total
    m_blocks-&gt;freeTotal += freeSize;
&#125;
</code></pre>
<p>这4个主要的方法实现好之后就是<code>MemoryPool::alloc</code>与<code>MemoryPool::free</code>两个方法的实现了，我们要做的只需要对上面4个方法进行逻辑的封装就好了。</p>
<p>对于<code>MemoryPool::alloc</code>方法的实现</p>
<pre><code>void *MemoryPool::alloc(size_t size)
&#123;
    if (0 == size)
        return nullptr;

    if (nullptr == m_blocks)
        m_blocks = allocBlock(size);

    auto unit = allocUnit(size);
    if (nullptr == unit)
    &#123;
        if (size + m_poolSize &gt; m_poolMaxSize)
            throw std::bad_alloc();

        auto block = allocBlock(size);
        if (nullptr == block)
            return nullptr;

        unit = allocUnit(size);
        if (nullptr == unit)
            return nullptr;
    &#125;

    return unit-&gt;data;
&#125;
</code></pre>
<p>对于<code>MemoryPool::free</code>方法的实现</p>
<pre><code>void MemoryPool::free(void *data)
&#123;
    if (nullptr == data)
        return;

    auto unit = reinterpret_cast&lt;unit_t *&gt;(reinterpret_cast&lt;uint8_t *&gt;(data) - sizeof(unit_t));
    if (nullptr == unit)
        return;

    if (nullptr == unit-&gt;block)
        return;

    freeUnit(unit);
&#125;
</code></pre>
<p>到这里，内存池的主体已经搭建好了，那接下来就对比一下性能。</p>
<h2 id="性能对比"><a href="#性能对比" class="headerlink" title="性能对比"></a>性能对比</h2><p>测试用的代码如下</p>
<pre><code>MemoryPool g_memoryPool(1 * 1024 * 1024 * 1024);

template &lt;typename runable_t&gt;
struct RunTickCount
&#123;
    runable_t &amp;&amp;runable;

    uint64_t operator()() const noexcept
    &#123;
        auto result = __rdtsc();

        runable();

        return __rdtsc() - result;
    &#125;
&#125;;

void test01()
&#123;
    for (size_t i = 0; i &lt; 100; i++)
    &#123;
        auto data = new char[8 * 1024 * 1024];
        delete[] data;
    &#125;
&#125;

void test02()
&#123;
    for (size_t i = 0; i &lt; 100; i++)
    &#123;
        auto data = ::VirtualAlloc(nullptr, 8 * 1024 * 1024, MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE);
        ::VirtualFree(data, 0, MEM_RELEASE);
    &#125;
&#125;

void test03()
&#123;
    for (size_t i = 0; i &lt; 100; i++)
    &#123;
        auto data = g_memoryPool.alloc(8 * 1024 * 1024);
        g_memoryPool.free(data);
    &#125;
&#125;

void test04()
&#123;
    for (size_t i = 0; i &lt; 100; i++)
        auto data = new char[8 * 1024 * 1024];
&#125;

void test05()
&#123;
    for (size_t i = 0; i &lt; 100; i++)
        auto data = ::VirtualAlloc(nullptr, 8 * 1024 * 1024, MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE);
&#125;

void test06()
&#123;
    for (size_t i = 0; i &lt; 100; i++)
        auto data = g_memoryPool.alloc(8 * 1024 * 1024);
&#125;

int main()
&#123;
    try
    &#123;
        std::cout &lt;&lt; &quot;[*] test 100 loop with allocating and freeing the memory of 8MB&quot; &lt;&lt; std::endl;
        std::cout &lt;&lt; &quot;[=] std new-delete time: &quot; &lt;&lt; RunTickCount&lt;decltype(test01)&gt;&#123;test01&#125;() &lt;&lt; &quot; ticks&quot; &lt;&lt; std::endl;
        std::cout &lt;&lt; &quot;[=] windows virtualAlloc-Free time: &quot; &lt;&lt; RunTickCount&lt;decltype(test02)&gt;&#123;test02&#125;() &lt;&lt; &quot; ticks&quot; &lt;&lt; std::endl;
        std::cout &lt;&lt; &quot;[=] memory pool alloc-free time: &quot; &lt;&lt; RunTickCount&lt;decltype(test03)&gt;&#123;test03&#125;() &lt;&lt; &quot; ticks&quot; &lt;&lt; std::endl;
        std::cout &lt;&lt; &quot;[=] std just new time: &quot; &lt;&lt; RunTickCount&lt;decltype(test04)&gt;&#123;test04&#125;() &lt;&lt; &quot; ticks&quot; &lt;&lt; std::endl;
        std::cout &lt;&lt; &quot;[=] windows just virtualAlloc time: &quot; &lt;&lt; RunTickCount&lt;decltype(test05)&gt;&#123;test05&#125;() &lt;&lt; &quot; ticks&quot; &lt;&lt; std::endl;
        std::cout &lt;&lt; &quot;[=] memory pool just alloc time: &quot; &lt;&lt; RunTickCount&lt;decltype(test06)&gt;&#123;test06&#125;() &lt;&lt; &quot; ticks&quot; &lt;&lt; std::endl;
        std::cout &lt;&lt; &quot;[+] test passed&quot; &lt;&lt; std::endl;
    &#125;
    catch (const std::exception &amp;e)
    &#123;
        std::cerr &lt;&lt; &quot;[-] &quot; &lt;&lt; e.what() &lt;&lt; std::endl;
    &#125;

    return 0;
&#125;
</code></pre>
<p>编译使用的参数<code>cl .\test_memorypool.cc /O2 /EHsc /std:c++20</code></p>
<p><img src="/images/1650222097.jpg" alt="性能测试结果"></p>
<p>这里仅用WindowsAPI与内存池的性能做比较，对于<code>new</code>与<code>delete</code>就当看个乐呵。</p>
<p>可以看到，内存池在循环申请与释放的测试中一骑绝尘。<br>这是因为在<code>freeUnit</code>时我们并没有真的把内存还给系统，而是交给内存池来保管。<br>而第二次进入<code>allocUnit</code>时因为还有可用的内存，所以可以直接分配，不需要向系统申请新的内存！</p>
<p>但是内存池在仅申请内存不释放的测试中被WindowsAPI所击败，这是因为仅申请内存的话调用WindowsAPI仅需一次<code>VirtualAlloc</code>的费用。<br>而内存池每次进行动态扩容时，不仅需要一次<code>VirtualAlloc</code>的费用，还需要对内存池中的各项参数进行调整，所以导致费用升高。</p>
<p>那么是因为这个内存池太垃圾了？其实不然，我们默认设定了内存池的最小块大小时4MB，而每次申请的内存大小为8MB，这就导致了内存池需要不断地进行动态扩容。<br>如果我们这里把内存池的块内存大小设置的更大，或者说我们每次申请的内存大小并不超过默认块大小，那么情况又会有所不同。</p>
<p>我们把每次申请的内存大小修改为4KB</p>
<pre><code>void test05()
&#123;
    for (size_t i = 0; i &lt; 100; i++)
        auto data = ::VirtualAlloc(nullptr, 4 * 1024, MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE);
&#125;

void test06()
&#123;
    for (size_t i = 0; i &lt; 100; i++)
        auto data = g_memoryPool.alloc(4 * 1024);
&#125;
</code></pre>
<p>再来看结果</p>
<p><img src="/images/1650222098.jpg" alt="性能测试结果"></p>
<p>这次轮到WindowsAPI被内存池击败了。由此可见，并不是所有情况下内存池都是适用的，仅在特定情况下内存池能较好的发挥其作用。</p>
<p>接下来我们写一段程序来dump内存池的内存结构，了解一下在<code>freeUnit</code>时究竟发生了什么。</p>
<h2 id="内存池释放单元时的Graphviz图"><a href="#内存池释放单元时的Graphviz图" class="headerlink" title="内存池释放单元时的Graphviz图"></a>内存池释放单元时的Graphviz图</h2><p>先修改一下代码，创建一个新的类<code>MemoryPoolX</code>并继承<code>MemoryPool</code>，我们将在这里类里进行dump</p>
<pre><code>class MemoryPoolX final : public MemoryPool
&#123;
public:
    MemoryPoolX(size_t poolMaxSize = 128 * 1024 * 1024, size_t blockMinSize = 4 * 1024 * 1024)
        : MemoryPool(poolMaxSize, blockMinSize)
    &#123;
    &#125;

    ~MemoryPoolX()
    &#123;
    &#125;

    void dumpGraphviz()
    &#123;
        std::ofstream out(&quot;test_memorypool.dot&quot;);
        out &lt;&lt; &quot;digraph DataStructure &#123;\n&quot;;
        out &lt;&lt; &quot;node [shape=record];\n&quot;;

        out &lt;&lt; &quot;\&quot;&quot; &lt;&lt; this &lt;&lt; &quot;\&quot; [label=\&quot;&#123;&lt;f0&gt;MemoryPool|&quot;
            &lt;&lt; this &lt;&lt; &quot;|&quot;
            &lt;&lt; &quot;&#123;systemPageSize|&quot; &lt;&lt; m_systemPageSize &lt;&lt; &quot;&#125;|&quot;
            &lt;&lt; &quot;&#123;poolMaxSize|&quot; &lt;&lt; m_poolMaxSize &lt;&lt; &quot;&#125;|&quot;
            &lt;&lt; &quot;&#123;blockMinSize|&quot; &lt;&lt; m_blockMinSize &lt;&lt; &quot;&#125;|&quot;
            &lt;&lt; &quot;&#123;poolSize|&quot; &lt;&lt; m_poolSize &lt;&lt; &quot;&#125;|&quot;
            &lt;&lt; &quot;&#123;&lt;f1&gt;blocks|&quot; &lt;&lt; m_blocks &lt;&lt; &quot;&#125;&quot;
            &lt;&lt; &quot;&#125;\&quot; color=\&quot;#409eff\&quot;];\n&quot;;

        block_t *block = m_blocks;
        do
        &#123;
            out &lt;&lt; &quot;\&quot;&quot; &lt;&lt; block &lt;&lt; &quot;\&quot; [label=\&quot;&#123;&lt;f0&gt;MemoryBlock|&quot;
                &lt;&lt; block &lt;&lt; &quot;|&quot;
                &lt;&lt; &quot;&#123;data|&quot; &lt;&lt; block-&gt;data &lt;&lt; &quot;&#125;|&quot;
                &lt;&lt; &quot;&#123;size|&quot; &lt;&lt; block-&gt;size &lt;&lt; &quot;&#125;|&quot;
                &lt;&lt; &quot;&#123;freeTotal|&quot; &lt;&lt; block-&gt;freeTotal &lt;&lt; &quot;&#125;|&quot;
                &lt;&lt; &quot;&#123;&lt;f1&gt;freeList|&quot; &lt;&lt; block-&gt;freeList &lt;&lt; &quot;&#125;|&quot;
                &lt;&lt; &quot;&#123;&lt;f2&gt;usedList|&quot; &lt;&lt; block-&gt;usedList &lt;&lt; &quot;&#125;|&quot;
                &lt;&lt; &quot;&#123;&lt;f3&gt;nextBlock|&quot; &lt;&lt; block-&gt;nextBlock &lt;&lt; &quot;&#125;|&quot;
                &lt;&lt; &quot;&#123;&lt;f4&gt;prevBlock|&quot; &lt;&lt; block-&gt;prevBlock &lt;&lt; &quot;&#125;&quot;
                &lt;&lt; &quot;&#125;\&quot; color=\&quot;#909399\&quot;];\n&quot;;

            unit_t *unit = block-&gt;usedList;
            do
            &#123;
                out &lt;&lt; &quot;\&quot;&quot; &lt;&lt; unit &lt;&lt; &quot;\&quot; [label=\&quot;&#123;&lt;f0&gt;MemoryUnit|&quot;
                    &lt;&lt; unit &lt;&lt; &quot;|&quot;
                    &lt;&lt; &quot;&#123;data|&quot; &lt;&lt; unit-&gt;data &lt;&lt; &quot;&#125;|&quot;
                    &lt;&lt; &quot;&#123;size|&quot; &lt;&lt; unit-&gt;size &lt;&lt; &quot;&#125;|&quot;
                    &lt;&lt; &quot;&#123;block|&quot; &lt;&lt; unit-&gt;block &lt;&lt; &quot;&#125;|&quot;
                    &lt;&lt; &quot;&#123;&lt;f1&gt;nextUnit|&quot; &lt;&lt; unit-&gt;nextUnit &lt;&lt; &quot;&#125;|&quot;
                    &lt;&lt; &quot;&#123;&lt;f2&gt;prevUnit|&quot; &lt;&lt; unit-&gt;prevUnit &lt;&lt; &quot;&#125;&quot;
                    &lt;&lt; &quot;&#125;\&quot; color=\&quot;#f56c6c\&quot;];\n&quot;;

                if (unit == block-&gt;usedList)
                &#123;
                    out &lt;&lt; &quot;subgraph cluster_&quot; &lt;&lt; unit &lt;&lt; &quot; &#123;\n&quot;
                        &lt;&lt; &quot;label=\&quot;usedList\&quot;;\n&quot;;
                    out &lt;&lt; &quot;\&quot;&quot; &lt;&lt; block &lt;&lt; &quot;\&quot;:f2 -&gt; \&quot;&quot; &lt;&lt; unit &lt;&lt; &quot;\&quot;:f0 [style=\&quot;dotted\&quot; color=\&quot;#0000ff\&quot;];\n&quot;;
                &#125;
                else
                    out &lt;&lt; &quot;\&quot;&quot; &lt;&lt; unit-&gt;nextUnit &lt;&lt; &quot;\&quot;:f2 -&gt; \&quot;&quot; &lt;&lt; unit &lt;&lt; &quot;\&quot;:f0 [style=\&quot;dotted\&quot; color=\&quot;#0000ff\&quot;];\n&quot;;

                unit = unit-&gt;nextUnit;
            &#125; while (unit != block-&gt;usedList);
            out &lt;&lt; &quot;&#125;\n&quot;;

            unit = block-&gt;freeList;
            do
            &#123;
                out &lt;&lt; &quot;\&quot;&quot; &lt;&lt; unit &lt;&lt; &quot;\&quot; [label=\&quot;&#123;&lt;f0&gt;MemoryUnit|&quot;
                    &lt;&lt; unit &lt;&lt; &quot;|&quot;
                    &lt;&lt; &quot;&#123;data|&quot; &lt;&lt; unit-&gt;data &lt;&lt; &quot;&#125;|&quot;
                    &lt;&lt; &quot;&#123;size|&quot; &lt;&lt; unit-&gt;size &lt;&lt; &quot;&#125;|&quot;
                    &lt;&lt; &quot;&#123;block|&quot; &lt;&lt; unit-&gt;block &lt;&lt; &quot;&#125;|&quot;
                    &lt;&lt; &quot;&#123;&lt;f1&gt;nextUnit|&quot; &lt;&lt; unit-&gt;nextUnit &lt;&lt; &quot;&#125;|&quot;
                    &lt;&lt; &quot;&#123;&lt;f2&gt;prevUnit|&quot; &lt;&lt; unit-&gt;prevUnit &lt;&lt; &quot;&#125;&quot;
                    &lt;&lt; &quot;&#125;\&quot; color=\&quot;#67c23a\&quot;];\n&quot;;

                if (unit == block-&gt;freeList)
                &#123;
                    out &lt;&lt; &quot;subgraph cluster_&quot; &lt;&lt; unit &lt;&lt; &quot; &#123;\n&quot;
                        &lt;&lt; &quot;label=\&quot;freeList\&quot;;\n&quot;;
                    out &lt;&lt; &quot;\&quot;&quot; &lt;&lt; block &lt;&lt; &quot;\&quot;:f1 -&gt; \&quot;&quot; &lt;&lt; unit &lt;&lt; &quot;\&quot;:f0 [style=\&quot;dashed\&quot; color=\&quot;#0000ff\&quot;];\n&quot;;
                &#125;
                else
                    out &lt;&lt; &quot;\&quot;&quot; &lt;&lt; unit-&gt;nextUnit &lt;&lt; &quot;\&quot;:f1 -&gt; \&quot;&quot; &lt;&lt; unit &lt;&lt; &quot;\&quot;:f0 [style=\&quot;dashed\&quot; color=\&quot;#0000ff\&quot;];\n&quot;;

                unit = unit-&gt;nextUnit;
            &#125; while (unit != block-&gt;freeList);
            out &lt;&lt; &quot;&#125;\n&quot;;

            if (block == m_blocks)
                out &lt;&lt; &quot;\&quot;&quot; &lt;&lt; this &lt;&lt; &quot;\&quot;:f1 -&gt; \&quot;&quot; &lt;&lt; block &lt;&lt; &quot;\&quot;:f0 [color=\&quot;#0000ff\&quot;];\n&quot;;
            else
                out &lt;&lt; &quot;\&quot;&quot; &lt;&lt; block-&gt;nextBlock &lt;&lt; &quot;\&quot;:f3 -&gt; \&quot;&quot; &lt;&lt; block &lt;&lt; &quot;\&quot;:f0 [color=\&quot;#0000ff\&quot;];\n&quot;;

            block = block-&gt;nextBlock;
        &#125; while (block != m_blocks);

        out &lt;&lt; &quot;&#125;&quot;;
        out.close();
    &#125;
&#125;;

MemoryPoolX g_memoryPool(1 * 1024 * 1024 * 1024);

void dumpGraphviz()
&#123;
    std::vector&lt;void *&gt; datas;

    for (size_t i = 0; i &lt; 6; i++)
        datas.push_back(g_memoryPool.alloc(i * 1024));
    datas.push_back(g_memoryPool.alloc(8 * 1024 * 1024));
    datas.push_back(g_memoryPool.alloc(8 * 1024 * 1024));

    g_memoryPool.dumpGraphviz();
    std::cout &lt;&lt; &quot;dump01&quot; &lt;&lt; std::endl;

    getchar();
    g_memoryPool.free(datas[2]);
    g_memoryPool.dumpGraphviz();
    std::cout &lt;&lt; &quot;dump02&quot; &lt;&lt; std::endl;

    getchar();
    g_memoryPool.free(datas[3]);
    g_memoryPool.dumpGraphviz();
    std::cout &lt;&lt; &quot;dump03&quot; &lt;&lt; std::endl;

    getchar();
&#125;
</code></pre>
<p>然后在<code>main</code>函数中调用<code>dumpGraphviz</code>就好了，直接看结果(若看不清可对着图片右键，然后选择<code>在新标签页中打开图片</code>)</p>
<p>申请完内存后的内存布局情况，其中红色为已使用的，绿色为空闲的</p>
<p><img src="/images/1650222099.jpeg" alt="graphvizDump01"></p>
<p>释放大小为<code>2048</code>的这个内存单元后的内存布局情况</p>
<p><img src="/images/1650222100.jpeg" alt="graphvizDump02"></p>
<p>可以看到第一个内存块的空闲内存单元链表中多出了一个大小为<code>2048</code>的空闲内存单元，因为其与大小为<code>4178648</code>的空闲内存单元并不临近，所以并没有进行内存单元(碎片)的合并。</p>
<p>释放大小为<code>3072</code>的这个内存单元后的内存布局情况</p>
<p><img src="/images/1650222101.jpeg" alt="graphvizDump03"></p>
<p>在释放大小为<code>3072</code>的内存单元的同时检测到其与大小为<code>2048</code>的空闲内存单元为临近内存单元，所以会进行碎片的合并。<br>为什么会生成一个大小为<code>5160</code>的空闲内存单元而不是大小为<code>5120</code>的单元是因为合并成一个时需要丢弃被合并的内存单元的头部信息，而头部信息占用的内存大小为<code>40</code>字节，因此合并后就是<code>5160</code>字节。其他单元依此类推。</p>
<p>到这里，内存池的内容基本就讲完了，接下来我们来看看垃圾回收机制。</p>
<h2 id="Garbage-Collection"><a href="#Garbage-Collection" class="headerlink" title="Garbage Collection"></a>Garbage Collection</h2><p><strong>注意：</strong><code>这里所说的标记使用的是引用计数的方式</code></p>
<p>其实个人觉得在C++中使用GC的意义不大，虽然会更方便一点，但是使用智能指针与作用域限定进行自动内存管理其实也差不多，所以GC这里的内容就算是写着玩的了。</p>
<p>想要在C++中实现GC，我们要做的第一件事情是要对<code>raw pointer</code>进行封装，因为如果使用的是<code>raw pointer</code>的话，我们无法对数据的引用进行更新，也无法跟踪指针的使用。例如：GC运行后仍有未知代码对被GC的指针进行访问，造成程序的崩溃。</p>
<h3 id="原始指针的封装"><a href="#原始指针的封装" class="headerlink" title="原始指针的封装"></a>原始指针的封装</h3><p>我们这里使用引用计数的方式来跟踪指针，上代码。</p>
<p>先给内存单元添加三个属性</p>
<pre><code>// 内存单元
struct MemoryUnit
&#123;
    uint8_t *data;        // 内存单元的数据地址
    size_t size;          // 内存的数据大小
    size_t refIndex;      // 内存单元引用表的对应的索引(用于内存整理算法更新引用)
    size_t refCount;      // 内存单元引用计数(用于内存标记算法)
    size_t aliveCount;    // 内存单元的GC存活计数(用于分代理论)
    MemoryBlock *block;   // 内存单元所属的内存块
    MemoryUnit *nextUnit; // 下一个内存单元
    MemoryUnit *prevUnit; // 上一个内存单元
&#125;;
</code></pre>
<p>然后给<code>MemoryPool</code>添加一个成员<code>std::unordered_map&lt;size_t, unit_t *&gt; m_refUnits</code>，用来记录用于整理算法的指针引用。并添加一个<code>[]</code>运算符的重载</p>
<pre><code>unit_t *operator[](size_t index)
&#123;
    return m_refUnits[index];
&#125;
</code></pre>
<p>方便对于内存单元的访问。</p>
<p>原始指针的封装类</p>
<pre><code>class GCMemory
&#123;
public:
    friend MemoryPool;

public:
    GCMemory(MemoryPool *pool, size_t unitIndex)
        : m_pool(pool),
          m_unitIndex(unitIndex)
    &#123;
        (*m_pool)[m_unitIndex]-&gt;refCount++;
    &#125;
    GCMemory()
        : m_pool(nullptr),
          m_unitIndex(0)
    &#123;
    &#125;
    ~GCMemory()
    &#123;
        if (nullptr == m_pool)
            return;

        auto unit = (*m_pool)[m_unitIndex];
        if (nullptr != unit)
            unit-&gt;refCount--;
    &#125;

    GCMemory(GCMemory &amp;other)
        : m_pool(other.m_pool)
    &#123;
        (*m_pool)[m_unitIndex]-&gt;refCount++;
    &#125;
    GCMemory(GCMemory &amp;&amp;other)
        : m_pool(other.m_pool)
    &#123;
        other.m_pool = nullptr;
    &#125;
    GCMemory &amp;operator=(GCMemory &amp;other)
    &#123;
        m_pool = other.m_pool;
        (*m_pool)[m_unitIndex]-&gt;refCount++;

        return *this;
    &#125;
    GCMemory &amp;operator=(GCMemory &amp;&amp;other)
    &#123;
        m_pool = other.m_pool;
        other.m_pool = nullptr;

        return *this;
    &#125;

    GCMemory &amp;operator++()
    &#123;
        (*m_pool)[m_unitIndex]-&gt;refCount++;

        return *this;
    &#125;

    GCMemory &amp;operator--()
    &#123;
        auto unit = (*m_pool)[m_unitIndex];

        if (unit-&gt;refCount &gt; 0)
            unit-&gt;refCount--;

        return *this;
    &#125;

    operator bool() const
    &#123;
        auto unit = (*m_pool)[m_unitIndex];

        return nullptr != m_pool &amp;&amp; nullptr != unit &amp;&amp; unit-&gt;refCount &gt; 0;
    &#125;

    operator void *() const noexcept
    &#123;
        auto unit = (*m_pool)[m_unitIndex];

        return nullptr == unit ? nullptr : unit-&gt;data;
    &#125;
    operator uint8_t *() const noexcept
    &#123;
        auto unit = (*m_pool)[m_unitIndex];

        return nullptr == unit ? nullptr : unit-&gt;data;
    &#125;

private:
    MemoryPool *m_pool;
    size_t m_unitIndex;
&#125;;

using gc_t = GCMemory;
</code></pre>
<p>对于<code>MemoryPool::allocGC</code>方法的实现</p>
<pre><code>MemoryPool::gc_t MemoryPool::allocGC(size_t size)
&#123;
    if (0 == size)
        return &#123;&#125;;

    if (nullptr == m_blocks)
        m_blocks = allocBlock(size);

    auto unit = allocUnit(size);
    if (nullptr == unit)
    &#123;
        if (size + m_poolSize &gt; m_poolMaxSize)
            throw std::bad_alloc();

        auto block = allocBlock(size);
        if (nullptr == block)
            return &#123;&#125;;

        unit = allocUnit(size);
        if (nullptr == unit)
            return &#123;&#125;;
    &#125;

    static size_t unitIndex = 0;

    m_refUnits[unitIndex] = unit;
    unit-&gt;refIndex = unitIndex++;
    unit-&gt;refCount = 0;
    unit-&gt;aliveCount = 0;

    return gc_t(this, unit-&gt;refIndex);
&#125;
</code></pre>
<p>那么来稍微测试一下</p>
<p><img src="/images/1650222102.jpeg" alt="作用域测试01"></p>
<p><img src="/images/1650222103.jpeg" alt="作用域测试01"></p>
<p>可以看到，在刚申请完的时候引用计数为<code>1</code>，并在走出作用域后变为了<code>0</code>。</p>
<h3 id="内存标记算法"><a href="#内存标记算法" class="headerlink" title="内存标记算法"></a>内存标记算法</h3><pre><code>void MemoryPool::markedGC()
&#123;
    for (auto &amp;unit : m_refUnits)
    &#123;
        if (0 != unit.second-&gt;refCount)
            continue;

        freeUnit(unit.second);
        unit.second = nullptr;
    &#125;
&#125;
</code></pre>
<p>这个其实没什么好说的，当发生GC的时候检查内存单元的引用计数，若为<code>0</code>则表示没有使用，进行内存的回收。</p>
<p>看一下效果</p>
<p><img src="/images/1650222104.jpeg" alt="内存标记算法结果"></p>
<p>在这里我们手动将<code>data02</code>的引用计数<code>-1</code>来模拟无引用的情况。</p>
<p>可以看到，在执行GC之后引用计数为<code>0</code>的<code>data02</code>的引用指针变成了<code>nullptr</code>，说明GC运行成功。正常情况下只论标记回收算法的话内存池会产生大量的内存碎片，但我们这里在释放的时候会自动进行临近碎片的合并，所以情况其实还好。</p>
<p>看一下内存结构变化的<code>Graphviz</code>图，对应代码中两处<code>g_memoryPool.dumpGraphviz()</code>的调用。</p>
<table>
<thead>
<tr>
<th><img src="/images/1650222105.jpeg" alt="内存标记算法内存结构变化01"></th>
<th><img src="/images/1650222106.jpeg" alt="内存标记算法内存结构变化02"></th>
</tr>
</thead>
</table>
<p><strong>注意：</strong><code>对于后面将要说的两种算法来说，当前的线程池模型属于冗余设计。实际设计时因为存在整理算法，所以freeList、usedList这些都可以不要，直接使用一个成员标记最后申请的位置即可。在下次进入申请内存时仅需判断当前块是否有足够的空闲内存，如果没有则动态扩容，否则可直接返回最后申请的位置，在这种情况下算法的时间复杂度仅为O(1)</code></p>
<h3 id="内存标记整理算法"><a href="#内存标记整理算法" class="headerlink" title="内存标记整理算法"></a>内存标记整理算法</h3><p>在实现整理算法之前还需要两个特别重要的方法需要实现，分别是<code>suspendTheWorld</code>与<code>resumeTheWorld</code>。</p>
<p>在我们进行内存整理之前需要先对当前进程的除当前线程外的所有线程进行暂停，因为在我们进行整理的过程中不允许出现被整理内存被其他线程访问的情况，否则可能会导致出现数据错误甚至崩溃等问题。</p>
<p>上代码</p>
<pre><code>std::vector&lt;HANDLE&gt; MemoryPool::suspendTheWorld()
&#123;
    std::vector&lt;HANDLE&gt; threadHandles;

    auto currentProcessId = ::GetCurrentProcessId();
    auto currentThreadId = ::GetCurrentThreadId();
    auto snapshotHandle = ::CreateToolhelp32Snapshot(TH32CS_SNAPTHREAD, 0);
    if (nullptr != snapshotHandle)
    &#123;
        THREADENTRY32 threadEntry&#123;&#125;;
        threadEntry.dwSize = sizeof(threadEntry);

        if (!::Thread32First(snapshotHandle, &amp;threadEntry))
            return threadHandles;
        do
        &#123;
            if (currentProcessId != threadEntry.th32OwnerProcessID || currentThreadId == threadEntry.th32ThreadID)
                continue;

            auto handle = ::OpenThread(THREAD_ALL_ACCESS, false, threadEntry.th32ThreadID);
            if (nullptr == handle)
                throw std::exception(&quot;OpenThread failed&quot;);

            if (-1 == ::SuspendThread(handle))
                throw std::exception(&quot;SuspendThread failed&quot;);

            threadHandles.push_back(handle);
        &#125; while (::Thread32Next(snapshotHandle, &amp;threadEntry));

        ::CloseHandle(snapshotHandle);
    &#125;

    return threadHandles;
&#125;

void MemoryPool::resumeTheWorld(std::vector&lt;HANDLE&gt; &amp;handles)
&#123;
    for (auto &amp;handle : handles)
    &#123;
        if (-1 == ::ResumeThread(handle))
            throw std::exception(&quot;ResumeThread failed&quot;);

        ::CloseHandle(handle);
    &#125;
&#125;
</code></pre>
<p>这两个方法实现之后再来实现内存标记整理算法</p>
<pre><code>void MemoryPool::markedTidyingGC()
&#123;
    std::set&lt;unit_t *&gt; aliveUnits;
    std::vector&lt;unit_t *&gt; deadUnits;

    auto threadHandles = suspendTheWorld(); // 砸瓦鲁多

    auto block = m_blocks;
    do
    &#123;
        aliveUnits.clear();
        deadUnits.clear();
        auto unit = block-&gt;usedList;

        do
        &#123;
            if (0 != unit-&gt;refCount)
                aliveUnits.insert(unit);
            else
                deadUnits.push_back(unit);

            unit = unit-&gt;nextUnit;
        &#125; while (unit != block-&gt;usedList);

        // check if alive units is empty
        if (aliveUnits.empty())
        &#123;
            // free all dead units
            for (auto &amp;unit : deadUnits)
            &#123;
                m_refUnits[unit-&gt;refIndex] = nullptr;
                freeUnit(unit);
            &#125;
        &#125;
        else
        &#123;
            // update dead unit reference
            for (const auto &amp;unit : deadUnits)
                m_refUnits[unit-&gt;refIndex] = nullptr;

            // move alive units to the front of the block
            auto unitMoveToPosition = reinterpret_cast&lt;unit_t *&gt;(block-&gt;data);
            size_t usedTotalSize = 0;

            for (auto &amp;unit : aliveUnits)
            &#123;
                memcpy(unitMoveToPosition, unit, sizeof(unit_t) + unit-&gt;size);

                unitMoveToPosition-&gt;data = reinterpret_cast&lt;uint8_t *&gt;(unitMoveToPosition) + sizeof(unit_t);

                if (0 == usedTotalSize)
                &#123;
                    block-&gt;usedList = unitMoveToPosition;
                    unitMoveToPosition-&gt;nextUnit = unitMoveToPosition;
                    unitMoveToPosition-&gt;prevUnit = unitMoveToPosition;
                &#125;
                else
                &#123;
                    block-&gt;usedList-&gt;prevUnit-&gt;nextUnit = unitMoveToPosition;
                    unitMoveToPosition-&gt;prevUnit = block-&gt;usedList-&gt;prevUnit;
                    unitMoveToPosition-&gt;nextUnit = block-&gt;usedList;
                    block-&gt;usedList-&gt;prevUnit = unitMoveToPosition;
                &#125;
                usedTotalSize += unitMoveToPosition-&gt;size + sizeof(unit_t);

                unitMoveToPosition = reinterpret_cast&lt;unit_t *&gt;(unitMoveToPosition-&gt;data + unitMoveToPosition-&gt;size);
            &#125;

            // reset free unit list
            block-&gt;freeTotal = block-&gt;size - usedTotalSize - sizeof(unit_t);
            block-&gt;freeList = reinterpret_cast&lt;unit_t *&gt;(block-&gt;data + usedTotalSize);
            block-&gt;freeList-&gt;data = reinterpret_cast&lt;uint8_t *&gt;(block-&gt;freeList) + sizeof(unit_t);
            block-&gt;freeList-&gt;block = block;
            block-&gt;freeList-&gt;size = block-&gt;freeTotal;
            block-&gt;freeList-&gt;nextUnit = block-&gt;freeList;
            block-&gt;freeList-&gt;prevUnit = block-&gt;freeList;

            // update used unit reference
            unit = block-&gt;usedList;
            do
            &#123;
                m_refUnits[unit-&gt;refIndex] = unit;

                unit = unit-&gt;nextUnit;
            &#125; while (unit != block-&gt;usedList);
        &#125;

        block = block-&gt;nextBlock;
    &#125; while (block != m_blocks);

    resumeTheWorld(threadHandles); // 使用相同类型的替身
&#125;
</code></pre>
<p>可以看到整个整理的过程就是先暂停世界，然后记录在此次GC中仙去与存活的内存单元。</p>
<p>如果此次GC没有存活的内存单元则直接直接进行内存单元的释放，否则先进行仙去内存单元的指针引用更新，使其变为<code>nullptr</code>，接下来对存活内存单元进行数据移动，将整个内存单元移动至前一个内存单元的后面，使其紧密贴合，如果是第一个移动的话则移动的目标地址是当前内存块的数据地址。</p>
<p>你问我会不会后面的数据把前面的单元给覆盖了？自然是不会，这是为什么使用<code>std::set</code>而不是<code>std::vector、std::unordered_set</code>等容器来存放存活内存单元地址的原因，因为<code>std::set</code>会自动给我们进行排序，而只要我们保证存活内存单元的移动是顺序的，就不会发生数据覆盖的情况。<br><strong>小提示：</strong><code>std::set基于红黑树实现，如果不需要排序的功能可使用std::unordered_set，std::unordered_set的实现基于哈希表，在性能上可直接吊打</code></p>
<p>在移动完所有存活的内存单元之后我们需要更新空闲内存空间的信息，因为我们已将使用的内存单元移动到内存块首部，所以剩下的都是可使用的空闲内存，直接分配一个大块空闲内存单元就好了。</p>
<p>最后我们需要更新已使用的内存单元的指针引用信息并取消整个世界的暂停即可。</p>
<p>看效果</p>
<p><img src="/images/1650222107.jpeg" alt="内存标记整理算法结果"></p>
<p>运行过程内存结构变化的<code>Graphviz</code>图</p>
<table>
<thead>
<tr>
<th><img src="/images/1650222108.jpeg" alt="内存标记整理算法内存结构变化01"></th>
<th><img src="/images/1650222109.jpeg" alt="内存标记整理算法内存结构变化02"></th>
</tr>
</thead>
</table>
<p>可以看到<code>data02</code>被释放后原本使用的地址被<code>data03</code>拿去用了，说明移动整理成功。</p>
<h3 id="内存分代标记整理算法"><a href="#内存分代标记整理算法" class="headerlink" title="内存分代标记整理算法"></a>内存分代标记整理算法</h3><p><strong>提示：</strong><code>因当前内存池结构不太好实现分代，所以接下来会另外申请一块内存来当作老年代</code></p>
<p>代码</p>
<pre><code>void MemoryPool::generationalMarkedTidyingGC()
&#123;
    static unit_t *elderUnitList = reinterpret_cast&lt;unit_t *&gt;(::VirtualAlloc(nullptr, 32 * 1024 * 1024, MEM_RESERVE | MEM_COMMIT, PAGE_READWRITE));
    static size_t elderUnitListIndex = 0;
    if (nullptr == elderUnitList)
        throw std::exception(&quot;Emulate elder block failed&quot;);

    std::set&lt;unit_t *&gt; elderUnits;
    std::set&lt;unit_t *&gt; aliveUnits;
    std::vector&lt;unit_t *&gt; deadUnits;

    auto threadHandles = suspendTheWorld(); // 砸瓦鲁多

    auto block = m_blocks;
    do
    &#123;
        if (nullptr == block-&gt;usedList)
        &#123;
            block = block-&gt;nextBlock;
            continue;
        &#125;

        elderUnits.clear();
        aliveUnits.clear();
        deadUnits.clear();
        auto unit = block-&gt;usedList;

        do
        &#123;
            if (0 != unit-&gt;refCount)
            &#123;
                if (4 &lt;= ++unit-&gt;aliveCount)
                    elderUnits.insert(unit);
                else
                    aliveUnits.insert(unit);
            &#125;
            else
                deadUnits.push_back(unit);

            unit = unit-&gt;nextUnit;
        &#125; while (unit != block-&gt;usedList);

        // check if alive units and elder units is empty
        if (aliveUnits.empty() &amp;&amp; elderUnits.empty())
        &#123;
            // free all dead units
            for (auto &amp;unit : deadUnits)
            &#123;
                m_refUnits[unit-&gt;refIndex] = nullptr;
                freeUnit(unit);
            &#125;
        &#125;
        else
        &#123;
            // update dead unit reference
            for (const auto &amp;unit : deadUnits)
                m_refUnits[unit-&gt;refIndex] = nullptr;

            // move elder units to the front of the elder block
            for (auto &amp;unit : elderUnits)
            &#123;
                memcpy(elderUnitList + elderUnitListIndex, unit, sizeof(unit_t) + unit-&gt;size);

                auto elderUnit = reinterpret_cast&lt;unit_t *&gt;(elderUnitList + elderUnitListIndex);
                elderUnit-&gt;data = reinterpret_cast&lt;uint8_t *&gt;(elderUnit) + sizeof(unit_t);
                elderUnit-&gt;block = nullptr;

                if (0 == elderUnitListIndex)
                &#123;
                    elderUnit-&gt;nextUnit = elderUnit;
                    elderUnit-&gt;prevUnit = elderUnit;
                &#125;
                else
                &#123;
                    elderUnitList-&gt;prevUnit-&gt;nextUnit = elderUnit;
                    elderUnit-&gt;prevUnit = elderUnitList-&gt;prevUnit;
                    elderUnit-&gt;nextUnit = elderUnitList;
                    elderUnitList-&gt;prevUnit = elderUnit;
                &#125;

                // update elder unit reference
                m_refUnits[elderUnit-&gt;refIndex] = elderUnit;

                elderUnitListIndex += sizeof(unit_t) + elderUnit-&gt;size;
            &#125;

            // move alive units to the front of the block
            auto unitMoveToPosition = reinterpret_cast&lt;unit_t *&gt;(block-&gt;data);
            size_t usedTotalSize = 0;

            if (0 == aliveUnits.size())
                block-&gt;usedList = nullptr;
            for (auto &amp;unit : aliveUnits)
            &#123;
                memcpy(unitMoveToPosition, unit, sizeof(unit_t) + unit-&gt;size);

                unitMoveToPosition-&gt;data = reinterpret_cast&lt;uint8_t *&gt;(unitMoveToPosition) + sizeof(unit_t);

                if (0 == usedTotalSize)
                &#123;
                    block-&gt;usedList = unitMoveToPosition;
                    unitMoveToPosition-&gt;nextUnit = unitMoveToPosition;
                    unitMoveToPosition-&gt;prevUnit = unitMoveToPosition;
                &#125;
                else
                &#123;
                    block-&gt;usedList-&gt;prevUnit-&gt;nextUnit = unitMoveToPosition;
                    unitMoveToPosition-&gt;prevUnit = block-&gt;usedList-&gt;prevUnit;
                    unitMoveToPosition-&gt;nextUnit = block-&gt;usedList;
                    block-&gt;usedList-&gt;prevUnit = unitMoveToPosition;
                &#125;
                usedTotalSize += unitMoveToPosition-&gt;size + sizeof(unit_t);

                unitMoveToPosition = reinterpret_cast&lt;unit_t *&gt;(unitMoveToPosition-&gt;data + unitMoveToPosition-&gt;size);
            &#125;

            // reset free unit list
            block-&gt;freeTotal = block-&gt;size - usedTotalSize - sizeof(unit_t);
            block-&gt;freeList = reinterpret_cast&lt;unit_t *&gt;(block-&gt;data + usedTotalSize);
            block-&gt;freeList-&gt;data = reinterpret_cast&lt;uint8_t *&gt;(block-&gt;freeList) + sizeof(unit_t);
            block-&gt;freeList-&gt;block = block;
            block-&gt;freeList-&gt;size = block-&gt;freeTotal;
            block-&gt;freeList-&gt;nextUnit = block-&gt;freeList;
            block-&gt;freeList-&gt;prevUnit = block-&gt;freeList;

            // update used unit reference
            if (nullptr != block-&gt;usedList)
            &#123;
                unit = block-&gt;usedList;
                do
                &#123;
                    m_refUnits[unit-&gt;refIndex] = unit;

                    unit = unit-&gt;nextUnit;
                &#125; while (unit != block-&gt;usedList);
            &#125;
        &#125;

        block = block-&gt;nextBlock;
    &#125; while (block != m_blocks);

    resumeTheWorld(threadHandles); // 使用相同类型的替身
&#125;
</code></pre>
<p>其中<code>elderUnitList</code>就是我们用来模拟老年代的另外申请的内存块。</p>
<p>另外在内存标记整理算法的基础上加了个判断，当内存单元的GC存活次数<code>&gt;= 4</code>的时候，我们就把它移动到老年代的内存块上，并更新内存单元的指针引用。</p>
<p>当在所有的已使用内存单元都成为老年代的情况下，我们还需要将当前内存块的已使用内存单元链表设置为<code>nullptr</code>。</p>
<p>这里分代的基本思路就是将内存分为新生代与老年代，其中新生代就是我们当前的内存池，老年代就是另外申请的那一块大小<code>32MB</code>的内存。发生GC时我们只对新生代做操作，而进入老年代的内存单元基本移动到老年代的内存块上之后就放手不管了，并且设定进入老年代的条件是内存单元能活过<code>4</code>次GC的调用（GC的调用基本只会发生在内存池无法再申请内存的情况下，除非手动调用）。</p>
<p>写段代码来看看效果</p>
<p><img src="/images/1650222110.jpeg" alt="内存分代标记整理算法结果"></p>
<p>可以看到第一次GC之后进行了一次内存整理，并回收了引用计数为<code>0</code>的<code>data02</code>。接下来再进行4次GC，但真正执行的其实只有3次，第4次进去后因为判断到内存块的<code>usedList</code>为<code>nullptr</code>，所以就直接进行了返回。这表明前3次已经将存活次数<code>&gt;= 4</code>的<code>test01</code>与<code>test03</code>两个对应的内存单元移动到了老年代内存块上了。</p>
<p>来看一下内存结构变化的<code>Graphviz</code>图</p>
<table>
<thead>
<tr>
<th><img src="/images/1650222111.jpeg" alt="内存分代标记整理算法内存结构变化01"></th>
<th><img src="/images/1650222112.jpeg" alt="内存分代标记整理算法内存结构变化02"></th>
<th><img src="/images/1650222113.jpeg" alt="内存分代标记整理算法内存结构变化03"></th>
</tr>
</thead>
</table>
<p>可以看到运行到最后内存池已不存在使用中的内存单元，所有的内存均已归还，而被使用了的内存单元则被转移到了老年代内存块之上，那么来看一下老年代内存块的<code>Graphviz</code>图</p>
<p><img src="/images/1650222114.jpeg" alt="老年代内存块结构"></p>
<p>这两个内存单元就是我们的<code>test01</code>与<code>test03</code>，移动正确。</p>
<h2 id="GC前后的操作"><a href="#GC前后的操作" class="headerlink" title="GC前后的操作"></a>GC前后的操作</h2><p>在没有必要的时候我们要尽量避免GC的调用，可在仅当内存池超过限定最大可向系统申请的内存大小时才启动GC进行垃圾回收，并且避免手动的去调用GC。</p>
<p>在GC后若仍无法分配内存则抛出异常<code>std::bad_alloc</code>。</p>
<p>以上说的两个操作只需要在运行时做一些判断即可，在这里就不实现了，那么到这里我们所要探讨的几种垃圾回收机制就整完了，接下来我们回到GC之前。</p>
<h2 id="C-使用特化"><a href="#C-使用特化" class="headerlink" title="C++使用特化"></a>C++使用特化</h2><p>为了方便使用，来实现两个简单的包装函数。</p>
<pre><code>template &lt;typename class_t&gt;
class_t &amp;object() requires std::is_pod_v&lt;class_t&gt;
&#123;
    return *reinterpret_cast&lt;class_t *&gt;(alloc(sizeof(class_t)));
&#125;

template &lt;typename class_t, typename... params_t&gt;
class_t &amp;object(params_t &amp;&amp;...params)
&#123;
    class_t *placement = (class_t *)alloc(sizeof(class_t));
    if (nullptr == placement)
        throw std::bad_alloc();

    new (placement) class_t(std::forward&lt;params_t&gt;(params)...);

    return *placement;
&#125;
</code></pre>
<p>然后测试一下</p>
<table>
<thead>
<tr>
<th><img src="/images/1650222115.jpeg" alt="结构"></th>
<th><img src="/images/1650222116.jpeg" alt="测试"></th>
</tr>
</thead>
</table>
<p>然后我这里不需要容器的支持（主要是懒得实现<code>std::allocator</code>），直接对其禁用。</p>
<p>先在外部声明一个<code>concept</code></p>
<pre><code>template &lt;typename any_t&gt;
concept is_container = requires(any_t any)
&#123;
    &#123;any.size()&#125;;
    &#123;any.begin()&#125;;
    &#123;any.end()&#125;;
&#125;;
</code></pre>
<p>然后再实现函数</p>
<pre><code>template &lt;typename class_t, typename... params_t&gt;
class_t &amp;object(params_t &amp;&amp;...params) requires is_container&lt;class_t&gt;
&#123;
    static_assert(false, &quot;Unsupported type of container.&quot;);

    return &#123;&#125;;
&#125;
</code></pre>
<p>测试</p>
<p><img src="/images/1650222117.jpeg" alt="测试"></p>
<p>差不多就这样了。</p>
<h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>想起还有一件事没做，就是在<code>allocUnit</code>的时候需要对齐<code>sizeof(void*)</code>，不过在这里就不再实现了，鸭蛋莫鸭蛋。</p>
<p>那就这样了，有缘再见~</p>
</article><section class="jump-container is-flex is-justify-content-space-between my-6"><!-- em is empty placeholder--><em></em><a class="button is-default" href="/2022/04/18/%E9%80%86%E5%90%91-%E8%AE%B0%E5%BD%95%E5%B0%8F%E9%BB%91%E7%9B%92%E7%AD%BE%E5%90%8D%E7%AE%97%E6%B3%95%E7%9A%84%E9%80%86%E5%90%91%E8%BF%87%E7%A8%8B/" title="[逆向] 记录小黑盒签名算法的逆向过程"><span class="has-text-weight-semibold">下一页: [逆向] 记录小黑盒签名算法的逆向过程</span><i class="iconfont icon-next ml-2 has-text-grey"></i></a></section><article class="mt-6 comment-container"><script async repo="Bzi-Han/bzi-han.github.io" src="https://utteranc.es/client.js" issue-term="pathname" theme="preferred-color-scheme"></script></article></div></div></main></main><footer class="is-flex is-flex-direction-column is-align-items-center is-flex-shrink-0 is-family-serif"><section class="sns-container"><!-- Github--><a title="github" target="_blank" rel="noopener nofollow" href="//github.com/Bzi-Han"><i class="iconfont icon-github"></i></a><!-- Ins--><!-- RSS--><!-- 知乎--><!-- 领英--><!-- 脸书--></section><p><span>Copyright ©</span><span> Bzi-Han 2022</span></p><div class="is-flex is-justify-content-center is-flex-wrap-wrap"><p>Powered by Hexo &verbar;&nbsp;</p><p class="is-flex is-justify-content-center"><a title="Hexo theme author" target="_blank" rel="noopener" href="//github.com/haojen">Theme by Haojen&nbsp;</a></p><div style="margin-top: 2px"><a class="github-button" title="github-button" target="_blank" rel="noopener" href="https://github.com/haojen/hexo-theme-Claudia" data-color-scheme="no-preference: light; light: light; dark: dark;" data-show-count="true"></a></div></div><div><span></span></div></footer><script async defer src="https://buttons.github.io/buttons.js"></script><script src="/js/post.js"></script></body></html>