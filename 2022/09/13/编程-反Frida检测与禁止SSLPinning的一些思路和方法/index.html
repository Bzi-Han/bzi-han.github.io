<!DOCTYPE html><html class="appearance-auto" lang="zh-CN"><head><meta charset="UTF-8"><title>[编程] 反Frida检测与禁止SSLPinning的一些思路和方法</title><meta name="description" content="Bzi-Han's blog, Bzi-Han的博客"><meta name="viewport" content="width=device-width, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no, initial-scale=1"><!-- Google Analytics --><!-- End Google Analytics -->
<!-- Baidu Analytics --><!-- End Baidu Analytics --><link rel="icon" href="/images/favicon.png"><link rel="stylesheet" href="/style/common/bulma.css"><link rel="stylesheet" href="/style/base.css"><link rel="stylesheet" href="/style/common/helper.css"><script src="/js/common.js"></script><link rel="stylesheet" href="/style/post.css"><link rel="stylesheet" href="/style/themes/highlight-theme-light.css"><script src="/js/highlight.pack.js"></script><meta name="description" content="抛砖引玉。
前言本文仅供学习探讨之用，如果侵犯了您的权益请联系我删除。
工具
Visual Studio Code
Frida

简要介绍Frida官方解释：

It’s Greasemonkey for native apps, or, put in more technical terms, it’s a dynamic code instrumentation toolkit. It lets you inject snippets of JavaScript or your own library into native apps on Windows, macOS, GNU&amp;#x2F;Linux, iOS, Android, and QNX. Frida also provides you wit.."><meta name="generator" content="Hexo 6.1.0"><link rel="alternate" href="/atom.xml" title="Bzi-Han的博客" type="application/atom+xml">
</head><body class="is-flex is-flex-direction-column"><header class="header-widget is-flex-shrink-0 is-hidden-mobile"><div class="container is-fullhd is-flex is-justify-content-space-between is-align-items-center is-full-height"><section class="is-hidden-mobile is-flex-shrink-0"><h2><a href="/">Bzi-Han's blog</a></h2></section><h3 class="is-hidden-mobile is-family-serif is-full-height is-flex is-align-items-center is-flex-shrink-0"><div class="is-full-height" id="postTopic"><p class="is-full-height is-flex-shrink-0 is-flex is-align-items-center is-justify-content-center">[编程] 反Frida检测与禁止SSLPinning的一些思路和方法</p><p class="is-full-height is-flex-shrink-0 is-flex is-align-items-center is-justify-content-center">点击返回顶部</p></div></h3><aside class="is-flex-shrink-0"><h3 class="is-inline-block"><a href="/">首页</a></h3><h3 class="is-inline-block"><a href="/about">关于</a></h3><h3 class="is-inline-block"><a href="/archives">归档</a></h3></aside></div></header><header class="is-flex header-widget is-flex-shrink-0 is-align-items-center is-justify-content-center is-hidden-tablet"><h3 class="is-inline-block"><a href="/">首页</a></h3><h3 class="is-inline-block"><a href="/about">关于</a></h3><h3 class="is-inline-block"><a href="/archives">归档</a></h3></header><main><main class="container is-max-widescreen content section post-page pt-4 px-4"><div class="columns is-flex-desktop is-justify-content-center is-flex-direction-row-reverse"><div class="column is-3 is-hidden-mobile"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%89%8D%E8%A8%80"><span class="toc-text">前言</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B7%A5%E5%85%B7"><span class="toc-text">工具</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AE%80%E8%A6%81%E4%BB%8B%E7%BB%8D"><span class="toc-text">简要介绍</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Frida"><span class="toc-text">Frida</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#SSLPinning"><span class="toc-text">SSLPinning</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Frida%E6%A3%80%E6%B5%8B"><span class="toc-text">Frida检测</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A6%81%E7%94%A8SSLPinning"><span class="toc-text">禁用SSLPinning</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9C%80%E6%B1%82%E5%88%86%E6%9E%90"><span class="toc-text">需求分析</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%98%B2%E6%AD%A2SSLPinning"><span class="toc-text">防止SSLPinning</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%8DFrida%E6%A3%80%E6%B5%8B"><span class="toc-text">反Frida检测</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%9D%E8%80%83"><span class="toc-text">思考</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%93%E8%AF%AD"><span class="toc-text">结语</span></a></li></ol></div><div class="column is-9"><header class="my-4"></header><h1 class="mt-0 mb-1 is-family-serif" id="postTitle">[编程] 反Frida检测与禁止SSLPinning的一些思路和方法</h1><time class="has-text-grey" datetime="2022-09-12T23:49:23.000Z">2022-09-13</time><article class="mt-2 post-content"><p>抛砖引玉。</p>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本文仅供学习探讨之用，如果侵犯了您的权益请联系我删除。</p>
<h2 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h2><ol>
<li><a target="_blank" rel="noopener" href="https://code.visualstudio.com/" title="Visual Studio Code Official">Visual Studio Code</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/frida/frida" title="Frida Official">Frida</a></li>
</ol>
<h2 id="简要介绍"><a href="#简要介绍" class="headerlink" title="简要介绍"></a>简要介绍</h2><h3 id="Frida"><a href="#Frida" class="headerlink" title="Frida"></a>Frida</h3><p><a target="_blank" rel="noopener" href="https://frida.re/docs/home/">官方解释</a>：</p>
<blockquote>
<p>It’s Greasemonkey for native apps, or, put in more technical terms, it’s a dynamic code instrumentation toolkit. It lets you inject snippets of JavaScript or your own library into native apps on Windows, macOS, GNU&#x2F;Linux, iOS, Android, and QNX. Frida also provides you with some simple tools built on top of the Frida API. These can be used as-is, tweaked to your needs, or serve as examples of how to use the API.</p>
</blockquote>
<p>简单来说最主要的特色就是一个跨平台的可以使用<code>JavaScript</code>代码片段来进行<code>程序安全测试</code>的工具集，并提供较多的易用API与各种强大的特性。</p>
<h3 id="SSLPinning"><a href="#SSLPinning" class="headerlink" title="SSLPinning"></a>SSLPinning</h3><p>我们都知道通过安装伪造的证书与中间人攻击可以轻松的抓取HTTPS的加密流量信息，如<a target="_blank" rel="noopener" href="https://mitmproxy.org/">mitmproxy</a>、<a target="_blank" rel="noopener" href="https://www.charlesproxy.com/">Charles</a>、<a target="_blank" rel="noopener" href="https://www.telerik.com/fiddler">Fiddler</a>等工具都是基于这个原理。</p>
<p>而SSLPinning就是对于HTTPS协议的反中间人攻击的一种手段。将服务器返回的证书与本地客户端的证书进行校验，如不一致则中断连接。</p>
<h3 id="Frida检测"><a href="#Frida检测" class="headerlink" title="Frida检测"></a>Frida检测</h3><p>顾名思义，就是APP中包含了有专门用来检测Frida是否附加了或正在调试自身进程的代码。如果有检测到的话轻则APP闪退，重则封号。如一些游戏的反作弊引擎就会检测Frida，运气不好就会被封，但非游戏的大部分APP只做闪退处理。</p>
<h3 id="禁用SSLPinning"><a href="#禁用SSLPinning" class="headerlink" title="禁用SSLPinning"></a>禁用SSLPinning</h3><p>通过Hook之类的方式在证书获取环节返回一个空的证书管理器，从而实现不让客户端校验或者通过Hook关键校验函数并返回<code>true</code>来实现校验成功。</p>
<h2 id="需求分析"><a href="#需求分析" class="headerlink" title="需求分析"></a>需求分析</h2><p>现如今的APP只要是正经一点的基本上都会使用SSLPinning来防止用户轻松的抓取HTTPS流量信息，所以我们如果要抓包的话就必须得把SSLPinning干掉。</p>
<p>对于如何干掉SSLPinning其实已经有很多的开源项目了。有基于<code>Xposed</code>的、<code>LSPosed</code>的，甚至<code>Magisk</code>的，但这些都存在一定的兼容性问题，手机变砖那真的是常态了。</p>
<p>而Frida的话则只需要有root权限即可，这也是选择Frida的主要原因之一。但Frida又属于检测的重点照顾对象之一，因此我们还需要进行<code>Anti Anti-Frida</code>。</p>
<h2 id="防止SSLPinning"><a href="#防止SSLPinning" class="headerlink" title="防止SSLPinning"></a>防止SSLPinning</h2><pre><code>/**
 * 修改默认临时文件名前缀
 * @see https://github.com/frida/frida-java-bridge/blob/main/lib/class-factory.js#L103
*/
if (&#39;frida&#39; === Java.classFactory.tempFileNaming.prefix)
    Java.classFactory.tempFileNaming.prefix = &#39;gc&#39;;

Java.perform(() =&gt; &#123;
    const X509TrustManager = Java.use(&quot;javax.net.ssl.X509TrustManager&quot;);
    const SSLContext = Java.use(&quot;javax.net.ssl.SSLContext&quot;);

    // 注册个假的TrustManager类
    const TrustManager = Java.registerClass(&#123;
        implements: [X509TrustManager],
        methods: &#123;
            checkClientTrusted(chain, authType) &#123; &#125;,
            checkServerTrusted(chain, authType) &#123; &#125;,
            getAcceptedIssuers() &#123;
                return [];
            &#125;,
        &#125;,
        name: &quot;com.network.TrustManager&quot;,
    &#125;);
    // 创建用来替换的TrustManager对象数组
    const trustManagers = [TrustManager.$new()];

    const SSLContextInit = SSLContext.init.overload(
        &quot;[Ljavax.net.ssl.KeyManager;&quot;,
        &quot;[Ljavax.net.ssl.TrustManager;&quot;,
        &quot;java.security.SecureRandom&quot;
    );
    // Hook SSLContext.init 方法
    SSLContextInit.implementation = function (keyManager, trustManager, secureRandom) &#123;
        console.log(&#39;[=] Intercepted SSLContext.init()&#39;);
    
        // 替换假的TrustManagers
        SSLContextInit.call(this, keyManager, trustManagers, secureRandom);
    &#125;;
&#125;);
</code></pre>
<p>这里只做了一个最基本的防止SSLPinning校验的演示，如果你想了解更多的话推荐查看<a target="_blank" rel="noopener" href="https://github.com/sensepost/objection/blob/master/agent/src/android/pinning.ts">objection</a>的实现。</p>
<h2 id="反Frida检测"><a href="#反Frida检测" class="headerlink" title="反Frida检测"></a>反Frida检测</h2><pre><code>let i = 0;

Interceptor.attach(Module.findExportByName(&#39;libc.so&#39;, &#39;strstr&#39;), &#123;
    onEnter(args) &#123;
        this.fridaDetection = false;
        const haystack = Memory.readCString(args[0]).toLowerCase();
        const needle = Memory.readCString(args[1]).toLowerCase();

        if (-1 !== haystack.indexOf(needle) &amp;&amp; (
            -1 !== haystack.indexOf(&#39;frida&#39;) || // frida相关的字符串
            -1 !== haystack.indexOf(&#39;gdbus&#39;) || // dbus线程名
            -1 !== haystack.indexOf(&#39;gum-js-loop&#39;) || // gumjs线程名
            -1 !== haystack.indexOf(&#39;gmain&#39;) || // vala线程名
            -1 !== haystack.indexOf(&#39;linjector&#39;) || // 命名管道相关
            -1 !== needle.indexOf(&#39;/data/local/tmp&#39;)) // 目录检测
        ) &#123;
            this.fridaDetection = true;

            if (100 &gt; i) &#123;
                console.log(
                    `[=] 检测你🐎呢\n` +
                    `    haystack: $&#123;haystack&#125;\n` +
                    `    needle: $&#123;needle&#125;\n` +
                    `    i: $&#123;i++&#125;\n`
                );
            &#125; else &#123;
                const detectionModule = Process.findModuleByAddress(this.returnAddress);

                console.log(
                    `[=] 检测你🐎呢\n` +
                    `    haystack: $&#123;haystack&#125;\n` +
                    `    moduleName: $&#123;detectionModule ? detectionModule.name : &#39;null&#39;&#125;\n` +
                    `    modulePath: $&#123;detectionModule ? detectionModule.path : &#39;null&#39;&#125;\n` +
                    `    moduleBase: $&#123;detectionModule ? detectionModule.base : &#39;null&#39;&#125; moduleSize: $&#123;detectionModule ? detectionModule.size : &#39;null&#39;&#125;\n` +
                    `    detectionPointOffset: $&#123;detectionModule ? this.returnAddress.sub(detectionModule.base) : this.returnAddress&#125;\n`
                );
            &#125;
        &#125;
    &#125;,
    onLeave(retval) &#123;
        if (this.fridaDetection)
            retval.replace(0);
    &#125;
&#125;);
</code></pre>
<p>在这个地方我们通过Hook<code>libc</code>中的<a target="_blank" rel="noopener" href="https://en.cppreference.com/w/c/string/byte/strstr">strstr</a>函数来实现简易的过检测，究其原因是因为不管你用啥方法，基于字符串查找的检测最终还是得调用这个方法。</p>
<p>但需要注意的是这种方法不是肯定能过，只是适用部分情况。很多用心点做的检测是可以轻松绕过这份代码的，当然也能Anti Anti就是了，这部分放在后面再说，先来看看代码效果。</p>
<p>未加载脚本时对进程附加Frida</p>
<p><img src="/images/1650222130.jpg" alt="UnAntiAntiFrida"></p>
<p>加载反Frida检测脚本后对进程附加Frida</p>
<p><img src="/images/1650222131.jpg" alt="AntiAntiFrida"></p>
<p>可以看到，在未加载脚本之前我们附加到进程之后是会直接被卸载掉的，而加载之后则可以正常附加，并且Frida API的调用也正常。</p>
<h2 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h2><p>上面说到举例的这种方法只适用于基于字符串匹配的Frida特征检测的情况，那么接下来就举出一些不适用的情况以及一些反检测的思路。列举的一些情况仅为我所知道的，如果你知道更多的请告诉我。</p>
<p><img src="/images/sticker_genius.gif" alt="nice"></p>
<ol>
<li>自己编写执行<code>syscall</code>的汇编代码来代替对于libc中函数的调用。</li>
<li>使用自己实现的模式匹配算法。</li>
<li>扫描可执行文件所属内存块，并暴力匹配frida相关特征。</li>
<li>对指定lib进行监控，循环计算<code>checksum</code>并校验，如果对不上说明被修改或者Hook了，这种方式比较暴力无差别。</li>
<li>对指定函数头部几个字节进行扫描，检测是否被Hook以及特征是否为Frida所属。</li>
</ol>
<p>对于其中<code>2</code>、<code>4</code>、<code>5</code>三种情况目前我并没有思路，比较好的方法就是找到检测点直接把检测做掉。</p>
<p>所以我们来看一下<code>1</code>、<code>3</code>情况的处理方式，对于这两种情况有一个通用的做法。即通过<code>ptrace(PTRACE_SYSCALL)</code>的方式来监听APP的<code>syscall</code>调用，并拦截函数序号<code>__NR_openat</code>(对应为libc中的openat函数)。</p>
<p>相关函数与宏在<code>linux/ptrace.h</code>与<code>fcntl.h</code>中有定义。在拦截到相关调用的时候检查调用参数<code>pathname</code>是否包含<code>/proc/self/</code>，如果包含则取消调用并将返回值也即<code>fd</code>改为我们提前准备好的去掉frida特征的相关临时文件的<code>fd</code>。</p>
<p>这样当程序在对打开的信息流进行扫描的时候就发现不了frida了。</p>
<h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>到这里文章就结束了，迷迷糊糊的也不知道有没有说清楚，<del>又水了一篇文章</del>。</p>
<p>那么有缘再见~</p>
</article><section class="jump-container is-flex is-justify-content-space-between my-6"><!-- em is empty placeholder--><a class="button is-default" href="/2022/09/15/%E9%80%86%E5%90%91-%E7%B1%B3%E6%B8%B8%E7%A4%BE%E5%8E%9F%E7%A5%9E%E6%AF%8F%E6%97%A5%E7%AD%BE%E5%88%B0%E4%B9%8BDS%E7%AE%97%E6%B3%95/" title="[逆向] 米游社原神每日签到之DS算法"><i class="iconfont icon-prev mr-2 has-text-grey"></i><span class="has-text-weight-semibold">上一页: [逆向] 米游社原神每日签到之DS算法</span></a><a class="button is-default" href="/2022/07/02/%E9%A1%B9%E7%9B%AE-Taskcloud%E5%9F%BA%E6%9C%AC%E9%87%8D%E6%9E%84%E5%AE%8C%E6%88%90%E4%B8%8E%E5%90%8E%E7%BB%AD%E5%A1%AB%E5%9D%91%E8%AE%B0%E5%BD%95%E8%AE%A1%E5%88%92%E8%B4%B4/" title="[项目] Taskcloud基本重构完成与后续填坑记录计划贴"><span class="has-text-weight-semibold">下一页: [项目] Taskcloud基本重构完成与后续填坑记录计划贴</span><i class="iconfont icon-next ml-2 has-text-grey"></i></a></section><article class="mt-6 comment-container"><script async repo="Bzi-Han/bzi-han.github.io" src="https://utteranc.es/client.js" issue-term="pathname" theme="preferred-color-scheme"></script></article></div></div></main></main><footer class="is-flex is-flex-direction-column is-align-items-center is-flex-shrink-0 is-family-serif"><section class="sns-container"><!-- Github--><a title="github" target="_blank" rel="noopener nofollow" href="//github.com/Bzi-Han"><i class="iconfont icon-github"></i></a><!-- Ins--><!-- RSS--><!-- 知乎--><!-- 领英--><!-- 脸书--></section><p><span>Copyright ©</span><span> Bzi-Han 2022</span></p><div class="is-flex is-justify-content-center is-flex-wrap-wrap"><p>Powered by Hexo &verbar;&nbsp;</p><p class="is-flex is-justify-content-center"><a title="Hexo theme author" target="_blank" rel="noopener" href="//github.com/haojen">Theme by Haojen&nbsp;</a></p><div style="margin-top: 2px"><a class="github-button" title="github-button" target="_blank" rel="noopener" href="https://github.com/haojen/hexo-theme-Claudia" data-color-scheme="no-preference: light; light: light; dark: dark;" data-show-count="true"></a></div></div><div><span></span></div></footer><script async defer src="https://buttons.github.io/buttons.js"></script><script src="/js/post.js"></script></body></html>