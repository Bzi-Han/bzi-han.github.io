<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>[编程] 使用C++20实现异步任务与单/多线程的协程调度器</title>
      <link href="/2022/12/17/%E7%BC%96%E7%A8%8B-%E4%BD%BF%E7%94%A8C++20%E5%AE%9E%E7%8E%B0%E5%BC%82%E6%AD%A5%E4%BB%BB%E5%8A%A1%E4%B8%8E%E5%8D%95-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%8D%8F%E7%A8%8B%E8%B0%83%E5%BA%A6%E5%99%A8/"/>
      <url>/2022/12/17/%E7%BC%96%E7%A8%8B-%E4%BD%BF%E7%94%A8C++20%E5%AE%9E%E7%8E%B0%E5%BC%82%E6%AD%A5%E4%BB%BB%E5%8A%A1%E4%B8%8E%E5%8D%95-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%8D%8F%E7%A8%8B%E8%B0%83%E5%BA%A6%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<p>对C++ Coroutine feature的后续展开。</p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本文仅供学习探讨之用，如果侵犯了您的权益请联系我删除。</p><h2 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h2><ol><li><a href="https://code.visualstudio.com/" title="Visual Studio Code Official">Visual Studio Code</a></li></ol><h2 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h2><p>协程这玩意我觉得其实没必要多做什么介绍，现在流行的语言基本上都有这玩意，网上也有很多相关的文章。如果你还没听过的话我觉得你可以先谷歌或百度查查相关资料。</p><p><img src="/images/sticker_darksee.jpg" alt="暗中观察"></p><p>从<code>C++</code>推出协程特性都已经两年了。虽说刚出的时候就造了个异步任务的轮子，不过一直没什么机会用，后来也就扔一边了。</p><p>最近想起又拿出来试了试，发现有点难用。加上我想写篇文章记录一下一些设计思路，索性就直接重构了一下，并增加一些新的功能。</p><p>进入正题，因为本期代码比较长所以本文中应该不会出现完整的代码，只会把基本写法和一些关键的设计部分拿出来解释说明。</p><p>至于完整的代码实现与简单测试都已上传至我的Github仓库中，如果你感兴趣可以自行跳转查看。</p><p><a href="https://github.com/Bzi-Han/coroutine">仓库地址</a>：<a href="https://github.com/Bzi-Han/coroutine">https://github.com/Bzi-Han/coroutine</a></p><h2 id="编译器支持"><a href="#编译器支持" class="headerlink" title="编译器支持"></a>编译器支持</h2><p>使用本协程库的一些限制条件</p><p>MSVC: <code>19.29.30145^</code></p><p>GCC: <code>12.2^</code></p><p>CLANG: <code>15.0.0^</code></p><p>如果你的编译器版本低于以上版本的请自行测试。</p><h2 id="基础协程"><a href="#基础协程" class="headerlink" title="基础协程"></a>基础协程</h2><p>一个基础的协程是由一个类或结构体包含着一个公开的名字固定为<code>promise_type</code>的结构体或类构成的，只要你的<code>promise_type</code>必要的成员都是公开的就行。</p><p>必要的成员有以下几个</p><ol><li><code>get_return_object()</code>用于返回实际的协程对象。</li><li><code>initial_suspend()</code>协程对象创建后的初始暂停点。</li><li><code>final_suspend()</code>协程执行完的最终暂停点。</li><li><code>return_value()</code>或<code>return_void()</code>用于接收协程的返回值。</li><li><code>unhandled_exception()</code>用于处理协程中抛出的未在内部处理的异常。</li></ol><p>可选的成员有以下几个</p><ol><li><code>yield_value()</code>用于接收<code>co_yield</code>的值。</li><li><code>await_transform()</code>或<code>operator co_await</code>用于对<code>co_await</code>语法的重载。</li><li><code>get_return_object_on_allocation_failure()</code>用于接管协程分配内存失败时默认抛出<code>std::bad_alloc</code>异常的操作。</li></ol><p>接下来我们来看以下一个最简单的协程该怎么写，上代码</p><pre><code>struct task_promise_type;struct task : std::coroutine_handle&lt;task_promise_type&gt;&#123;    using promise_type = task_promise_type;&#125;;struct task_promise_type&#123;    task get_return_object() &#123; return &#123;task::from_promise(*this)&#125;; &#125;    std::suspend_always initial_suspend() noexcept &#123; return &#123;&#125;; &#125;    std::suspend_always final_suspend() noexcept &#123; return &#123;&#125;; &#125;    void return_void() &#123;&#125;    void unhandled_exception() &#123;&#125;&#125;;</code></pre><p>这里<code>task</code>继承<code>std::coroutine_handle</code>属于偷懒写法，由父类来接收协程句柄并使用父类的接口进行管理，实际在<code>get_return_object()</code>时协程的句柄可有你自己自行分配。</p><p>例如不继承<code>std::coroutine_handle</code>并在<code>task</code>的构造函数中接收协程句柄并存入私有成员等待后续使用，然后在析构函数中去销毁协程(<code>handle.destroy()</code>)就可实现通过<code>RAII</code>自动管理协程的生命周期，后面介绍库的时候会说到。</p><p><strong>需要了解</strong>的是<code>initial_suspend</code>与<code>final_suspend</code>的返回值均为一个<code>awaitable</code>。</p><p><code>awaitable</code>决定了当前协程后续的流程走向，这里使用的<code>std::suspend_always</code>为语言提供的默认<code>awaitable</code>之一，此外还有个<code>std::suspend_never</code>表示不暂停。</p><p><code>awaitable</code>也可以自己实现，与<code>promise_type</code>相似，其必须包含以下成员</p><ol><li><code>await_ready()</code>用于决定当前协程是否暂停。</li><li><code>await_suspend()</code>如当前协程决定暂停，则会进入此函数。</li><li><code>await_resume()</code>当前协程准备继续执行时会进入此函数，其返回值就是<code>co_await</code>的返回值。</li></ol><p>那么怎么用</p><pre><code>task test01()&#123;    std::cout &lt;&lt; &quot;黑之契约者给我整破防了&quot; &lt;&lt; std::endl;    co_await std::suspend_always&#123;&#125;;    std::cout &lt;&lt; &quot;继续破防&quot; &lt;&lt; std::endl;&#125;int main()&#123;    auto coro01 = test01();    coro01.resume();    std::cout &lt;&lt; &quot;先缓缓&quot; &lt;&lt; std::endl;    coro01.resume();    coro01.destroy();    return 0;&#125;</code></pre><hr><pre><code>黑之契约者给我整破防了先缓缓继续破防</code></pre><p>还是很简单的，接下看一下可选的三个成员怎么使用</p><p>添加一个结构体<code>normal_function_transform</code>用于将普通的无参函数转成支持我们协程执行流程的<code>awaitable</code></p><p>并修改<code>promise_type</code>添加我们需要的三个成员函数</p><pre><code>template &lt;typename runable_t, typename return_t&gt;struct normal_function_transform&#123;    runable_t runable;    return_t result;    constexpr bool await_ready() const noexcept &#123; return false; &#125;    constexpr void await_suspend(std::coroutine_handle&lt;&gt; resumePoint) noexcept    &#123;        result = runable();        // resumePoint.resume()        //   这里可以直接在这里释放继续执行当前协程，也可以等待外部调度。        //   如果在这里继续执行当前协程则不会交出调度权。    &#125;    constexpr return_t await_resume() const noexcept    &#123;        return result;    &#125;&#125;;template &lt;typename runable_t&gt;struct normal_function_transform&lt;runable_t, void&gt;&#123;    runable_t runable;    constexpr bool await_ready() const noexcept &#123; return false; &#125;    constexpr void await_suspend(std::coroutine_handle&lt;&gt; resumePoint) const noexcept    &#123;        runable();    &#125;    constexpr void await_resume() const noexcept &#123;&#125;&#125;;struct task_promise_type&#123;    task get_return_object() &#123; return &#123;task::from_promise(*this)&#125;; &#125;    std::suspend_always initial_suspend() noexcept &#123; return &#123;&#125;; &#125;    std::suspend_always final_suspend() noexcept &#123; return &#123;&#125;; &#125;    void return_void() &#123;&#125;    void unhandled_exception() &#123;&#125;    std::suspend_always yield_value(const std::string_view &amp;data)    &#123;        std::cout &lt;&lt; &quot;[task_promise_type::yield_value] yield value: &quot; &lt;&lt; data &lt;&lt; std::endl;        return &#123;&#125;;    &#125;    template &lt;typename runable_t&gt;    auto await_transform(runable_t runable)    &#123;        return normal_function_transform&lt;runable_t, std::invoke_result_t&lt;runable_t&gt;&gt;&#123;runable&#125;;    &#125;    static task get_return_object_on_allocation_failure()    &#123;        std::cout &lt;&lt; &quot;[task_promise_type::get_return_object_on_allocation_failure] boom&quot; &lt;&lt; std::endl;        return &#123;nullptr&#125;;    &#125;&#125;;</code></pre><p>然后我们来看一下使用的代码以及效果</p><pre><code>int test00()&#123;    std::cout &lt;&lt; &quot;[test00] test00 called&quot; &lt;&lt; std::endl;    return 233;&#125;task test01()&#123;    std::cout &lt;&lt; &quot;[test01] 黑之契约者给我整破防了&quot; &lt;&lt; std::endl;    auto result = co_await test00;    std::cout &lt;&lt; &quot;[test01] co_await result: &quot; &lt;&lt; result &lt;&lt; std::endl;    std::cout &lt;&lt; &quot;[test01] 继续破防&quot; &lt;&lt; std::endl;    co_yield &quot;提交一个值并交出调度权&quot;;    std::cout &lt;&lt; &quot;[test01] 继续结束&quot; &lt;&lt; std::endl;&#125;int main()&#123;    auto coro01 = test01();    coro01.resume();    std::cout &lt;&lt; &quot;[main] 先缓缓&quot; &lt;&lt; std::endl;    coro01.resume();    std::cout &lt;&lt; &quot;[main] 又回来了&quot; &lt;&lt; std::endl;    coro01(); //coro01.resume();    coro01.destroy();    return 0;&#125;</code></pre><hr><pre><code>[test01] 黑之契约者给我整破防了[test00] test00 called[main] 先缓缓[test01] co_await result: 233[test01] 继续破防[task_promise_type::yield_value] yield value: 提交一个值并交出调度权[main] 又回来了[test01] 继续结束</code></pre><p>那么到这里我觉得基础的协程也差不多了，接下来就来看一下这个库的协程与调度器的一些设计。</p><h2 id="协程任务设计"><a href="#协程任务设计" class="headerlink" title="协程任务设计"></a>协程任务设计</h2><h3 id="基础结构"><a href="#基础结构" class="headerlink" title="基础结构"></a>基础结构</h3><h4 id="TaskBase"><a href="#TaskBase" class="headerlink" title="TaskBase"></a>TaskBase</h4><p>这个类中包含了4个<code>static</code>类型的成员，全部为<code>thread_local</code>属性。</p><ol><li><code>m_taskQueue</code> 通用任务的执行队列。</li><li><code>m_delayQueue</code> 延迟任务的执行队列。</li><li><code>m_resumeQueue</code> 保存子协程运行结束的返回点队列。</li><li><code>m_finallyQueue</code> 保存当前协程运行结束后<code>co_finally</code>语法所执行的协程。</li></ol><h4 id="task-promise-type-base"><a href="#task-promise-type-base" class="headerlink" title="task_promise_type_base"></a>task_promise_type_base</h4><h5 id="final-suspend"><a href="#final-suspend" class="headerlink" title="final_suspend"></a>final_suspend</h5><p>这个函数有两个分支，一个是开启<code>co_finally</code>语法的分支，另一个是没开启的分支。</p><p>未开启<code>co_finally</code>语法的执行流程</p><ul><li>检测当前协程在<code>m_resumeQueue</code>中是否存在返回点，如果存在则将返回点放入<code>m_taskQueue</code>中，并将<code>m_resumeQueue</code>中的返回点抹除。</li></ul><p>开启<code>co_finally</code>语法的执行流程</p><ol><li>检测当前协程在<code>m_resumeQueue</code>中是否存在返回点，如果存在则将返回点取出，并将<code>m_resumeQueue</code>中的返回点抹除。</li><li>通过取出的返回点判断当前协程是不是<code>finally</code>协程，如果是则将返回点放入<code>m_taskQueue</code>并返回。</li><li>如果不是则检测当前协程是否存在<code>finally</code>协程，如果存在则将所有<code>finally</code>协程放入<code>m_taskQueue</code>并将返回点放入<code>m_resumeQueue</code>中。</li><li>如果当前协程不存在<code>finally</code>协程，则将取出的返回点放入<code>m_taskQueue</code>中。</li></ol><h5 id="yield-value"><a href="#yield-value" class="headerlink" title="yield_value"></a>yield_value</h5><p>这个函数有一个接收<code>yield_t</code>类型的默认函数与一个接收延迟任务类型参数的重载。</p><p>默认函数<code>yield_value(const std::conditional_t&lt;std::is_same_v&lt;void, yield_t&gt;, uint8_t, yield_t&gt; &amp;result)</code>的执行流程</p><ol><li>将提交上来的<code>result</code>存入预定的<code>std::vector</code>中。</li><li>将自身协程放入<code>m_taskQueue</code>中等待再次调度。</li></ol><p>重载函数<code>yield_value(deferrable &amp;&amp;defer)</code>的执行流程</p><ul><li>根据传进的参数构造延迟任务并放入<code>m_delayQueue</code>中等待调度。</li></ul><h4 id="task-promise-type"><a href="#task-promise-type" class="headerlink" title="task_promise_type"></a>task_promise_type</h4><p>这个类继承于<code>task_promise_type_base</code>，有一个默认入口与一个类型偏特化入口。</p><p>默认入口接收任何类型的<code>return_t</code>。</p><p>偏特化入口只接收<code>void</code>类型的<code>return_t</code>。</p><p>这样做的目的是用于实现无返回值<code>promise_type</code>与有返回值<code>promise_type</code>的同时兼容。</p><h4 id="Task"><a href="#Task" class="headerlink" title="Task"></a>Task</h4><p>这个类继承于<code>TaskBase</code>，是实际协程的实现类，实际协程调度时操作的就是当前<code>Task</code>继承于<code>TaskBase</code>的4个任务队列。</p><p>该类使用<code>using alias</code>对<code>promise_type</code>进行定义并使用私有成员<code>std::coroutine_handle&lt;promise_type&gt; m_coroutineHandle</code>对<code>promise_type</code>初始化的协程句柄进行保存。</p><h3 id="co-delay语法"><a href="#co-delay语法" class="headerlink" title="co_delay语法"></a>co_delay语法</h3><p><code>co_delay</code>语法的实现为</p><pre><code>#define co_delay co_yield coroutine::task_implement::deferrable&#123;&#125; =</code></pre><p>其中<code>deferrable</code>为一个用来标识和存储延迟任务的结构体，他的定义如下</p><pre><code>struct deferrable&#123;    void *task = nullptr;    std::chrono::milliseconds timeout;    deferrable &amp;&amp;operator=(size_t timeout)    &#123;        this-&gt;timeout = std::chrono::milliseconds&#123;timeout&#125;;        return std::move(*this);    &#125;&#125;;</code></pre><p>可以看到它实际上是使用<code>co_yield</code>语法对当前协程提交了一个<code>deferrable</code>，而延迟执行的毫秒数为<code>co_delay</code>后面跟的立即数。如：<code>co_delay 233;</code>的延迟时间为233毫秒啊。</p><h3 id="co-switch语法"><a href="#co-switch语法" class="headerlink" title="co_switch语法"></a>co_switch语法</h3><p><code>co_switch</code>语法的实现为</p><pre><code>#define co_switch co_yield &#123;&#125;</code></pre><p>与<code>co_delay</code>一样，不过提交的是一个<code>initialize list</code>，实际走的是一个<code>uint8_t</code>类型的<code>0</code>。</p><h3 id="co-finally语法"><a href="#co-finally语法" class="headerlink" title="co_finally语法"></a>co_finally语法</h3><p>它的使用方法为</p><pre><code>co_finally&#123;    // write any code...&#125;;</code></pre><p><code>co_finally</code>语法的实现为</p><pre><code>#define _COROMAKELAMBDA(x, y) x##y#define COROMAKELAMBDA(x, y) _COROMAKELAMBDA(x, y)#define co_finally coroutine::task_implement::__CoroFinally COROMAKELAMBDA(lambda, __COUNTER__) = [&amp;]() -&gt; coroutine::task_implement::Task&lt;void, void&gt;</code></pre><p>这里<code>COROMAKELAMBDA</code>宏用于实现随机的变量名，其实际名为<code>lambda</code>+<code>序号</code>，序号由编译器提供的宏<code>__COUNTER__</code>提供，它的值是它使用的第几次次数的值，从<code>0</code>开始。</p><p><code>__CoroFinally</code>类的定义如下</p><pre><code>template &lt;typename coro_t&gt;class __CoroFinally&#123;public:    __CoroFinally(coro_t coro)        : m_coro(std::move(coro))    &#123;    &#125;    ~__CoroFinally()    &#123;        TaskBase::m_finallyQueue.push(&#123;m_coro(), false&#125;);    &#125;private:    coro_t m_coro;&#125;;</code></pre><p>可以看到，这里实际上是声明了一个名为<code>lambda</code>+<code>x</code>的<code>__CoroFinally</code>类型的局部变量。</p><p>在初始化的时候传入一个返回值和提交值都为<code>void</code>的一个不完整的<code>lambda</code>表达式，<br>其使用用户所编写的代码块进行补全，变成一个完整的<code>lambda</code>表达式。</p><p>在当前协程运行完走出作用域时，由于<code>RAII</code>的作用<code>__CoroFinally</code>会将自身持有的协程放入<code>m_finallyQueue</code>中，然后等待调度器的执行并完成<code>finally</code>所要执行的工作。</p><h2 id="调度器设计"><a href="#调度器设计" class="headerlink" title="调度器设计"></a>调度器设计</h2><p>基于上面设计的结构，在编写调度器时我们只需要关注与维护<code>TaskBase</code>的4个静态成员即可。</p><h3 id="单线程调度器"><a href="#单线程调度器" class="headerlink" title="单线程调度器"></a>单线程调度器</h3><p>对于单线程调度器，我们只需要在调用<code>run</code>函数时检测<code>m_taskQueue</code>与<code>m_delayQueue</code>是否为空，如果不为空则将协程取出并执行清空即可。</p><p>普通任务与延迟任务的调度优先级取决于个人，这里写的流程为</p><ol><li>检测<code>m_delayQueue</code>与<code>m_taskQueue</code>是否为空，如果都为空则跳出死循环并结束此次的运行。</li><li>如果<code>m_delayQueue</code>不为空，取出头部任务并判断是否已超时，如果已超时则执行取出的任务并从<code>m_delayQueue</code>中抹除。</li><li>检测<code>m_taskQueue</code>是否为空，如果为空则使用<code>continue</code>回到死循环的头部开始执行。</li><li>如果<code>m_taskQeueu</code>不为空，取出头部的任务执行，并从<code>m_taskQueue</code>中抹除。</li></ol><h3 id="多线程调度器"><a href="#多线程调度器" class="headerlink" title="多线程调度器"></a>多线程调度器</h3><p>先来看一下多线程调度器的成员与任务的转移流程</p><pre><code>using channel_t = std::promise&lt;std::pair&lt;void *, void *&gt;&gt; *;using future_t = std::future&lt;std::pair&lt;void *, void *&gt;&gt;;constexpr static size_t m_minTasks = 2, m_maxTasks = 3; // 本地任务队列任务数量的最大值与最小值static size_t m_maxWokers;                              // 最大工作线程数量static bool m_work;                                     // 用于控制线程池的开关static std::mutex m_globalMutex, m_localMutex;          // 队列锁static std::vector&lt;std::thread&gt; m_workers;              // 工作线程池static std::queue&lt;void *&gt; m_globalQueue;                // 全局任务队列，给调度器添加任务时会添加到此队列中static std::queue&lt;channel_t&gt; m_channels;                // 用于偷取其他工作线程中的本地任务的通信通道</code></pre><p>当我们给调度器添加一个任务时，首先会被添加到<code>m_globalQueue</code>全局任务队列中，然后每个工作线程会在<code>m_globalQueue</code>中获取属于自己的任务。</p><p>获取到的任务会添加到当前线程的本地队列中，也就是<code>TaskBase</code>的4个静态成员。</p><p>当有空闲线程出现时，它会往<code>m_channels</code>中添加自己接收其他线程”施舍”的任务的<code>promise</code>，如果其他线程的本地队列过长，就会将自己的头部任务交给其他在空闲中的线程来执行，自己则执行下一个任务。</p><p><code>run</code>函数的执行流程</p><ul><li>检测当前工作线程数量是否大于<code>m_maxWokers</code>，如果还不足则添加工作线程至可以执行本次<code>m_globalQueue</code>队列中任务数量的工作线程数量(最多不超过上限)。</li></ul><p><code>worker</code>函数的执行流程</p><p>由于基础流程与单线程调度器基本一致，所以我们只讲不同的部分。</p><ol><li>检测<code>m_globalQueue</code>是否为不为空且<code>m_taskQueue</code>本地任务队列存在的任务数量是否小于<code>m_minTasks</code>。</li><li>如果小于这个数量则从<code>m_globalQueue</code>获取一个任务并放入<code>m_taskQueue</code>中。</li><li>当<code>m_globalQueue</code>与<code>m_taskQueue</code>都为空，而<code>m_work</code>不为<code>false</code>时，创建一个<code>promise</code>并放入<code>m_channels</code>中。</li><li>每隔1s检测一次<code>promise</code>是否已经准备就绪，若已经准备就绪(已经偷到别的线程的本地任务)，则从中取出偷取的到的任务并加入<code>m_taskQueue</code>中。</li></ol><p>至此，对于这个协程库的介绍就完了。</p><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>这篇文章咕咕咕了好久</p><p><img src="/images/sticker_qiqidao.png" alt="qiqi"></p><p>那就这样了，有缘再见~</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>[编程] 论C++&quot;新语法&quot;-finally如何实现</title>
      <link href="/2022/10/16/%E7%BC%96%E7%A8%8B-%E8%AE%BAC++%E6%96%B0%E8%AF%AD%E6%B3%95-finally%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0/"/>
      <url>/2022/10/16/%E7%BC%96%E7%A8%8B-%E8%AE%BAC++%E6%96%B0%E8%AF%AD%E6%B3%95-finally%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0/</url>
      
        <content type="html"><![CDATA[<p>好用滴很！</p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本文仅供学习探讨之用，如果侵犯了您的权益请联系我删除。</p><h2 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h2><ol><li><a href="https://code.visualstudio.com/" title="Visual Studio Code Official">Visual Studio Code</a></li></ol><h2 id="需求分析"><a href="#需求分析" class="headerlink" title="需求分析"></a>需求分析</h2><p>先放一段代码我们来看一下实际操作时可能会遇到的一些场景，并分析为什么我们会需要<code>finally</code>语法。</p><p>上代码</p><pre><code>#include &lt;WinSock2.h&gt;#include &lt;Windows.h&gt;#include &lt;iostream&gt;std::string lastErrorMessage(int code = 0)&#123;    if (0 == code)        code = ::WSAGetLastError();    std::string result(1024, 0);    auto size = ::FormatMessageA(FORMAT_MESSAGE_FROM_SYSTEM, nullptr, code, MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT), result.data(), result.size(), nullptr);    result.resize(size);    return result;&#125;;void test01()&#123;    WSADATA wsaData&#123;&#125;;    // initialization    auto errorCode = ::WSAStartup(MAKEWORD(2, 2), &amp;wsaData);    if (errorCode)        throw std::runtime_error(lastErrorMessage(errorCode));    // create socket fd    auto fd = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);    if (INVALID_SOCKET == fd)    &#123;        auto message = lastErrorMessage();        ::WSACleanup();        throw std::runtime_error(std::move(message));    &#125;    // configure server    SOCKADDR_IN serverConfig&#123;&#125;;    serverConfig.sin_family = PF_INET;    serverConfig.sin_addr.S_un.S_addr = inet_addr(&quot;127.0.0.1&quot;);    serverConfig.sin_port = htons(11451);    // connecting to the server    if (connect(fd, reinterpret_cast&lt;SOCKADDR *&gt;(&amp;serverConfig), sizeof(SOCKADDR)))    &#123;        auto message = lastErrorMessage();        ::closesocket(fd);        ::WSACleanup();        throw std::runtime_error(std::move(message));    &#125;    ::closesocket(fd);    ::WSACleanup();&#125;int main()&#123;    std::cout &lt;&lt; &quot;[=] start test&quot; &lt;&lt; std::endl;    try    &#123;        test01();        std::cout &lt;&lt; &quot;[+] test succeeded&quot; &lt;&lt; std::endl;    &#125;    catch (const std::exception &amp;e)    &#123;        std::cout &lt;&lt; &quot;[-] &quot; &lt;&lt; e.what() &lt;&lt; std::endl;    &#125;    return 0;&#125;</code></pre><p>代码中我们以常规<code>socket</code>连接服务器的操作流程来演示。</p><p>可以看到在创建socket通信句柄与连接服务器失败时我们都需要对已<code>初始化/创建</code>的资源进行释放，并且这一过程还伴随着诸多的冗余。例如<code>WSACleanup</code>函数就需要多次书写，而这还只是一个小例子，在一个庞大的系统中可能会有非常多这样的冗余。</p><p>我们对三次调用<code>WSACleanup</code>的地方进行分析，不难看出其都是在当前函数即将跳出作用域时才会执行。这就让我们联想到了<code>RAII</code>对吧。</p><p>而基于<code>RAII</code>实现的智能指针刚好就可以实现我们<code>finally</code>的这个想法，我们可以利用<code>std::unique_ptr</code>提供的自定义<code>deleter</code>来实现<code>finally</code>代码块。需要注意的是同为智能指针的<code>std::shared_ptr</code>与<code>std::weak_ptr</code>并不支持自定义的<code>deleter</code>，所以没法用来实现<code>finally</code>。</p><h2 id="简易实现"><a href="#简易实现" class="headerlink" title="简易实现"></a>简易实现</h2><p>接下来我们先来用<code>std::unique_ptr</code>实现一个简单的<code>finally</code>，上代码</p><pre><code>void test01()&#123;    WSADATA wsaData&#123;&#125;;    SOCKET fd&#123;&#125;;    // construction the finally block    auto finallyBlock = [&amp;](uint8_t *data)    &#123;        if (nullptr != data)            delete data;        if (0 != fd &amp;&amp; INVALID_SOCKET != fd)            ::closesocket(fd);        ::WSACleanup();        std::cout &lt;&lt; &quot;[=] finally block&quot; &lt;&lt; std::endl;    &#125;;    std::unique_ptr&lt;uint8_t, decltype(finallyBlock)&gt; defer(new uint8_t, finallyBlock);    // initialization    auto errorCode = ::WSAStartup(MAKEWORD(2, 2), &amp;wsaData);    if (errorCode)        throw std::runtime_error(lastErrorMessage(errorCode));    // create socket fd    fd = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);    if (INVALID_SOCKET == fd)        throw std::runtime_error(lastErrorMessage(errorCode));    // configure server    SOCKADDR_IN serverConfig&#123;&#125;;    serverConfig.sin_family = PF_INET;    serverConfig.sin_addr.S_un.S_addr = inet_addr(&quot;127.0.0.1&quot;);    serverConfig.sin_port = htons(11451);    // connecting to the server    if (connect(fd, reinterpret_cast&lt;SOCKADDR *&gt;(&amp;serverConfig), sizeof(SOCKADDR)))    &#123;        std::cout &lt;&lt; &quot;[-] connection failed&quot; &lt;&lt; std::endl;        throw std::runtime_error(lastErrorMessage());    &#125;&#125;</code></pre><p>我们对<code>test01</code>函数进行一些修改，添加<code>finally</code>实现与一些信息输出。</p><p>代码执行后效果如下</p><p><img src="/images/1650222143.jpg" alt="代码执行结果"></p><p>可以看到代码的执行顺序与我们预期的一样，顺序为</p><ol><li>输出”connection failed”信息。</li><li><code>throw</code>连接服务器的异常信息。</li><li>局部变量超出函数作用域<code>RAII</code>开始执行，智能指针<code>defer</code>开始销毁所管理的裸指针<code>uint8_t*</code>。</li><li>因为我们设置了自定义销毁函数(<code>deleter</code>)，所以会进入<code>finallyBlock</code>这个<code>lambda</code>中。</li><li>执行释放资源的操作并输出信息”finally block”。</li><li>回到外部调用函数的地方(<code>main</code>)并处理异常，输出异常信息。</li></ol><p>这样我们就实现了一个简易的<code>finally</code>。</p><h2 id="完整改进实现"><a href="#完整改进实现" class="headerlink" title="完整改进实现"></a>完整改进实现</h2><p>上面说到的实现中虽然能用，但基本是不符合我们所设想的情况的。</p><p>首先他不是一个”新语法”，而是一种写法。</p><p>其次它的运行每次需要在堆中申请一个字节大小的内存并最终释放，如果编译器不能很好的优化的话这将造成很大的性能瓶颈。</p><p><code>new</code>与<code>delete</code>的代价可不便宜啊，对于我们想单单执行一个<code>lambda</code>表达式来说有点过于浪费了。</p><p>那么既然大家都是基于<code>RAII</code>的话，何不自己造呢，老规矩先上代码后分析</p><pre><code>#ifndef FINALLY_H //! FINALLY_H#define FINALLY_H#include &lt;type_traits&gt;#include &lt;utility&gt;template &lt;typename callable_t&gt;class __FinallyCaller&#123;public:    __FinallyCaller(callable_t callable)        : m_callable(std::move(callable))    &#123;    &#125;    ~__FinallyCaller() noexcept    &#123;        m_callable();    &#125;private:    callable_t m_callable;&#125;;struct __Helper&#123;    template &lt;typename callable_t&gt;    constexpr __FinallyCaller&lt;callable_t&gt; operator+(const callable_t &amp;&amp;callable)    &#123;        static_assert(noexcept(callable), &quot;The finally block cannot throw&quot;);        return &#123;callable&#125;;    &#125;&#125;;#define _MAKELAMBDA(x, y) x##y#define MAKELAMBDA(x, y) _MAKELAMBDA(x, y)#define finally auto &amp;&amp;MAKELAMBDA(lambda, __COUNTER__) = __Helper&#123;&#125; + [&amp;]() noexcept#endif //! FINALLY_H</code></pre><p>首先我们来看<code>__FinallyCaller</code>这个模板类，它的构造函数接收一个<code>callable</code>的参数并存入成员变量中，并在析构函数中去调用这个<code>callable</code>。</p><p>即当局部变量类型为<code>__FinallyCaller</code>而又开始执行<code>RAII</code>时，传进来的<code>callable</code>会被调用，可以是函数也可以是<code>lambda</code>。</p><p>那么我们来看一下<code>__FinallyCaller</code>的使用方法</p><pre><code>int main()&#123;    __FinallyCaller defer = [&amp;]    &#123;        std::cout &lt;&lt; &quot;[=] finally block&quot; &lt;&lt; std::endl;    &#125;;    std::cout &lt;&lt; &quot;[=] main end&quot; &lt;&lt; std::endl;    return 0;&#125;</code></pre><hr><pre><code>/out:test_finally.exetest_finally.obj[=] main end[=] finally block</code></pre><p>可以看到流程与我们预想的一样。</p><p>但这种写法有一个问题，就是只支持<code>c++17</code>及以上的版本，因为在<code>c++17</code>才加入了<a href="https://en.cppreference.com/w/cpp/language/class_template_argument_deduction" title="详细资料">类模板参数推导</a>，而<code>__Helper</code>就是解决这个问题的方法之一。</p><p>来看一下用法</p><pre><code>int main()&#123;    auto defer = __Helper&#123;&#125; + [&amp;]    &#123;        std::cout &lt;&lt; &quot;[=] finally block&quot; &lt;&lt; std::endl;    &#125;;    std::cout &lt;&lt; &quot;[=] main end&quot; &lt;&lt; std::endl;    return 0;&#125;</code></pre><hr><pre><code>/out:test_finally.exetest_finally.obj[=] main end[=] finally block</code></pre><p>没有问题，在<code>c++11</code> <code>c++14</code>中都能正常编译运行。</p><p>在这些用例中我们都还需要自己声明变量与构造，达不到我们<code>finally</code>的需求，那么再来看看剩余的3个宏定义的工作。</p><p>首先是<code>#define _MAKELAMBDA(x, y) x##y</code>，这个没啥好说的就是一个宏连接，将传入的<code>x</code>和<code>y</code>进行字面上的连接，比如<code>1</code>和<code>2</code>就会变成<code>12</code>。</p><p>然后是<code>#define MAKELAMBDA(x, y) _MAKELAMBDA(x, y)</code>，辅助展开，这个具体有啥用下面说明。</p><p>最后是<code>#define finally auto &amp;&amp;MAKELAMBDA(lambda, __COUNTER__) = __Helper&#123;&#125; + [&amp;]() noexcept</code>。</p><p>这条宏的本质是声明一个变量，来简化展开看一下就是<code>auto lambda0 = __Helper&#123;&#125; + [&amp;]</code>，其中这个变量名<code>lambda0</code>后面跟的<code>0</code>是由宏<code>__COUNTER__</code>提供的一个全局计数器，使用<code>MAKELAMBDA</code>进行连接而成。</p><p>这就要说到第二个宏辅助展开的作用，这里的<code>__COUNTER__</code>如果不进行两层的<code>MAKELAMBDA</code>包装的话是无法成功展开的，就会变成<code>lambda__COUNTER__</code>这样的情况，这就与我们的预期相违，所以需要加一层。</p><p>那么有了这3条宏的加持我们基本上可以写出符合我们预期的代码了，我们直接对<code>test01</code>函数进行修改来看一下最终效果</p><pre><code>void test01()&#123;    WSADATA wsaData&#123;&#125;;    SOCKET fd&#123;&#125;;    // construction the finally block    finally    &#123;        if (0 != fd &amp;&amp; INVALID_SOCKET != fd)            ::closesocket(fd);        ::WSACleanup();        std::cout &lt;&lt; &quot;[=] finally block&quot; &lt;&lt; std::endl;    &#125;;    // initialization    auto errorCode = ::WSAStartup(MAKEWORD(2, 2), &amp;wsaData);    if (errorCode)        throw std::runtime_error(lastErrorMessage(errorCode));    // create socket fd    fd = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);    if (INVALID_SOCKET == fd)        throw std::runtime_error(lastErrorMessage(errorCode));    // configure server    SOCKADDR_IN serverConfig&#123;&#125;;    serverConfig.sin_family = PF_INET;    serverConfig.sin_addr.S_un.S_addr = inet_addr(&quot;127.0.0.1&quot;);    serverConfig.sin_port = htons(11451);    // connecting to the server    if (connect(fd, reinterpret_cast&lt;SOCKADDR *&gt;(&amp;serverConfig), sizeof(SOCKADDR)))    &#123;        std::cout &lt;&lt; &quot;[-] connection failed&quot; &lt;&lt; std::endl;        throw std::runtime_error(lastErrorMessage());    &#125;&#125;</code></pre><hr><pre><code>/out:test_finally.exetest_finally.obj[=] start test[-] connection failed[=] finally block[-] 由于目标计算机积极拒绝，无法连接。 </code></pre><p>可以看到<code>finally</code>的书写一下就变得简单了，没有那么多繁杂的东西，只有一个<code>finally</code>关键字与<code>&#123;&#125;;</code>，大括号中即是我们需要最终执行的代码。</p><p>这个方法相比简易方法实现的最大的好处就是跟堆内存没有关系，这意味着在编译器的优化下可以被完全展开，这对于吃性能的场景是非常友好的。</p><p>唯一的缺点就是最后还要跟个<code>;</code>，毕竟这是一条语句。如果能去掉这个<code>;</code>的话就更好了。</p><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>那么其实就这样了，也没有什么特别的难点，就是好用！</p><p>那就这样了，有缘再见~</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>[逆向] 米游社原神每日签到之DS算法</title>
      <link href="/2022/09/15/%E9%80%86%E5%90%91-%E7%B1%B3%E6%B8%B8%E7%A4%BE%E5%8E%9F%E7%A5%9E%E6%AF%8F%E6%97%A5%E7%AD%BE%E5%88%B0%E4%B9%8BDS%E7%AE%97%E6%B3%95/"/>
      <url>/2022/09/15/%E9%80%86%E5%90%91-%E7%B1%B3%E6%B8%B8%E7%A4%BE%E5%8E%9F%E7%A5%9E%E6%AF%8F%E6%97%A5%E7%AD%BE%E5%88%B0%E4%B9%8BDS%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<p>漏签真的很烦。</p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本文仅供学习探讨之用，如果侵犯了您的权益请联系我删除。</p><h2 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h2><ol><li><a href="https://www.telerik.com/fiddler" title="Fiddler Official">Fiddler</a></li><li><a href="https://github.com/skylot/jadx" title="JADX Official">JADX</a></li><li><a href="https://hex-rays.com/" title="IDA Official">IDA</a></li><li><a href="https://github.com/frida/frida" title="Frida Official">Frida</a></li></ol><h2 id="抓包"><a href="#抓包" class="headerlink" title="抓包"></a>抓包</h2><p><img src="/images/1650222132.jpg" alt="签到包内容"></p><h2 id="重放测试"><a href="#重放测试" class="headerlink" title="重放测试"></a>重放测试</h2><p>使用<code>Shift + R</code>进行一个包的重放。</p><p><img src="/images/1650222133.jpg" alt="重放测试结果"></p><p>没有问题，这其中有个<code>DS</code>参数看起来挺可疑的，去掉再试试。</p><p><img src="/images/1650222134.jpg" alt="重放测试结果"></p><p>服务器直接不认了，那么可以确定这就是个时间戳签名信息。</p><h2 id="JADX"><a href="#JADX" class="headerlink" title="JADX"></a>JADX</h2><p>将apk拖进<code>jadx</code>并等待分析完成后打开搜索窗口直接搜索<code>DS</code>关键字</p><p><img src="/images/1650222135.jpg" alt="搜索结果"></p><p>然后啥也没搜到，那么换个<code>&quot;DS&quot;</code>关键字</p><p><img src="/images/1650222136.jpg" alt="搜索结果"></p><p>看到几个可疑的目标，比如这个圈起来的类名就叫做<code>GetDSMethodImpl</code>，可以说非常的直接，那么跟过去看看</p><p><img src="/images/1650222137.jpg" alt="跟踪结果"></p><p>经过分析代码后，发现<code>DS</code>来自与这个函数，继续跟过去看看</p><p><img src="/images/1650222138.jpg" alt="跟踪结果"></p><p>可以看到到这里就已经进入了<code>so</code>层了，那么接下来进入下一层的分析。</p><h2 id="IDA"><a href="#IDA" class="headerlink" title="IDA"></a>IDA</h2><p>全部的伪代码比较长，我就截取一小部分先来看看</p><pre><code>v4 = (*a1)-&gt;GetStringUTFChars(a1, a3, 0LL); v64 = 0LL;v65 = 0LL;v66 = 0LL;v5 = strlen(v4);                             v6 = v5;if ( v5 &gt;= 0x17 )&#123;    v8 = (v5 + 16) &amp; 0xFFFFFFFFFFFFFFF0LL;    v7 = (char *)operator new(v8);    v65 = v6;    v66 = v7;    v64 = v8 | 1;    goto LABEL_5;&#125;v7 = (char *)&amp;v64 + 1;LOBYTE(v64) = 2 * v5;if ( v5 )LABEL_5:    memcpy(v7, v4, v6);                       v7[v6] = 0;                          gettimeofday(&amp;tv, 0LL);std::to_string((std::__ndk1 *)(v63 / 1000000 + *(_QWORD *)&amp;tv), v9);Random::random((Random *)v58);std::operator+&lt;char&gt;(&quot;salt=&quot;, &amp;v64);v10 = std::string::append((int)&amp;v48, &quot;&amp;t=&quot;, 3u);</code></pre><p>可以看到其中大量使用了<code>std::string::append</code>，那么我们来Hook这个函数看看。</p><p>需要说明一下的是米游社有<code>Anti-Frida</code>，所以需要反一下，可以参考一下这篇文章：<a href="http://localhost:4000/2022/09/13/%E7%BC%96%E7%A8%8B-%E5%8F%8DFrida%E6%A3%80%E6%B5%8B%E4%B8%8E%E7%A6%81%E6%AD%A2SSLPinning%E7%9A%84%E4%B8%80%E4%BA%9B%E6%80%9D%E8%B7%AF%E5%92%8C%E6%96%B9%E6%B3%95/">反Frida检测与禁止SSLPinning的一些思路和方法</a>。</p><p>来看下Hook结果</p><p><img src="/images/1650222139.jpg" alt="Hook结果"></p><p>可以看到这个结果跟我们抓到的包的<code>DS</code>参数最终效果是一致的</p><p><code>DS: 1663216865,2bfm47,b6069f6088a02f2ff35b1407034b520c</code></p><p>那么我们根据这个结果再回到IDA进行一波分析逻辑。</p><p>经过一番梳理之后得到以下流程</p><pre><code>CMD5::CMD5((CMD5 *)&amp;v70);                     // new MD5类</code></pre><hr><pre><code>v4 = (*a1)-&gt;GetStringUTFChars(a1, a3, 0LL);   // 获取传进来的salt参数v64 = 0LL;v65 = 0LL;v66 = 0LL;v5 = strlen(v4);                              // 计算salt的长度v6 = v5;if ( v5 &gt;= 0x17 )&#123;    v8 = (v5 + 16) &amp; 0xFFFFFFFFFFFFFFF0LL;    v7 = (char *)operator new(v8);    v65 = v6;    v66 = v7;    v64 = v8 | 1;    goto LABEL_5;&#125;v7 = (char *)&amp;v64 + 1;LOBYTE(v64) = 2 * v5;if ( v5 )LABEL_5:    memcpy(v7, v4, v6);                         // copy v4(salt字符串)给v64v7[v6] = 0;                                   // 结尾设\0gettimeofday(&amp;tv, 0LL);std::to_string((std::__ndk1 *)(v63 / 1000000 + *(_QWORD *)&amp;tv), v9);Random::random((Random *)v58);                // 生成随机字符串std::operator+&lt;char&gt;(&quot;salt=&quot;, &amp;v64);          // 拼接salt=传进来的saltv10 = std::string::append((int)&amp;v48, &quot;&amp;t=&quot;, 3u);// 拼接&amp;t=v11 = *(_OWORD *)v10;v51 = *(void **)(v10 + 16);v50 = v11;*(_QWORD *)(v10 + 8) = 0LL;*(_QWORD *)(v10 + 16) = 0LL;*(_QWORD *)v10 = 0LL;if ( (v59 &amp; 1) != 0 )    v12 = v61;else    v12 = v60;if ( (v59 &amp; 1) != 0 )    LODWORD(v13) = *(_DWORD *)&amp;v60[7];else    v13 = (unsigned __int64)v59 &gt;&gt; 1;v14 = std::string::append((int)&amp;v50, v12, v13);// 拼接当前时间戳v15 = *(_OWORD *)v14;v53 = *(void **)(v14 + 16);v52 = v15;*(_QWORD *)(v14 + 8) = 0LL;*(_QWORD *)(v14 + 16) = 0LL;*(_QWORD *)v14 = 0LL;v16 = std::string::append((int)&amp;v52, &quot;&amp;r=&quot;, 3u);// 拼接&amp;r=v17 = *(_OWORD *)v16;v71 = *(void **)(v16 + 16);v70 = v17;*(_QWORD *)(v16 + 8) = 0LL;*(_QWORD *)(v16 + 16) = 0LL;*(_QWORD *)v16 = 0LL;if ( (v54 &amp; 1) != 0 )    v18 = v57;else    v18 = v55;if ( (v54 &amp; 1) != 0 )    LODWORD(v19) = v56;else    v19 = (unsigned __int64)v54 &gt;&gt; 1;v20 = std::string::append((int)&amp;v70, v18, v19);// 拼接随机字符串v21 = *(_WORD *)(v20 + 5);v22 = *(_DWORD *)(v20 + 1);v23 = *(_BYTE *)v20;                          // v23获得待计算字符串所有权v69 = *(_BYTE *)(v20 + 7);v68 = v21;v67 = v22;v25 = *(_QWORD *)(v20 + 8);v24 = *(void **)(v20 + 16);*(_QWORD *)v20 = 0LL;*(_QWORD *)(v20 + 8) = 0LL;*(_QWORD *)(v20 + 16) = 0LL;</code></pre><hr><pre><code>v40 = 0LL;v41 = 0LL;v42 = 0LL;if ( (v23 &amp; 1) == 0 )&#123;    LOBYTE(v40) = v23;                          // v40获得待计算字符串所有权    HIBYTE(v40) = v69;    *(_WORD *)((char *)&amp;v40 + 5) = v68;    *(_DWORD *)((char *)&amp;v40 + 1) = v67;    v41 = v25;    v42 = v24;    goto LABEL_42;&#125;</code></pre><hr><pre><code>CMD5::md5(&amp;v70, &amp;v40);                        // 计算v40 md5hash值if ( (v43 &amp; 1) != 0 )    v33 = v45;else    v33 = v44;if ( (v43 &amp; 1) != 0 )    LODWORD(v34) = *(_DWORD *)&amp;v44[7];else    v34 = (unsigned __int64)v43 &gt;&gt; 1;</code></pre><hr><pre><code>sub_13C40((int)&amp;v59, &quot;,&quot;);                    // 拼接 当前时间戳 + &quot;,&quot;if ( (v54 &amp; 1) != 0 )    v26 = v57;else    v26 = v55;if ( (v54 &amp; 1) != 0 )    LODWORD(v27) = v56;else    v27 = (unsigned __int64)v54 &gt;&gt; 1;v28 = std::string::append((int)&amp;v46, v26, v27);// 拼接随机字符串v29 = *(_OWORD *)v28;ptr = *(void **)(v28 + 16);v48 = v29;*(_QWORD *)(v28 + 8) = 0LL;*(_QWORD *)(v28 + 16) = 0LL;*(_QWORD *)v28 = 0LL;v30 = std::string::append((int)&amp;v48, &quot;,&quot;, 1u);// 拼接 ,</code></pre><hr><pre><code>v35 = std::string::append((int)&amp;v50, v33, v34);// 拼接hash值，完成整个签名过程</code></pre><h2 id="计算过程"><a href="#计算过程" class="headerlink" title="计算过程"></a>计算过程</h2><p>可能上面看起来会有点乱，接下来总结一下对于<code>DS</code>的计算过程大概是这样的</p><pre><code>input saltinput timestampinput randomStringprocess params = &quot;salt=&quot; + salt + &quot;&amp;t=&quot; + timestamp + &quot;&amp;r=&quot; + randomStringoutput hash = md5(params)output DS = timestamp + &quot;,&quot; + randomString + &quot;,&quot; + hash</code></pre><h2 id="代码验证"><a href="#代码验证" class="headerlink" title="代码验证"></a>代码验证</h2><p>来写一份代码验证一下。</p><pre><code>import hashlibimport timeimport randomsalt = &#39;n0KjuIrKgLHh08LWSCYP0WXlVXaYvV64&#39;# timestamp = str(int(time.time()))timestamp = &#39;1663216865&#39;# randomString = &#39;&#39;.join(random.sample(&#39;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789&#39;, 6))randomString = &#39;2bfm47&#39;params = &#39;salt=&#123;&#125;&amp;t=&#123;&#125;&amp;r=&#123;&#125;&#39;.format(salt, timestamp, randomString)md5 = hashlib.md5()md5.update(params.encode(&#39;utf-8&#39;))hash = md5.hexdigest()DS = &#39;&#123;&#125;,&#123;&#125;,&#123;&#125;&#39;.format(timestamp, randomString, hash)print(&#39;DS&#39;, DS)</code></pre><p>输出</p><pre><code>预计输出1663216865,2bfm47,b6069f6088a02f2ff35b1407034b520c实际输出DS 1663216865,2bfm47,b6069f6088a02f2ff35b1407034b520c</code></pre><p>可以看到预想与实际的结果完全一致。</p><h2 id="实际测试"><a href="#实际测试" class="headerlink" title="实际测试"></a>实际测试</h2><p>来实际发个包试试吧</p><p><img src="/images/1650222140.jpg" alt="测试结果"></p><p>嗯，居然不认。根据结果知道我们的推理应该是不会错的，那么我们回到<code>jadx</code>看看是什么情况。</p><h2 id="回到JADX"><a href="#回到JADX" class="headerlink" title="回到JADX"></a>回到JADX</h2><p>对<code>a2222</code>这个函数查找引用后看到是有两个地方的</p><p><img src="/images/1650222141.jpg" alt="引用情况"></p><p>根据代码分析它们所使用的<code>salt</code>非同一个，那么我们需要找一下<code>salt</code>的来源。</p><p>经过分析之后我们抠出来了这样一段代码</p><pre><code>public class Main &#123;    public static final int[] iArr = &#123;-90, 114, -70, -74, -108, 222, 60, 66, 90, 72, 84, -102, -76, 120, 84, 216, 222, -114, -68, -66, -14348907, 108, 222, 216, -68, 192, -88, -120, 150, -74, 150, -108&#125;;    public static void main(String[] args) &#123;        int i;        StringBuilder sb = new StringBuilder();        ArrayList&lt;Number&gt; arrayList = new ArrayList(iArr.length);        for (int i2 : iArr) &#123;            if (i2 &lt; 0) &#123;                i = ((double) (-i2)) &gt;= Math.pow(3.0d, 6.0d) ? (int) (((Math.log(-((double) i2)) / Math.log(3.0d)) - ((double) 6)) + ((double) 48)) : ~i2;            &#125; else &#123;                i = (i2 / 3) + 48;            &#125;            arrayList.add(Integer.valueOf(i));        &#125;        ArrayList arrayList2 = new ArrayList(arrayList.size());        for (Number number : arrayList) &#123;            sb.append((char) number.intValue());            arrayList2.add(sb);        &#125;        String sb2 = sb.toString();        System.out.println(sb2);    &#125;&#125;</code></pre><p>执行后得到输出</p><pre><code>YVEIkzDFNHLeKXLxzqCA9TzxCpWwbIbk</code></pre><p>然后我们将代码中的<code>salt</code>替换为这个输出之后再来发个包试试</p><p><img src="/images/1650222142.jpg" alt="最终测试"></p><p>嗯，可以看到服务器已经认可我们的包了，没问题。</p><h2 id="TODO"><a href="#TODO" class="headerlink" title="TODO"></a>TODO</h2><ul><li><input checked="" disabled="" type="checkbox"> Taskcloud版本的自动签到脚本</li><li><input disabled="" type="checkbox"> 抓米游币每日签到的接口</li><li><input disabled="" type="checkbox"> 抓米游币浏览3个帖子的接口</li><li><input disabled="" type="checkbox"> 抓米游币点赞5次的接口</li><li><input disabled="" type="checkbox"> 抓米游币分享帖子的接口</li></ul><p>自动签到脚本慢慢再写，因为Taskcloud目前好像还有点问题，但是还没修。</p><p>米游社的其他接口<del>可能不搞</del>。</p><p><img src="/images/sticker_!smart.jpg" alt="!smart"></p><p>先放脚本的仓库链接，之后如果有新脚本的话都会更新到仓库里。</p><p>脚本仓库：<a href="https://github.com/Bzi-Han/scripts">scripts</a></p><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>原神真好玩，嘿嘿。</p><p>那就这样了，有缘再见~</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>[编程] 反Frida检测与禁止SSLPinning的一些思路和方法</title>
      <link href="/2022/09/13/%E7%BC%96%E7%A8%8B-%E5%8F%8DFrida%E6%A3%80%E6%B5%8B%E4%B8%8E%E7%A6%81%E6%AD%A2SSLPinning%E7%9A%84%E4%B8%80%E4%BA%9B%E6%80%9D%E8%B7%AF%E5%92%8C%E6%96%B9%E6%B3%95/"/>
      <url>/2022/09/13/%E7%BC%96%E7%A8%8B-%E5%8F%8DFrida%E6%A3%80%E6%B5%8B%E4%B8%8E%E7%A6%81%E6%AD%A2SSLPinning%E7%9A%84%E4%B8%80%E4%BA%9B%E6%80%9D%E8%B7%AF%E5%92%8C%E6%96%B9%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<p>抛砖引玉。</p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本文仅供学习探讨之用，如果侵犯了您的权益请联系我删除。</p><h2 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h2><ol><li><a href="https://code.visualstudio.com/" title="Visual Studio Code Official">Visual Studio Code</a></li><li><a href="https://github.com/frida/frida" title="Frida Official">Frida</a></li></ol><h2 id="简要介绍"><a href="#简要介绍" class="headerlink" title="简要介绍"></a>简要介绍</h2><h3 id="Frida"><a href="#Frida" class="headerlink" title="Frida"></a>Frida</h3><p><a href="https://frida.re/docs/home/">官方解释</a>：</p><blockquote><p>It’s Greasemonkey for native apps, or, put in more technical terms, it’s a dynamic code instrumentation toolkit. It lets you inject snippets of JavaScript or your own library into native apps on Windows, macOS, GNU&#x2F;Linux, iOS, Android, and QNX. Frida also provides you with some simple tools built on top of the Frida API. These can be used as-is, tweaked to your needs, or serve as examples of how to use the API.</p></blockquote><p>简单来说最主要的特色就是一个跨平台的可以使用<code>JavaScript</code>代码片段来进行<code>程序安全测试</code>的工具集，并提供较多的易用API与各种强大的特性。</p><h3 id="SSLPinning"><a href="#SSLPinning" class="headerlink" title="SSLPinning"></a>SSLPinning</h3><p>我们都知道通过安装伪造的证书与中间人攻击可以轻松的抓取HTTPS的加密流量信息，如<a href="https://mitmproxy.org/">mitmproxy</a>、<a href="https://www.charlesproxy.com/">Charles</a>、<a href="https://www.telerik.com/fiddler">Fiddler</a>等工具都是基于这个原理。</p><p>而SSLPinning就是对于HTTPS协议的反中间人攻击的一种手段。将服务器返回的证书与本地客户端的证书进行校验，如不一致则中断连接。</p><h3 id="Frida检测"><a href="#Frida检测" class="headerlink" title="Frida检测"></a>Frida检测</h3><p>顾名思义，就是APP中包含了有专门用来检测Frida是否附加了或正在调试自身进程的代码。如果有检测到的话轻则APP闪退，重则封号。如一些游戏的反作弊引擎就会检测Frida，运气不好就会被封，但非游戏的大部分APP只做闪退处理。</p><h3 id="禁用SSLPinning"><a href="#禁用SSLPinning" class="headerlink" title="禁用SSLPinning"></a>禁用SSLPinning</h3><p>通过Hook之类的方式在证书获取环节返回一个空的证书管理器，从而实现不让客户端校验或者通过Hook关键校验函数并返回<code>true</code>来实现校验成功。</p><h2 id="需求分析"><a href="#需求分析" class="headerlink" title="需求分析"></a>需求分析</h2><p>现如今的APP只要是正经一点的基本上都会使用SSLPinning来防止用户轻松的抓取HTTPS流量信息，所以我们如果要抓包的话就必须得把SSLPinning干掉。</p><p>对于如何干掉SSLPinning其实已经有很多的开源项目了。有基于<code>Xposed</code>的、<code>LSPosed</code>的，甚至<code>Magisk</code>的，但这些都存在一定的兼容性问题，手机变砖那真的是常态了。</p><p>而Frida的话则只需要有root权限即可，这也是选择Frida的主要原因之一。但Frida又属于检测的重点照顾对象之一，因此我们还需要进行<code>Anti Anti-Frida</code>。</p><h2 id="防止SSLPinning"><a href="#防止SSLPinning" class="headerlink" title="防止SSLPinning"></a>防止SSLPinning</h2><pre><code>/** * 修改默认临时文件名前缀 * @see https://github.com/frida/frida-java-bridge/blob/main/lib/class-factory.js#L103*/if (&#39;frida&#39; === Java.classFactory.tempFileNaming.prefix)    Java.classFactory.tempFileNaming.prefix = &#39;gc&#39;;Java.perform(() =&gt; &#123;    const X509TrustManager = Java.use(&quot;javax.net.ssl.X509TrustManager&quot;);    const SSLContext = Java.use(&quot;javax.net.ssl.SSLContext&quot;);    // 注册个假的TrustManager类    const TrustManager = Java.registerClass(&#123;        implements: [X509TrustManager],        methods: &#123;            checkClientTrusted(chain, authType) &#123; &#125;,            checkServerTrusted(chain, authType) &#123; &#125;,            getAcceptedIssuers() &#123;                return [];            &#125;,        &#125;,        name: &quot;com.network.TrustManager&quot;,    &#125;);    // 创建用来替换的TrustManager对象数组    const trustManagers = [TrustManager.$new()];    const SSLContextInit = SSLContext.init.overload(        &quot;[Ljavax.net.ssl.KeyManager;&quot;,        &quot;[Ljavax.net.ssl.TrustManager;&quot;,        &quot;java.security.SecureRandom&quot;    );    // Hook SSLContext.init 方法    SSLContextInit.implementation = function (keyManager, trustManager, secureRandom) &#123;        console.log(&#39;[=] Intercepted SSLContext.init()&#39;);            // 替换假的TrustManagers        SSLContextInit.call(this, keyManager, trustManagers, secureRandom);    &#125;;&#125;);</code></pre><p>这里只做了一个最基本的防止SSLPinning校验的演示，如果你想了解更多的话推荐查看<a href="https://github.com/sensepost/objection/blob/master/agent/src/android/pinning.ts">objection</a>的实现。</p><h2 id="反Frida检测"><a href="#反Frida检测" class="headerlink" title="反Frida检测"></a>反Frida检测</h2><pre><code>let i = 0;Interceptor.attach(Module.findExportByName(&#39;libc.so&#39;, &#39;strstr&#39;), &#123;    onEnter(args) &#123;        this.fridaDetection = false;        const haystack = Memory.readCString(args[0]).toLowerCase();        const needle = Memory.readCString(args[1]).toLowerCase();        if (-1 !== haystack.indexOf(needle) &amp;&amp; (            -1 !== haystack.indexOf(&#39;frida&#39;) || // frida相关的字符串            -1 !== haystack.indexOf(&#39;gdbus&#39;) || // dbus线程名            -1 !== haystack.indexOf(&#39;gum-js-loop&#39;) || // gumjs线程名            -1 !== haystack.indexOf(&#39;gmain&#39;) || // vala线程名            -1 !== haystack.indexOf(&#39;linjector&#39;) || // 命名管道相关            -1 !== needle.indexOf(&#39;/data/local/tmp&#39;)) // 目录检测        ) &#123;            this.fridaDetection = true;            if (100 &gt; i) &#123;                console.log(                    `[=] 检测你🐎呢\n` +                    `    haystack: $&#123;haystack&#125;\n` +                    `    needle: $&#123;needle&#125;\n` +                    `    i: $&#123;i++&#125;\n`                );            &#125; else &#123;                const detectionModule = Process.findModuleByAddress(this.returnAddress);                console.log(                    `[=] 检测你🐎呢\n` +                    `    haystack: $&#123;haystack&#125;\n` +                    `    moduleName: $&#123;detectionModule ? detectionModule.name : &#39;null&#39;&#125;\n` +                    `    modulePath: $&#123;detectionModule ? detectionModule.path : &#39;null&#39;&#125;\n` +                    `    moduleBase: $&#123;detectionModule ? detectionModule.base : &#39;null&#39;&#125; moduleSize: $&#123;detectionModule ? detectionModule.size : &#39;null&#39;&#125;\n` +                    `    detectionPointOffset: $&#123;detectionModule ? this.returnAddress.sub(detectionModule.base) : this.returnAddress&#125;\n`                );            &#125;        &#125;    &#125;,    onLeave(retval) &#123;        if (this.fridaDetection)            retval.replace(0);    &#125;&#125;);</code></pre><p>在这个地方我们通过Hook<code>libc</code>中的<a href="https://en.cppreference.com/w/c/string/byte/strstr">strstr</a>函数来实现简易的过检测，究其原因是因为不管你用啥方法，基于字符串查找的检测最终还是得调用这个方法。</p><p>但需要注意的是这种方法不是肯定能过，只是适用部分情况。很多用心点做的检测是可以轻松绕过这份代码的，当然也能Anti Anti就是了，这部分放在后面再说，先来看看代码效果。</p><p>未加载脚本时对进程附加Frida</p><p><img src="/images/1650222130.jpg" alt="UnAntiAntiFrida"></p><p>加载反Frida检测脚本后对进程附加Frida</p><p><img src="/images/1650222131.jpg" alt="AntiAntiFrida"></p><p>可以看到，在未加载脚本之前我们附加到进程之后是会直接被卸载掉的，而加载之后则可以正常附加，并且Frida API的调用也正常。</p><h2 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h2><p>上面说到举例的这种方法只适用于基于字符串匹配的Frida特征检测的情况，那么接下来就举出一些不适用的情况以及一些反检测的思路。列举的一些情况仅为我所知道的，如果你知道更多的请告诉我。</p><p><img src="/images/sticker_genius.gif" alt="nice"></p><ol><li>自己编写执行<code>syscall</code>的汇编代码来代替对于libc中函数的调用。</li><li>使用自己实现的模式匹配算法。</li><li>扫描可执行文件所属内存块，并暴力匹配frida相关特征。</li><li>对指定lib进行监控，循环计算<code>checksum</code>并校验，如果对不上说明被修改或者Hook了，这种方式比较暴力无差别。</li><li>对指定函数头部几个字节进行扫描，检测是否被Hook以及特征是否为Frida所属。</li></ol><p>对于其中<code>2</code>、<code>4</code>、<code>5</code>三种情况目前我并没有思路，比较好的方法就是找到检测点直接把检测做掉。</p><p>所以我们来看一下<code>1</code>、<code>3</code>情况的处理方式，对于这两种情况有一个通用的做法。即通过<code>ptrace(PTRACE_SYSCALL)</code>的方式来监听APP的<code>syscall</code>调用，并拦截函数序号<code>__NR_openat</code>(对应为libc中的openat函数)。</p><p>相关函数与宏在<code>linux/ptrace.h</code>与<code>fcntl.h</code>中有定义。在拦截到相关调用的时候检查调用参数<code>pathname</code>是否包含<code>/proc/self/</code>，如果包含则取消调用并将返回值也即<code>fd</code>改为我们提前准备好的去掉frida特征的相关临时文件的<code>fd</code>。</p><p>这样当程序在对打开的信息流进行扫描的时候就发现不了frida了。</p><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>到这里文章就结束了，迷迷糊糊的也不知道有没有说清楚，<del>又水了一篇文章</del>。</p><p>那么有缘再见~</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>[项目] Taskcloud基本重构完成与后续填坑记录计划贴</title>
      <link href="/2022/07/02/%E9%A1%B9%E7%9B%AE-Taskcloud%E5%9F%BA%E6%9C%AC%E9%87%8D%E6%9E%84%E5%AE%8C%E6%88%90%E4%B8%8E%E5%90%8E%E7%BB%AD%E5%A1%AB%E5%9D%91%E8%AE%B0%E5%BD%95%E8%AE%A1%E5%88%92%E8%B4%B4/"/>
      <url>/2022/07/02/%E9%A1%B9%E7%9B%AE-Taskcloud%E5%9F%BA%E6%9C%AC%E9%87%8D%E6%9E%84%E5%AE%8C%E6%88%90%E4%B8%8E%E5%90%8E%E7%BB%AD%E5%A1%AB%E5%9D%91%E8%AE%B0%E5%BD%95%E8%AE%A1%E5%88%92%E8%B4%B4/</url>
      
        <content type="html"><![CDATA[<p>记录以防忘记。</p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本文仅供学习探讨之用，如果侵犯了您的权益请联系我删除。</p><h2 id="项目地址"><a href="#项目地址" class="headerlink" title="项目地址"></a>项目地址</h2><p>本文只做简要介绍，如果有兴趣还请移步主项目阅读<code>README.md</code>。</p><h3 id="主项目"><a href="#主项目" class="headerlink" title="主项目"></a>主项目</h3><p><a href="https://github.com/Bzi-Han/taskcloud">https://github.com/Bzi-Han/taskcloud</a></p><h3 id="子项目"><a href="#子项目" class="headerlink" title="子项目"></a>子项目</h3><p><em>前端</em> <code>vue3</code> <a href="https://github.com/Bzi-Han/taskcloud_web">https://github.com/Bzi-Han/taskcloud_web</a></p><p><em>后端</em> <code>java</code> <a href="https://github.com/Bzi-Han/taskcloud_backend">https://github.com/Bzi-Han/taskcloud_backend</a></p><p><em>核心</em> <code>c++</code> <a href="https://github.com/Bzi-Han/taskcloud_core">https://github.com/Bzi-Han/taskcloud_core</a></p><h2 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h2><p>云任务是一套定时任务处理程序，用户通过与前端交互添加需要执行的任务到指定的任务包中，并设定任务包的激活状态与定时启动时间(可设定是否只运行一次或每天都运行)。除了用户手动投递的任务包外，系统会在第一次启动时与每天<code>00:00</code>时自动分发当天需要执行的任务。</p><p>任务执行所用的脚本可以是<code>Lua</code> <code>Python</code> <code>Javascript</code>这三种语言编写的代码，可以使用语言自带的各种工具函数和此程序导出的<a href="https://github.com/Bzi-Han/taskcloud/blob/main/docs/APIDocumentaion.md">API</a>接口来进行编程，任务执行的结果与执行过程中的各种日志与报错日志均可在前端控制台中看到，可作为脚本执行问题的参考数据。</p><p>若是任务的开发者还可以在帮助中心发布帮助文档，以更好地帮助用户使用。</p><h2 id="架构"><a href="#架构" class="headerlink" title="架构"></a>架构</h2><p>整个项目的架构图</p><p><img src="/images/1650222128.jpg" alt="项目架构图"></p><p>数据库的结构图</p><p><img src="/images/1650222129.png" alt="数据库结构图"></p><h2 id="基于Docker构建核心项目的编译环境"><a href="#基于Docker构建核心项目的编译环境" class="headerlink" title="基于Docker构建核心项目的编译环境"></a>基于Docker构建核心项目的编译环境</h2><p>因为<a href="https://github.com/Bzi-Han/taskcloud_core">核心项目</a>使用了<code>CMake</code>来帮助构建，所以理论上可以跨<code>Windows</code>与<code>Linux</code>进行编译(没有试过<code>Mac</code>)，但不能保证一定不会遇到问题，因此这里仅作为一个备选解决手段。</p><p>也可以作为构建基于<code>docker-debian</code> <code>clang-14</code>编译环境的参考吧。</p><ol><li>确保<code>docker</code>服务运行中。</li><li>执行<code>docker run -d --name taskcloud_builder -it debian /bin/bash</code>创建基本容器。如果需要 <strong>ssh</strong> 服务的话可再添加<code>-p 外部端口:内部端口</code>进行端口映射，后续再安装 <strong>ssh</strong> 服务即可，但我这里就不需要了。</li><li>执行<code>docker exec -it taskcloud_builder /bin/bash</code>进入容器命令行。</li><li>执行<code>cp /etc/apt/sources.list /etc/apt/sources.list.bak</code>备份 <strong>apt</strong> 源。</li><li>执行<code>sed -i &#39;s/deb.debian.org/mirrors.ustc.edu.cn/g&#39; /etc/apt/sources.list</code>替换 <strong>apt</strong> 源为中科大源，可自行设置其他源。</li><li>执行<code>sed -i &#39;s|security.debian.org/debian-security|mirrors.ustc.edu.cn/debian-security|g&#39; /etc/apt/sources.list</code>替换 <strong>apt-security</strong> 源为中科大源，可自行设置其他源。</li><li>执行<code>apt-get update</code>更新源。</li><li>执行<code>apt-get install wget -y</code>安装 <strong>wget</strong> 工具。</li><li>执行<code>apt install lsb-release wget software-properties-common -y</code>安装 <strong>lsb-release</strong> 为后续安装提供支持。</li><li>执行<code>apt install gnupg -y</code>安装 <strong>gnupg</strong> 为后续安装提供支持，否则会出现<code>Cannot write to &#39;-&#39; (Broken pipe).</code>的情况。</li><li>执行<code>cd /tmp &amp;&amp; wget https://apt.llvm.org/llvm.sh</code>切换到 <strong>tmp</strong> 目录同时下载 <strong>clang</strong> 安装脚本。</li><li>执行<code>chmod +x llvm.sh &amp;&amp; ./llvm.sh 14 all</code>添加执行权限以及直接运行脚本安装 <strong>clang-14</strong> 所有工具链。</li><li>安装完成后执行<code>update-alternatives --install /usr/bin/clang clang /usr/bin/clang-14 1 --slave /usr/bin/clang++ clang++ /usr/bin/clang++-14</code>来设置默认的 <strong>clang</strong> 与 <strong>clang++</strong> 。</li><li>执行<code>apt-get install python3-dev -y</code>安装 <strong>python3-dev</strong> 提供所需的编译环境之一。</li><li>执行<code>apt-get install libssl-dev -y</code>安装 <strong>libssl-dev</strong> 提供所需的编译环境之一。</li><li>环境搭建完毕，可以开始编译项目了。</li></ol><h2 id="TODO"><a href="#TODO" class="headerlink" title="TODO"></a>TODO</h2><ul><li><input checked="" disabled="" type="checkbox"> 添加<code>crypto.gbkToUTF8</code>函数</li><li><input checked="" disabled="" type="checkbox"> 添加<code>crypto.utf8ToGBK</code>函数</li><li><input checked="" disabled="" type="checkbox"> 添加<code>crypto.urlEncode</code>函数</li><li><input checked="" disabled="" type="checkbox"> 添加<code>crypto.urlDecode</code>函数</li><li><input checked="" disabled="" type="checkbox"> 添加<code>crypto.rsaGenerateKeyPair</code>函数</li><li><input checked="" disabled="" type="checkbox"> 添加<code>crypto.rsaEncrypt</code>函数</li><li><input checked="" disabled="" type="checkbox"> 添加<code>crypto.rsaDecrypt</code>函数</li><li><input checked="" disabled="" type="checkbox"> 修改默认管理员账号密码</li><li><input checked="" disabled="" type="checkbox"> 提醒使用<code>java -jar</code>运行后端时添加<code>-Dfile.encoding=UTF-8</code>防止默认编码导致的乱码问题</li><li><input checked="" disabled="" type="checkbox"> 修复后端<code>python</code>与<code>javascript</code>审核错误问题</li><li><input checked="" disabled="" type="checkbox"> 添加<code>system</code>模块与<code>system.delay</code>函数</li><li><input checked="" disabled="" type="checkbox"> 添加<code>requests.put</code>函数</li><li><input checked="" disabled="" type="checkbox"> 添加<code>requests.delete</code>函数</li><li><input checked="" disabled="" type="checkbox"> 添加脚本共享机制，从中央仓库或者指定github仓库中拉取脚本，然后自动导入数据库中，同时也可以以上传zip包的方式。可设定此次拉取是否需要审核，不需要则直接导入为可用状态，且此功能属于管理员功能。</li><li><input checked="" disabled="" type="checkbox"> 前端在登陆页面添加后端服务地址设置，配置保存到<code>localStorage</code>中。</li></ul><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>暂时告一段落了，填坑的话还是慢慢来吧。<br><img src="/images/sticker_darksee.jpg" alt="暗中观察"></p><p>那就这样了，有缘再见~ </p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>[编程] 在Android Studio中使用Kotlin编写一个控制电脑远程开机的APP(WOL技术)</title>
      <link href="/2022/06/12/%E7%BC%96%E7%A8%8B-%E5%9C%A8Android-Studio%E4%B8%AD%E4%BD%BF%E7%94%A8Kotlin%E7%BC%96%E5%86%99%E4%B8%80%E4%B8%AA%E6%8E%A7%E5%88%B6%E7%94%B5%E8%84%91%E8%BF%9C%E7%A8%8B%E5%BC%80%E6%9C%BA%E7%9A%84APP-WOL%E6%8A%80%E6%9C%AF/"/>
      <url>/2022/06/12/%E7%BC%96%E7%A8%8B-%E5%9C%A8Android-Studio%E4%B8%AD%E4%BD%BF%E7%94%A8Kotlin%E7%BC%96%E5%86%99%E4%B8%80%E4%B8%AA%E6%8E%A7%E5%88%B6%E7%94%B5%E8%84%91%E8%BF%9C%E7%A8%8B%E5%BC%80%E6%9C%BA%E7%9A%84APP-WOL%E6%8A%80%E6%9C%AF/</url>
      
        <content type="html"><![CDATA[<p>本文章将只围绕坑与几个技术难点与WOL的一些相关知识展开，不会过多的描述具体细节，如若想知道还请自行查阅项目源码。</p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本文仅供学习探讨之用，如果侵犯了您的权益请联系我删除。</p><h2 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h2><ol><li><a href="https://docs.microsoft.com/en-us/windows/wsl/install" title="WSL Install Documentation">Ubuntu(WSL)</a></li><li><a href="http://manpages.ubuntu.com/manpages/bionic/man1/nslookup.1.html" title="nslookup Documentation">nslookup(Ubuntu)</a></li><li><a href="https://www.wireshark.org/" title="Wireshark Official">Wireshark</a></li><li><a href="https://developer.android.com/studio" title="Official Download">Android Studio</a></li></ol><h2 id="基本原理"><a href="#基本原理" class="headerlink" title="基本原理"></a>基本原理</h2><p>核心依赖的东西只有一个，就是WOL(Wake-on-LAN)技术，即允许通过网络消息远程打开或唤醒网络中的某台计算机。</p><p>WOL技术依赖于主板与网卡，想要使用此功能必须确保你的设备支持此技术。就现代计算机来说，应该已经没有不支持的机器了吧？(心虚)</p><p>WOL唤醒的关键点是一个叫做<code>MagicPacket(魔术包)</code>的东西，当网卡接收到发送往此网卡的魔术包并且经过校验后确认无误后就会通知主板进行系统的唤醒。</p><p><code>MagicPacket</code>的构造十分的简单，由前缀<code>6</code>个<code>0xFF</code>跟后面的重复<code>16</code>次的<code>6</code>个字节的目标机器的网卡MAC地址构成。你可以使用任何传输层的协议进行发送魔术包到目标主机，但通常会使用<code>UDP</code>协议。</p><pre><code>// MAC地址为 11:22:33:44:55:66 的示例魔术包00000000        FF FF FF FF FF FF 11 22 33 44 55 66 11 22 33 44        .......&quot;3DUf.&quot;3D00000010        55 66 11 22 33 44 55 66 11 22 33 44 55 66 11 22        Uf.&quot;3DUf.&quot;3DUf.&quot;00000020        33 44 55 66 11 22 33 44 55 66 11 22 33 44 55 66        3DUf.&quot;3DUf.&quot;3DUf00000030        11 22 33 44 55 66 11 22 33 44 55 66 11 22 33 44        .&quot;3DUf.&quot;3DUf.&quot;3D00000040        55 66 11 22 33 44 55 66 11 22 33 44 55 66 11 22        Uf.&quot;3DUf.&quot;3DUf.&quot;00000050        33 44 55 66 11 22 33 44 55 66 11 22 33 44 55 66        3DUf.&quot;3DUf.&quot;3DUf00000060        11 22 33 44 55 66                                      .&quot;3DUf</code></pre><p>我们只需要将此魔术包发往目标机器即可实现远程唤醒机器。</p><p>参考资料:</p><ol><li><a href="https://en.wikipedia.org/wiki/Wake-on-LAN" title="Wiki">Wake-on-LAN</a></li><li><a href="https://baike.baidu.com/item/%E8%BF%9C%E7%A8%8B%E5%94%A4%E9%86%92" title="百度百科">远程唤醒</a></li></ol><h2 id="需求分析"><a href="#需求分析" class="headerlink" title="需求分析"></a>需求分析</h2><p>其实只实现远程唤醒很简单，上面的内容我觉得也已经说的比较清晰了，就是组包与发包的过程。</p><p>但是如果我们要写成APP的话就只有个唤醒功能肯定是不够的。毕竟不可能每次进入APP还要手动输入一次MAC地址IP地址吧，而且配置也很麻烦。所以我们需要一个扫描局域网在线设备的功能，并可以保存配置到本地，免去手动配置的麻烦。但同时我们也需要保留手动配置的选项作为最终解决手段。</p><p>此外还有一个问题就是如果我们的电脑的IP是动态获取的(DHCP)，则我们的配置可能会失效，例如我现在的一个配置他的目标IP地址为<code>192.168.1.233</code>，而真实记录的IP地址为<code>192.168.1.234</code>。当我们往配置中的IP地址发送魔术包时由于真实机器并没有接收到，所以不会发生任何事情，于是我们需要一个可以控制是否精准唤醒目标机器的开关选项，如果是非精准唤醒则我们会向局域网广播地址<code>192.168.1.255</code>发送魔术包，使得目标机器即使与配置IP不同也可以接收到我们发送的唤醒魔术包。</p><p>在局域网扫描中我们需要获取的信息有IP地址、MAC地址、主机名。其中主机名将作为默认的配置名称，IP地址与MAC地址为唤醒目标机器的主要参数。</p><h2 id="技术难点"><a href="#技术难点" class="headerlink" title="技术难点"></a>技术难点</h2><ol><li>如何扫描局域网中的在线机器，并获取在线机器的IP地址与MAC地址。</li><li>如何通过目标机器的IP地址获取到目标机器的主机名。</li></ol><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><ol><li>使用<code>UDP</code>协议往此网段中的<code>1-254</code>台机器发送数据包使其产生ARP缓存，然后通过<code>cat /proc/net/arp</code>指令获取ARP表，解析ARP表即可获得IP地址与MAC地址。</li><li>使用<code>LLMNR</code>协议协议通过IP地址反向查询目标机器的主机名。</li></ol><h2 id="通过IP地址获取主机名功能的实现"><a href="#通过IP地址获取主机名功能的实现" class="headerlink" title="通过IP地址获取主机名功能的实现"></a>通过IP地址获取主机名功能的实现</h2><p>在Linux中有一款叫<code>nslookup</code>的工具，其功能为通过IP地址可反向查询出目标机器的主机名，接下来我们将通过对这款工具的分析来搞清楚如何实现我们需要的功能。</p><p>打开我们的Ubuntu(Linux子系统 WSL)，输入<code>nslookup ip</code>即可查看到目标机器的主机名</p><p><img src="/images/1650222118.jpeg" alt="nslookup结果"></p><p>可以看到成功查询出了主机名。</p><h2 id="Wireshark"><a href="#Wireshark" class="headerlink" title="Wireshark"></a>Wireshark</h2><p>打开Wireshark，选择以太网开始监听，在filter一栏中我们输入<code>dns || llmnr</code>过滤我们只需要看的协议。</p><p><img src="/images/1650222119.jpeg" alt="Wireshark"></p><p><img src="/images/1650222120.jpeg" alt="Wireshark"></p><p>回到控制台再一次执行我们刚才的命令</p><p><img src="/images/1650222121.jpeg" alt="执行命令Wireshark结果"></p><p>数据出来了之后我们停止抓包，来分析一下它获取主机名的流程。在这里我们只关注<code>IPV4</code>的东西，<code>IPV6</code>可以忽略不看。</p><p><img src="/images/1650222122.jpeg" alt="DNS反向查询请求结果"></p><p>可以看到他先是向默认的DNS服务器发送了一个反向查询主机名的请求（毕竟如果能直接在DNS服务器上找到就不需要进行多播了），但是DNS服务器上并没有找到相关的信息，所以它返回的数据包中并没有包含<code>Answer</code>。</p><p><code>.in-addr.arpa</code>是反向查询的专属命名空间，例如图中查询<code>192.168.3.102</code>则它的Name为<code>102.3.168.192.in-addr.arpa</code>。</p><p>在查询DNS服务器无果后它又使用LLMNR协议向局域网中广播了一则”寻机启示”，其中<code>224.0.0.252</code>这个地址是LLMNR协议的固定地址，而查询的数据包内容是不变的，因为LLMNR是基于DNS协议的一个小分支。</p><p>在广播了”寻机启示”之后，视网络状况而定目标主机如果接收到了信息，他就会主动向本机发送主机名等信息。</p><p>如图所示</p><p><img src="/images/1650222123.jpeg" alt="LLMNR广播请求结果"></p><p>其中红色框起来的是发送地址与目标地址，可以看到结果是由我们要查询的目标机器主动发往我们本机的。橙色框圈起来的<code>Domain Name</code>就是我们要查询的目标机器的主机名。</p><p>至此问题解决。</p><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><p>对于<code>DeviceDiscovery.getComputerName</code>的实现</p><pre><code>fun getComputerName(targetIp: String): String &#123;    var domainNameOffset: Int    // 组包    val packet = targetIp.let &#123;        val ips = it.split(&quot;.&quot;)        val hard01 = byteArrayOf(0x01, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00)        val hard02 = byteArrayOf(0x00, 0x0c, 0x00, 0x01)        val packetBuilder = ByteBuffer.allocate(256)        packetBuilder.putShort(888) //标识符        packetBuilder.put(hard01) //硬编码01        // 编码查询地址        domainNameOffset = packetBuilder.position()        for (i in 3 downTo 0) &#123;            packetBuilder.put(ips[i].length.toByte())            packetBuilder.put(ips[i].toByteArray())        &#125;        packetBuilder.put(7)        packetBuilder.put(&quot;in-addr&quot;.toByteArray())        packetBuilder.put(4)        packetBuilder.put(&quot;arpa&quot;.toByteArray())        packetBuilder.put(0)        packetBuilder.put(hard02) //硬编码02        domainNameOffset = packetBuilder.position() - domainNameOffset + 6 + packetBuilder.position()        DatagramPacket(packetBuilder.array(), 0, packetBuilder.position(), InetAddress.getByName(&quot;224.0.0.252&quot;), 5355)    &#125;    // 发送请求    kotlin.runCatching &#123; sender.send(packet) &#125;.onFailure &#123; return &quot;UnReachableDevice&quot; &#125;    // 接收返回    val recvBuffer = ByteBuffer.allocate(1024)    val recvPacket = DatagramPacket(recvBuffer.array(), recvBuffer.capacity())    sender.soTimeout = 1000    kotlin.runCatching &#123;        sender.receive(recvPacket)    &#125;.onFailure &#123; return &quot;UnKnowDevice&quot; &#125;    // 读取域名    recvBuffer.position(domainNameOffset)    val domainNameByteArray = ByteBuffer.allocate(recvBuffer.get().toInt())    recvBuffer.get(domainNameByteArray.array())    return String(domainNameByteArray.array())&#125;</code></pre><p>对于<code>DeviceDiscovery.scan</code>的实现</p><pre><code>fun scan(networkSegmentPrefix: String, progress: (Float) -&gt; Unit = &#123;&#125;): ArrayList&lt;LanDeviceInfo&gt; &#123;    val result = ArrayList&lt;LanDeviceInfo&gt;()    val data = ByteArray(1)    progress(0f)    for (i in 1..254) &#123;        kotlin.runCatching &#123; sender.send(DatagramPacket(data, 0, 1, InetAddress.getByName(networkSegmentPrefix + i), 888)) &#125;        progress(i / 254f)    &#125;    progress(1f)    progress(0f)    val table = runCommand(&quot;cat&quot;, &quot;/proc/net/arp&quot;)!!            .replace(&quot;\r&quot;, &quot;&quot;)            .split(&quot;\n&quot;)    for ((i, row) in table.withIndex()) &#123;        val col = row.let &#123;            val results = ArrayList&lt;String&gt;()            var flag = true            val sb = StringBuilder()            for (c in it.trim()) &#123;                when (c) &#123;                    &#39; &#39; -&gt; &#123;                        if (flag) &#123;                            results.add(sb.toString())                            sb.clear()                            flag = false                        &#125;                    &#125;                    else -&gt; &#123;                        sb.append(c)                        flag = true                    &#125;                &#125;            &#125;            if (flag)                results.add(sb.toString())            results        &#125;        when (col.size) &#123;            6 -&gt; &#123;                if (&quot;00:00:00:00:00:00&quot; != col[3] &amp;&amp; col[0].contains(networkSegmentPrefix)) &#123;                    result.add(LanDeviceInfo(                            getComputerName(col[0]),                            col[0],                            col[3],                            col[5],                            &quot;888&quot;                    ))                &#125;            &#125;        &#125;        progress(i / table.size.toFloat())    &#125;    progress(1f)    return result&#125;</code></pre><h2 id="最终效果"><a href="#最终效果" class="headerlink" title="最终效果"></a>最终效果</h2><p><img src="/images/1650222124.jpeg" alt="APP最终结果01"></p><p><img src="/images/1650222125.jpeg" alt="APP最终结果02"></p><p><img src="/images/1650222126.jpeg" alt="APP最终结果03"></p><p><img src="/images/1650222127.jpeg" alt="APP最终结果04"></p><h2 id="完整代码仓库地址"><a href="#完整代码仓库地址" class="headerlink" title="完整代码仓库地址"></a>完整代码仓库地址</h2><p><a href="https://github.com/Bzi-Han/WOLDeviceManager">GitHub</a></p><h2 id="避坑指南"><a href="#避坑指南" class="headerlink" title="避坑指南"></a>避坑指南</h2><ol><li>扫描是扫描局域网中目前在线的机器。</li><li>对于<code>真·关机</code>的机器是没法唤醒的，例如使用<code>shutdown -s -t 0</code>进行关机或者长按电源键强制关机与断电导致关机的，这三种情况无法唤醒。</li><li>Android10+的系统<a href="https://developer.android.com/about/versions/10/privacy/changes#proc-net-filesystem">无法使用</a>扫描功能，因为从Android10开始应用无法访问<code>/proc/net</code>，所以导致无法读取ARP表来进行获取IP地址与MAC地址。</li></ol><h2 id="一些思考"><a href="#一些思考" class="headerlink" title="一些思考"></a>一些思考</h2><ol><li>在配置中添加修改配置功能。</li><li>在配置中添加配置分组功能。</li><li>在配置中添加批量唤醒某个分组机器的功能。</li><li>寻找Android10+无法扫描的解决方案。</li></ol><p><del>算是遗留问题了，懒狗不想实现</del></p><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p><img src="/images/sticker_newfolder.jpg" alt="新建文件夹"></p><p>那就这样了，有缘再见~</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>[编程] 在C++中实现一个内存池与几种垃圾回收机制(GC策略)</title>
      <link href="/2022/04/28/%E7%BC%96%E7%A8%8B-%E5%9C%A8C++%E4%B8%AD%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E5%86%85%E5%AD%98%E6%B1%A0%E4%B8%8E%E5%87%A0%E7%A7%8D%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6(GC%E7%AD%96%E7%95%A5)/"/>
      <url>/2022/04/28/%E7%BC%96%E7%A8%8B-%E5%9C%A8C++%E4%B8%AD%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E5%86%85%E5%AD%98%E6%B1%A0%E4%B8%8E%E5%87%A0%E7%A7%8D%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6(GC%E7%AD%96%E7%95%A5)/</url>
      
        <content type="html"><![CDATA[<p>在特定情况下使用内存池可显著提高性能。</p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本文仅供学习探讨之用，如果侵犯了您的权益请联系我删除。</p><h2 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h2><ol><li><a href="https://code.visualstudio.com/" title="Visual Studio Code Official">Visual Studio Code</a></li><li><a href="http://graphviz.org/" title="Graphviz Official">Graphviz</a></li></ol><h2 id="需求与思考"><a href="#需求与思考" class="headerlink" title="需求与思考"></a>需求与思考</h2><ol><li>可限定内存池最大可向系统申请的内存大小</li><li>尽量保证池中的内存单元都在连续的内存上</li><li>内存池每次可申请任意大小的内存</li><li>进行内存的申请时若内存池的空闲空间不足且所需内存未超过内存池最大限定可申请的内存时将进行动态扩容</li><li>内存单元释放的同时进行临近内存碎片的合并</li><li>当前需要申请的内存加上已申请的内存若超过限定最大可向系统申请的内存大小时抛出异常</li></ol><ul><li>Garbage Collection<ul><li>内存标记算法</li><li>内存标记整理算法</li><li>内存分代标记整理算法</li></ul></li><li>当前需要申请的内存加上已申请的内存若超过限定最大可向系统申请的内存大小时启动GC进行垃圾回收</li><li>若启动GC后仍无法分配内存则抛出异常</li></ul><h2 id="内存池数据结构"><a href="#内存池数据结构" class="headerlink" title="内存池数据结构"></a>内存池数据结构</h2><pre><code>// 内存单元struct MemoryUnit&#123;    uint8_t *data;        // 内存单元的数据地址    size_t size;          // 内存的数据大小    MemoryBlock *block;   // 内存单元所属的内存块    MemoryUnit *nextUnit; // 下一个内存单元    MemoryUnit *prevUnit; // 上一个内存单元&#125;;// 内存块struct MemoryBlock&#123;    uint8_t *data;          // 内存块的数据地址    size_t size;            // 内存块的数据大小    size_t freeTotal;       // 内存块中剩余的空闲内存大小    MemoryUnit *freeList;   // 内存块中的空闲内存单元    MemoryUnit *usedList;   // 内存块中的已使用内存单元    MemoryBlock *nextBlock; // 下一个内存块    MemoryBlock *prevBlock; // 上一个内存块&#125;;// 内存池struct MemoryPool&#123;    size_t systemPageSize; // 当前操作系统的内存页定义大小    size_t blockMinSize;   // 申请内存块时至少申请不能小于块最小大小    size_t poolMaxSize;    // 内存池的最大可向系统申请的内存大小    size_t poolSize;       // 内存池的当前大小    MemoryBlock *blocks;   // 内存块单向循环链表&#125;;</code></pre><h2 id="需求的解决方案"><a href="#需求的解决方案" class="headerlink" title="需求的解决方案"></a>需求的解决方案</h2><ol><li>结构体<code>MemoryPool</code>的成员<code>poolMaxSize</code>与<code>poolSize</code>用于对比并限定最大可申请的内存大小</li><li>结构体<code>MemoryPool</code>的成员<code>blockMinSize</code>用于确保单次申请过小的内存单元导致过多的不连续内存块</li><li>结构体<code>MemoryUnit</code>的成员<code>size</code>用于存放当前内存单元所使用的内存大小</li><li>若当前条件满足动态扩容的条件时，向系统申请新的内存块并使用头插法插入结构体<code>MemoryPool</code>的成员<code>blocks</code>链表中，这也是将其设计为单项循环链表的原因。与此同此还要更新成员<code>poolSize</code>的数值。</li><li>内存碎片的合并将会在内存单元释放时自动进行<strong>临近</strong>单元合并，这也是结构体<code>MemoryUnit</code>设计为双向链表的原因之一</li><li>使用当前想要申请的内存大小加上结构体<code>MemoryPool</code>的成员<code>poolSize</code>的数值进行判断即可</li></ol><h2 id="内存池代码定义与实现"><a href="#内存池代码定义与实现" class="headerlink" title="内存池代码定义与实现"></a>内存池代码定义与实现</h2><p>类<code>MemoryPool</code>的定义</p><pre><code>class MemoryPool&#123;public:    struct MemoryBlock;    struct MemoryUnit    &#123;        uint8_t *data;        size_t size;        MemoryBlock *block;        MemoryUnit *nextUnit;        MemoryUnit *prevUnit;    &#125;;    struct MemoryBlock    &#123;        uint8_t *data;        size_t size;        size_t freeTotal;        MemoryUnit *freeList;        MemoryUnit *usedList;        MemoryBlock *nextBlock;        MemoryBlock *prevBlock;    &#125;;    using unit_t = MemoryUnit;    using block_t = MemoryBlock;public:    MemoryPool(size_t poolMaxSize = 128 * 1024 * 1024, size_t blockMinSize = 4 * 1024 * 1024);    ~MemoryPool();    void *alloc(size_t size);    void free(void *data);private:    block_t *allocBlock(size_t size);    void freeBlock(block_t *block);    unit_t *allocUnit(size_t size);    void freeUnit(unit_t *unit);private:    size_t m_systemPageSize = 0;    size_t m_poolMaxSize = 0;    size_t m_blockMinSize = 0;    size_t m_poolSize = 0;    block_t *m_blocks = nullptr;&#125;;</code></pre><p>对于<code>MemoryPool::allocBlock</code>方法的实现</p><pre><code>MemoryPool::block_t *MemoryPool::allocBlock(size_t size)&#123;    // allocate memory block    auto alignedSize = size + sizeof(block_t) + sizeof(unit_t);    alignedSize = (alignedSize + (m_systemPageSize - 1)) &amp; ~(m_systemPageSize - 1); // align to system page size    if (m_blockMinSize &gt; alignedSize)        alignedSize = m_blockMinSize;    auto block = reinterpret_cast&lt;block_t *&gt;(::VirtualAlloc(nullptr, alignedSize, MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE));    if (nullptr == block)        return nullptr;    // initialize memory block    block-&gt;data = reinterpret_cast&lt;uint8_t *&gt;(block) + sizeof(block_t);    block-&gt;size = alignedSize - sizeof(block_t);    auto dataPosition = block-&gt;data;    // initialize memory used unit    block-&gt;usedList = nullptr;    // initialize memory free unit    block-&gt;freeList = reinterpret_cast&lt;unit_t *&gt;(dataPosition);    dataPosition += sizeof(unit_t);    block-&gt;freeList-&gt;data = dataPosition;    block-&gt;freeList-&gt;size = block-&gt;size - (dataPosition - block-&gt;data);    block-&gt;freeList-&gt;nextUnit = block-&gt;freeList;    block-&gt;freeList-&gt;prevUnit = block-&gt;freeList;    block-&gt;freeList-&gt;block = block;    block-&gt;freeTotal = block-&gt;freeList-&gt;size;    // add to block list    if (nullptr != m_blocks)    &#123;        block-&gt;prevBlock = m_blocks-&gt;prevBlock;        block-&gt;nextBlock = m_blocks;        m_blocks-&gt;prevBlock-&gt;nextBlock = block;        m_blocks-&gt;prevBlock = block;    &#125;    else    &#123;        block-&gt;prevBlock = block;        block-&gt;nextBlock = block;        m_blocks = block;    &#125;    // update pool size    m_poolSize += block-&gt;size + sizeof(block_t);    return block;&#125;</code></pre><p>这里在申请内存时确保与当前操作系统内存页定义大小对齐。</p><p>对于<code>MemoryPool::freeBlock</code>方法的实现</p><pre><code>void MemoryPool::freeBlock(block_t *block)&#123;    // remove from block list    if (m_blocks-&gt;prevBlock == block &amp;&amp; m_blocks-&gt;nextBlock == block)        m_blocks = nullptr;    else    &#123;        block-&gt;prevBlock-&gt;nextBlock = block-&gt;nextBlock;        block-&gt;nextBlock-&gt;prevBlock = block-&gt;prevBlock;        if (m_blocks == block)            m_blocks = block-&gt;nextBlock;    &#125;    // update pool size    m_poolSize -= block-&gt;size + sizeof(block_t);    // free memory block    ::VirtualFree(block, 0, MEM_RELEASE);&#125;</code></pre><p>对于<code>MemoryPool::allocUnit</code>方法的实现</p><pre><code>MemoryPool::unit_t *MemoryPool::allocUnit(size_t size)&#123;    // check if no block is available    if (nullptr == m_blocks)        return nullptr;    // allocate memory unit    auto block = m_blocks; // first block    do    &#123;        // check if is there no enough memory in the block        if (size &gt; block-&gt;freeTotal)        &#123;            block = block-&gt;nextBlock;            continue;        &#125;        auto unit = block-&gt;freeList; // first free unit        do        &#123;            // check if is there no enough memory in the unit            if (size &gt; unit-&gt;size)            &#123;                unit = unit-&gt;nextUnit;                continue;            &#125;            // check if unit size is more than wanted size, split unit            if (unit-&gt;size &gt; size + sizeof(unit_t))            &#123;                auto newUnit = reinterpret_cast&lt;unit_t *&gt;(unit-&gt;data + size);                newUnit-&gt;data = unit-&gt;data + size + sizeof(unit_t);                newUnit-&gt;size = unit-&gt;size - size - sizeof(unit_t);                newUnit-&gt;nextUnit = unit-&gt;nextUnit;                newUnit-&gt;prevUnit = unit;                newUnit-&gt;block = unit-&gt;block;                unit-&gt;nextUnit-&gt;prevUnit = newUnit;                unit-&gt;nextUnit = newUnit;                unit-&gt;size = size;            &#125;            // remove unit from free list            unit-&gt;prevUnit-&gt;nextUnit = unit-&gt;nextUnit;            unit-&gt;nextUnit-&gt;prevUnit = unit-&gt;prevUnit;            if (block-&gt;freeList == unit)                block-&gt;freeList = unit-&gt;nextUnit;            // add unit to used list            if (nullptr == block-&gt;usedList)            &#123;                block-&gt;usedList = unit;                unit-&gt;nextUnit = unit;                unit-&gt;prevUnit = unit;            &#125;            else            &#123;                unit-&gt;nextUnit = block-&gt;usedList;                unit-&gt;prevUnit = block-&gt;usedList-&gt;prevUnit;                block-&gt;usedList-&gt;prevUnit-&gt;nextUnit = unit;                block-&gt;usedList-&gt;prevUnit = unit;            &#125;            // update free total            block-&gt;freeTotal -= unit-&gt;size;            return unit;        &#125; while (unit != block-&gt;freeList);    &#125; while (block != m_blocks);    return nullptr;&#125;</code></pre><p>对于<code>MemoryPool::freeUnit</code>方法的实现</p><pre><code>void MemoryPool::freeUnit(unit_t *unit)&#123;    auto freeSize = unit-&gt;size;    // remove unit from used list    if (unit-&gt;prevUnit == unit &amp;&amp; unit-&gt;nextUnit == unit)        unit-&gt;block-&gt;usedList = nullptr;    else    &#123;        unit-&gt;prevUnit-&gt;nextUnit = unit-&gt;nextUnit;        unit-&gt;nextUnit-&gt;prevUnit = unit-&gt;prevUnit;        if (unit-&gt;block-&gt;usedList == unit)            unit-&gt;block-&gt;usedList = unit-&gt;nextUnit;    &#125;    // add the unit to the free list, order by address    if (nullptr == unit-&gt;block-&gt;freeList)    &#123;        unit-&gt;nextUnit = unit;        unit-&gt;prevUnit = unit;        unit-&gt;block-&gt;freeList = unit;    &#125;    else    &#123;        auto prevUnit = unit-&gt;block-&gt;freeList;        auto nextUnit = unit-&gt;block-&gt;freeList-&gt;nextUnit;        if (prevUnit == prevUnit-&gt;prevUnit &amp;&amp; prevUnit == prevUnit-&gt;nextUnit)        &#123;            // combine units if is there near units            if (unit-&gt;data + unit-&gt;size == reinterpret_cast&lt;uint8_t *&gt;(nextUnit)) // combine next unit            &#123;                unit-&gt;size += nextUnit-&gt;size + sizeof(unit_t);                unit-&gt;nextUnit = unit;                unit-&gt;prevUnit = unit;                unit-&gt;block-&gt;freeList = unit;            &#125;            else if (prevUnit-&gt;data + prevUnit-&gt;size == reinterpret_cast&lt;uint8_t *&gt;(unit)) // combine prev unit                prevUnit-&gt;size += unit-&gt;size + sizeof(unit_t);            else // add unit to free list            &#123;                unit-&gt;nextUnit = nextUnit;                unit-&gt;prevUnit = nextUnit;                nextUnit-&gt;prevUnit = unit;                nextUnit-&gt;nextUnit = unit;                unit-&gt;block-&gt;freeList = nextUnit &lt; unit ? nextUnit : unit;            &#125;        &#125;        else        &#123;            // find insert position            while (nextUnit != unit-&gt;block-&gt;freeList &amp;&amp; nextUnit &lt; unit)            &#123;                prevUnit = nextUnit;                nextUnit = nextUnit-&gt;nextUnit;            &#125;            // combine the units if is there are near units            if (unit-&gt;data + unit-&gt;size == reinterpret_cast&lt;uint8_t *&gt;(nextUnit)) // combine next unit            &#123;                unit-&gt;size += nextUnit-&gt;size + sizeof(unit_t);                unit-&gt;nextUnit = nextUnit-&gt;nextUnit;                unit-&gt;prevUnit = nextUnit-&gt;prevUnit;                nextUnit-&gt;prevUnit-&gt;nextUnit = unit;                nextUnit-&gt;nextUnit-&gt;prevUnit = unit;                nextUnit = nextUnit-&gt;nextUnit;            &#125;            if (prevUnit-&gt;data + prevUnit-&gt;size == reinterpret_cast&lt;uint8_t *&gt;(unit)) // combine prev unit            &#123;                prevUnit-&gt;size += unit-&gt;size + sizeof(unit_t);                prevUnit-&gt;nextUnit = nextUnit;                nextUnit-&gt;prevUnit = prevUnit;            &#125;        &#125;    &#125;    // update free total    m_blocks-&gt;freeTotal += freeSize;&#125;</code></pre><p>这4个主要的方法实现好之后就是<code>MemoryPool::alloc</code>与<code>MemoryPool::free</code>两个方法的实现了，我们要做的只需要对上面4个方法进行逻辑的封装就好了。</p><p>对于<code>MemoryPool::alloc</code>方法的实现</p><pre><code>void *MemoryPool::alloc(size_t size)&#123;    if (0 == size)        return nullptr;    if (nullptr == m_blocks)        m_blocks = allocBlock(size);    auto unit = allocUnit(size);    if (nullptr == unit)    &#123;        if (size + m_poolSize &gt; m_poolMaxSize)            throw std::bad_alloc();        auto block = allocBlock(size);        if (nullptr == block)            return nullptr;        unit = allocUnit(size);        if (nullptr == unit)            return nullptr;    &#125;    return unit-&gt;data;&#125;</code></pre><p>对于<code>MemoryPool::free</code>方法的实现</p><pre><code>void MemoryPool::free(void *data)&#123;    if (nullptr == data)        return;    auto unit = reinterpret_cast&lt;unit_t *&gt;(reinterpret_cast&lt;uint8_t *&gt;(data) - sizeof(unit_t));    if (nullptr == unit)        return;    if (nullptr == unit-&gt;block)        return;    freeUnit(unit);&#125;</code></pre><p>到这里，内存池的主体已经搭建好了，那接下来就对比一下性能。</p><h2 id="性能对比"><a href="#性能对比" class="headerlink" title="性能对比"></a>性能对比</h2><p>测试用的代码如下</p><pre><code>MemoryPool g_memoryPool(1 * 1024 * 1024 * 1024);template &lt;typename runable_t&gt;struct RunTickCount&#123;    runable_t &amp;&amp;runable;    uint64_t operator()() const noexcept    &#123;        auto result = __rdtsc();        runable();        return __rdtsc() - result;    &#125;&#125;;void test01()&#123;    for (size_t i = 0; i &lt; 100; i++)    &#123;        auto data = new char[8 * 1024 * 1024];        delete[] data;    &#125;&#125;void test02()&#123;    for (size_t i = 0; i &lt; 100; i++)    &#123;        auto data = ::VirtualAlloc(nullptr, 8 * 1024 * 1024, MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE);        ::VirtualFree(data, 0, MEM_RELEASE);    &#125;&#125;void test03()&#123;    for (size_t i = 0; i &lt; 100; i++)    &#123;        auto data = g_memoryPool.alloc(8 * 1024 * 1024);        g_memoryPool.free(data);    &#125;&#125;void test04()&#123;    for (size_t i = 0; i &lt; 100; i++)        auto data = new char[8 * 1024 * 1024];&#125;void test05()&#123;    for (size_t i = 0; i &lt; 100; i++)        auto data = ::VirtualAlloc(nullptr, 8 * 1024 * 1024, MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE);&#125;void test06()&#123;    for (size_t i = 0; i &lt; 100; i++)        auto data = g_memoryPool.alloc(8 * 1024 * 1024);&#125;int main()&#123;    try    &#123;        std::cout &lt;&lt; &quot;[*] test 100 loop with allocating and freeing the memory of 8MB&quot; &lt;&lt; std::endl;        std::cout &lt;&lt; &quot;[=] std new-delete time: &quot; &lt;&lt; RunTickCount&lt;decltype(test01)&gt;&#123;test01&#125;() &lt;&lt; &quot; ticks&quot; &lt;&lt; std::endl;        std::cout &lt;&lt; &quot;[=] windows virtualAlloc-Free time: &quot; &lt;&lt; RunTickCount&lt;decltype(test02)&gt;&#123;test02&#125;() &lt;&lt; &quot; ticks&quot; &lt;&lt; std::endl;        std::cout &lt;&lt; &quot;[=] memory pool alloc-free time: &quot; &lt;&lt; RunTickCount&lt;decltype(test03)&gt;&#123;test03&#125;() &lt;&lt; &quot; ticks&quot; &lt;&lt; std::endl;        std::cout &lt;&lt; &quot;[=] std just new time: &quot; &lt;&lt; RunTickCount&lt;decltype(test04)&gt;&#123;test04&#125;() &lt;&lt; &quot; ticks&quot; &lt;&lt; std::endl;        std::cout &lt;&lt; &quot;[=] windows just virtualAlloc time: &quot; &lt;&lt; RunTickCount&lt;decltype(test05)&gt;&#123;test05&#125;() &lt;&lt; &quot; ticks&quot; &lt;&lt; std::endl;        std::cout &lt;&lt; &quot;[=] memory pool just alloc time: &quot; &lt;&lt; RunTickCount&lt;decltype(test06)&gt;&#123;test06&#125;() &lt;&lt; &quot; ticks&quot; &lt;&lt; std::endl;        std::cout &lt;&lt; &quot;[+] test passed&quot; &lt;&lt; std::endl;    &#125;    catch (const std::exception &amp;e)    &#123;        std::cerr &lt;&lt; &quot;[-] &quot; &lt;&lt; e.what() &lt;&lt; std::endl;    &#125;    return 0;&#125;</code></pre><p>编译使用的参数<code>cl .\test_memorypool.cc /O2 /EHsc /std:c++20</code></p><p><img src="/images/1650222097.jpg" alt="性能测试结果"></p><p>这里仅用WindowsAPI与内存池的性能做比较，对于<code>new</code>与<code>delete</code>就当看个乐呵。</p><p>可以看到，内存池在循环申请与释放的测试中一骑绝尘。<br>这是因为在<code>freeUnit</code>时我们并没有真的把内存还给系统，而是交给内存池来保管。<br>而第二次进入<code>allocUnit</code>时因为还有可用的内存，所以可以直接分配，不需要向系统申请新的内存！</p><p>但是内存池在仅申请内存不释放的测试中被WindowsAPI所击败，这是因为仅申请内存的话调用WindowsAPI仅需一次<code>VirtualAlloc</code>的费用。<br>而内存池每次进行动态扩容时，不仅需要一次<code>VirtualAlloc</code>的费用，还需要对内存池中的各项参数进行调整，所以导致费用升高。</p><p>那么是因为这个内存池太垃圾了？其实不然，我们默认设定了内存池的最小块大小时4MB，而每次申请的内存大小为8MB，这就导致了内存池需要不断地进行动态扩容。<br>如果我们这里把内存池的块内存大小设置的更大，或者说我们每次申请的内存大小并不超过默认块大小，那么情况又会有所不同。</p><p>我们把每次申请的内存大小修改为4KB</p><pre><code>void test05()&#123;    for (size_t i = 0; i &lt; 100; i++)        auto data = ::VirtualAlloc(nullptr, 4 * 1024, MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE);&#125;void test06()&#123;    for (size_t i = 0; i &lt; 100; i++)        auto data = g_memoryPool.alloc(4 * 1024);&#125;</code></pre><p>再来看结果</p><p><img src="/images/1650222098.jpg" alt="性能测试结果"></p><p>这次轮到WindowsAPI被内存池击败了。由此可见，并不是所有情况下内存池都是适用的，仅在特定情况下内存池能较好的发挥其作用。</p><p>接下来我们写一段程序来dump内存池的内存结构，了解一下在<code>freeUnit</code>时究竟发生了什么。</p><h2 id="内存池释放单元时的Graphviz图"><a href="#内存池释放单元时的Graphviz图" class="headerlink" title="内存池释放单元时的Graphviz图"></a>内存池释放单元时的Graphviz图</h2><p>先修改一下代码，创建一个新的类<code>MemoryPoolX</code>并继承<code>MemoryPool</code>，我们将在这个类里面进行dump操作</p><pre><code>class MemoryPoolX final : public MemoryPool&#123;public:    MemoryPoolX(size_t poolMaxSize = 128 * 1024 * 1024, size_t blockMinSize = 4 * 1024 * 1024)        : MemoryPool(poolMaxSize, blockMinSize)    &#123;    &#125;    ~MemoryPoolX()    &#123;    &#125;    void dumpGraphviz()    &#123;        std::ofstream out(&quot;test_memorypool.dot&quot;);        out &lt;&lt; &quot;digraph DataStructure &#123;\n&quot;;        out &lt;&lt; &quot;node [shape=record];\n&quot;;        out &lt;&lt; &quot;\&quot;&quot; &lt;&lt; this &lt;&lt; &quot;\&quot; [label=\&quot;&#123;&lt;f0&gt;MemoryPool|&quot;            &lt;&lt; this &lt;&lt; &quot;|&quot;            &lt;&lt; &quot;&#123;systemPageSize|&quot; &lt;&lt; m_systemPageSize &lt;&lt; &quot;&#125;|&quot;            &lt;&lt; &quot;&#123;poolMaxSize|&quot; &lt;&lt; m_poolMaxSize &lt;&lt; &quot;&#125;|&quot;            &lt;&lt; &quot;&#123;blockMinSize|&quot; &lt;&lt; m_blockMinSize &lt;&lt; &quot;&#125;|&quot;            &lt;&lt; &quot;&#123;poolSize|&quot; &lt;&lt; m_poolSize &lt;&lt; &quot;&#125;|&quot;            &lt;&lt; &quot;&#123;&lt;f1&gt;blocks|&quot; &lt;&lt; m_blocks &lt;&lt; &quot;&#125;&quot;            &lt;&lt; &quot;&#125;\&quot; color=\&quot;#409eff\&quot;];\n&quot;;        block_t *block = m_blocks;        do        &#123;            out &lt;&lt; &quot;\&quot;&quot; &lt;&lt; block &lt;&lt; &quot;\&quot; [label=\&quot;&#123;&lt;f0&gt;MemoryBlock|&quot;                &lt;&lt; block &lt;&lt; &quot;|&quot;                &lt;&lt; &quot;&#123;data|&quot; &lt;&lt; block-&gt;data &lt;&lt; &quot;&#125;|&quot;                &lt;&lt; &quot;&#123;size|&quot; &lt;&lt; block-&gt;size &lt;&lt; &quot;&#125;|&quot;                &lt;&lt; &quot;&#123;freeTotal|&quot; &lt;&lt; block-&gt;freeTotal &lt;&lt; &quot;&#125;|&quot;                &lt;&lt; &quot;&#123;&lt;f1&gt;freeList|&quot; &lt;&lt; block-&gt;freeList &lt;&lt; &quot;&#125;|&quot;                &lt;&lt; &quot;&#123;&lt;f2&gt;usedList|&quot; &lt;&lt; block-&gt;usedList &lt;&lt; &quot;&#125;|&quot;                &lt;&lt; &quot;&#123;&lt;f3&gt;nextBlock|&quot; &lt;&lt; block-&gt;nextBlock &lt;&lt; &quot;&#125;|&quot;                &lt;&lt; &quot;&#123;&lt;f4&gt;prevBlock|&quot; &lt;&lt; block-&gt;prevBlock &lt;&lt; &quot;&#125;&quot;                &lt;&lt; &quot;&#125;\&quot; color=\&quot;#909399\&quot;];\n&quot;;            unit_t *unit = block-&gt;usedList;            do            &#123;                out &lt;&lt; &quot;\&quot;&quot; &lt;&lt; unit &lt;&lt; &quot;\&quot; [label=\&quot;&#123;&lt;f0&gt;MemoryUnit|&quot;                    &lt;&lt; unit &lt;&lt; &quot;|&quot;                    &lt;&lt; &quot;&#123;data|&quot; &lt;&lt; unit-&gt;data &lt;&lt; &quot;&#125;|&quot;                    &lt;&lt; &quot;&#123;size|&quot; &lt;&lt; unit-&gt;size &lt;&lt; &quot;&#125;|&quot;                    &lt;&lt; &quot;&#123;block|&quot; &lt;&lt; unit-&gt;block &lt;&lt; &quot;&#125;|&quot;                    &lt;&lt; &quot;&#123;&lt;f1&gt;nextUnit|&quot; &lt;&lt; unit-&gt;nextUnit &lt;&lt; &quot;&#125;|&quot;                    &lt;&lt; &quot;&#123;&lt;f2&gt;prevUnit|&quot; &lt;&lt; unit-&gt;prevUnit &lt;&lt; &quot;&#125;&quot;                    &lt;&lt; &quot;&#125;\&quot; color=\&quot;#f56c6c\&quot;];\n&quot;;                if (unit == block-&gt;usedList)                &#123;                    out &lt;&lt; &quot;subgraph cluster_&quot; &lt;&lt; unit &lt;&lt; &quot; &#123;\n&quot;                        &lt;&lt; &quot;label=\&quot;usedList\&quot;;\n&quot;;                    out &lt;&lt; &quot;\&quot;&quot; &lt;&lt; block &lt;&lt; &quot;\&quot;:f2 -&gt; \&quot;&quot; &lt;&lt; unit &lt;&lt; &quot;\&quot;:f0 [style=\&quot;dotted\&quot; color=\&quot;#0000ff\&quot;];\n&quot;;                &#125;                else                    out &lt;&lt; &quot;\&quot;&quot; &lt;&lt; unit-&gt;nextUnit &lt;&lt; &quot;\&quot;:f2 -&gt; \&quot;&quot; &lt;&lt; unit &lt;&lt; &quot;\&quot;:f0 [style=\&quot;dotted\&quot; color=\&quot;#0000ff\&quot;];\n&quot;;                unit = unit-&gt;nextUnit;            &#125; while (unit != block-&gt;usedList);            out &lt;&lt; &quot;&#125;\n&quot;;            unit = block-&gt;freeList;            do            &#123;                out &lt;&lt; &quot;\&quot;&quot; &lt;&lt; unit &lt;&lt; &quot;\&quot; [label=\&quot;&#123;&lt;f0&gt;MemoryUnit|&quot;                    &lt;&lt; unit &lt;&lt; &quot;|&quot;                    &lt;&lt; &quot;&#123;data|&quot; &lt;&lt; unit-&gt;data &lt;&lt; &quot;&#125;|&quot;                    &lt;&lt; &quot;&#123;size|&quot; &lt;&lt; unit-&gt;size &lt;&lt; &quot;&#125;|&quot;                    &lt;&lt; &quot;&#123;block|&quot; &lt;&lt; unit-&gt;block &lt;&lt; &quot;&#125;|&quot;                    &lt;&lt; &quot;&#123;&lt;f1&gt;nextUnit|&quot; &lt;&lt; unit-&gt;nextUnit &lt;&lt; &quot;&#125;|&quot;                    &lt;&lt; &quot;&#123;&lt;f2&gt;prevUnit|&quot; &lt;&lt; unit-&gt;prevUnit &lt;&lt; &quot;&#125;&quot;                    &lt;&lt; &quot;&#125;\&quot; color=\&quot;#67c23a\&quot;];\n&quot;;                if (unit == block-&gt;freeList)                &#123;                    out &lt;&lt; &quot;subgraph cluster_&quot; &lt;&lt; unit &lt;&lt; &quot; &#123;\n&quot;                        &lt;&lt; &quot;label=\&quot;freeList\&quot;;\n&quot;;                    out &lt;&lt; &quot;\&quot;&quot; &lt;&lt; block &lt;&lt; &quot;\&quot;:f1 -&gt; \&quot;&quot; &lt;&lt; unit &lt;&lt; &quot;\&quot;:f0 [style=\&quot;dashed\&quot; color=\&quot;#0000ff\&quot;];\n&quot;;                &#125;                else                    out &lt;&lt; &quot;\&quot;&quot; &lt;&lt; unit-&gt;nextUnit &lt;&lt; &quot;\&quot;:f1 -&gt; \&quot;&quot; &lt;&lt; unit &lt;&lt; &quot;\&quot;:f0 [style=\&quot;dashed\&quot; color=\&quot;#0000ff\&quot;];\n&quot;;                unit = unit-&gt;nextUnit;            &#125; while (unit != block-&gt;freeList);            out &lt;&lt; &quot;&#125;\n&quot;;            if (block == m_blocks)                out &lt;&lt; &quot;\&quot;&quot; &lt;&lt; this &lt;&lt; &quot;\&quot;:f1 -&gt; \&quot;&quot; &lt;&lt; block &lt;&lt; &quot;\&quot;:f0 [color=\&quot;#0000ff\&quot;];\n&quot;;            else                out &lt;&lt; &quot;\&quot;&quot; &lt;&lt; block-&gt;nextBlock &lt;&lt; &quot;\&quot;:f3 -&gt; \&quot;&quot; &lt;&lt; block &lt;&lt; &quot;\&quot;:f0 [color=\&quot;#0000ff\&quot;];\n&quot;;            block = block-&gt;nextBlock;        &#125; while (block != m_blocks);        out &lt;&lt; &quot;&#125;&quot;;        out.close();    &#125;&#125;;MemoryPoolX g_memoryPool(1 * 1024 * 1024 * 1024);void dumpGraphviz()&#123;    std::vector&lt;void *&gt; datas;    for (size_t i = 0; i &lt; 6; i++)        datas.push_back(g_memoryPool.alloc(i * 1024));    datas.push_back(g_memoryPool.alloc(8 * 1024 * 1024));    datas.push_back(g_memoryPool.alloc(8 * 1024 * 1024));    g_memoryPool.dumpGraphviz();    std::cout &lt;&lt; &quot;dump01&quot; &lt;&lt; std::endl;    getchar();    g_memoryPool.free(datas[2]);    g_memoryPool.dumpGraphviz();    std::cout &lt;&lt; &quot;dump02&quot; &lt;&lt; std::endl;    getchar();    g_memoryPool.free(datas[3]);    g_memoryPool.dumpGraphviz();    std::cout &lt;&lt; &quot;dump03&quot; &lt;&lt; std::endl;    getchar();&#125;</code></pre><p>然后在<code>main</code>函数中调用<code>dumpGraphviz</code>就好了，直接看结果(若看不清可对着图片右键，然后选择<code>在新标签页中打开图片</code>)</p><p>申请完内存后的内存布局情况，其中红色为已使用的，绿色为空闲的</p><p><img src="/images/1650222099.jpeg" alt="graphvizDump01"></p><p>释放大小为<code>2048</code>的这个内存单元后的内存布局情况</p><p><img src="/images/1650222100.jpeg" alt="graphvizDump02"></p><p>可以看到第一个内存块的空闲内存单元链表中多出了一个大小为<code>2048</code>的空闲内存单元，因为其与大小为<code>4178648</code>的空闲内存单元并不临近，所以并没有进行内存单元(碎片)的合并。</p><p>释放大小为<code>3072</code>的这个内存单元后的内存布局情况</p><p><img src="/images/1650222101.jpeg" alt="graphvizDump03"></p><p>在释放大小为<code>3072</code>的内存单元的同时检测到其与大小为<code>2048</code>的空闲内存单元为临近内存单元，所以会进行碎片的合并。<br>为什么会生成一个大小为<code>5160</code>的空闲内存单元而不是大小为<code>5120</code>的单元是因为合并成一个时需要丢弃被合并的内存单元的头部信息，而头部信息占用的内存大小为<code>40</code>字节，因此合并后就是<code>5160</code>字节。其他单元依此类推。</p><p>到这里，内存池的内容基本就讲完了，接下来我们来看看垃圾回收机制。</p><h2 id="Garbage-Collection"><a href="#Garbage-Collection" class="headerlink" title="Garbage Collection"></a>Garbage Collection</h2><p><strong>注意：</strong><code>这里所说的标记使用的是引用计数的方式来模拟，真正的GC中不应出现引用计数这种东西。</code></p><p>其实个人觉得在C++中使用GC的意义不大，虽然会更方便一点，但是使用智能指针与作用域限定进行自动内存管理其实也差不多，所以GC这里的内容就算是写着玩的了。</p><p>想要在C++中实现GC，我们要做的第一件事情是要对<code>raw pointer</code>进行封装，因为如果使用的是<code>raw pointer</code>的话，我们无法对数据的引用进行更新，也无法跟踪指针的使用。例如：GC运行后仍有未知代码对被GC的指针(<code>raw pointer</code>)进行访问，造成程序的崩溃。</p><h3 id="原始指针的封装"><a href="#原始指针的封装" class="headerlink" title="原始指针的封装"></a>原始指针的封装</h3><p>我们这里使用引用计数的方式来跟踪指针，上代码。</p><p>先给内存单元添加三个属性</p><pre><code>// 内存单元struct MemoryUnit&#123;    uint8_t *data;        // 内存单元的数据地址    size_t size;          // 内存的数据大小    size_t refIndex;      // 内存单元引用表的对应的索引(用于内存整理算法更新引用)    size_t refCount;      // 内存单元引用计数(用于内存标记算法)    size_t aliveCount;    // 内存单元的GC存活计数(用于分代理论)    MemoryBlock *block;   // 内存单元所属的内存块    MemoryUnit *nextUnit; // 下一个内存单元    MemoryUnit *prevUnit; // 上一个内存单元&#125;;</code></pre><p>然后给<code>MemoryPool</code>添加一个成员<code>std::unordered_map&lt;size_t, unit_t *&gt; m_refUnits</code>，用来记录用于整理算法的指针引用。并添加一个<code>[]</code>运算符的重载</p><pre><code>unit_t *operator[](size_t index)&#123;    return m_refUnits[index];&#125;</code></pre><p>方便对于内存单元的访问。</p><p>原始指针的封装类</p><pre><code>class GCMemory&#123;public:    friend MemoryPool;public:    GCMemory(MemoryPool *pool, size_t unitIndex)        : m_pool(pool),          m_unitIndex(unitIndex)    &#123;        (*m_pool)[m_unitIndex]-&gt;refCount++;    &#125;    GCMemory()        : m_pool(nullptr),          m_unitIndex(0)    &#123;    &#125;    ~GCMemory()    &#123;        if (nullptr == m_pool)            return;        auto unit = (*m_pool)[m_unitIndex];        if (nullptr != unit)            unit-&gt;refCount--;    &#125;    GCMemory(GCMemory &amp;other)        : m_pool(other.m_pool)    &#123;        (*m_pool)[m_unitIndex]-&gt;refCount++;    &#125;    GCMemory(GCMemory &amp;&amp;other)        : m_pool(other.m_pool)    &#123;        other.m_pool = nullptr;    &#125;    GCMemory &amp;operator=(GCMemory &amp;other)    &#123;        m_pool = other.m_pool;        (*m_pool)[m_unitIndex]-&gt;refCount++;        return *this;    &#125;    GCMemory &amp;operator=(GCMemory &amp;&amp;other)    &#123;        m_pool = other.m_pool;        other.m_pool = nullptr;        return *this;    &#125;    GCMemory &amp;operator++()    &#123;        (*m_pool)[m_unitIndex]-&gt;refCount++;        return *this;    &#125;    GCMemory &amp;operator--()    &#123;        auto unit = (*m_pool)[m_unitIndex];        if (unit-&gt;refCount &gt; 0)            unit-&gt;refCount--;        return *this;    &#125;    operator bool() const    &#123;        auto unit = (*m_pool)[m_unitIndex];        return nullptr != m_pool &amp;&amp; nullptr != unit &amp;&amp; unit-&gt;refCount &gt; 0;    &#125;    operator void *() const noexcept    &#123;        auto unit = (*m_pool)[m_unitIndex];        return nullptr == unit ? nullptr : unit-&gt;data;    &#125;    operator uint8_t *() const noexcept    &#123;        auto unit = (*m_pool)[m_unitIndex];        return nullptr == unit ? nullptr : unit-&gt;data;    &#125;private:    MemoryPool *m_pool;    size_t m_unitIndex;&#125;;using gc_t = GCMemory;</code></pre><p>对于<code>MemoryPool::allocGC</code>方法的实现</p><pre><code>MemoryPool::gc_t MemoryPool::allocGC(size_t size)&#123;    if (0 == size)        return &#123;&#125;;    if (nullptr == m_blocks)        m_blocks = allocBlock(size);    auto unit = allocUnit(size);    if (nullptr == unit)    &#123;        if (size + m_poolSize &gt; m_poolMaxSize)            throw std::bad_alloc();        auto block = allocBlock(size);        if (nullptr == block)            return &#123;&#125;;        unit = allocUnit(size);        if (nullptr == unit)            return &#123;&#125;;    &#125;    static size_t unitIndex = 0;    m_refUnits[unitIndex] = unit;    unit-&gt;refIndex = unitIndex++;    unit-&gt;refCount = 0;    unit-&gt;aliveCount = 0;    return gc_t(this, unit-&gt;refIndex);&#125;</code></pre><p>那么来稍微测试一下</p><p><img src="/images/1650222102.jpeg" alt="作用域测试01"></p><p><img src="/images/1650222103.jpeg" alt="作用域测试01"></p><p>可以看到，在刚申请完的时候引用计数为<code>1</code>，并在走出作用域后变为了<code>0</code>。</p><h3 id="内存标记算法"><a href="#内存标记算法" class="headerlink" title="内存标记算法"></a>内存标记算法</h3><pre><code>void MemoryPool::markedGC()&#123;    for (auto &amp;unit : m_refUnits)    &#123;        if (0 != unit.second-&gt;refCount)            continue;        freeUnit(unit.second);        unit.second = nullptr;    &#125;&#125;</code></pre><p>这个其实没什么好说的，当发生GC的时候检查内存单元的引用计数，若为<code>0</code>则表示没有使用，进行内存的回收。</p><p>看一下效果</p><p><img src="/images/1650222104.jpeg" alt="内存标记算法结果"></p><p>在这里我们手动将<code>data02</code>的引用计数<code>-1</code>来模拟无引用的情况。</p><p>可以看到，在执行GC之后引用计数为<code>0</code>的<code>data02</code>的引用指针变成了<code>nullptr</code>，说明GC运行成功。正常情况下只论标记回收算法的话内存池会产生大量的内存碎片，但我们这里在释放的时候会自动进行临近碎片的合并，所以情况其实还好。</p><p>看一下内存结构变化的<code>Graphviz</code>图，对应代码中两处<code>g_memoryPool.dumpGraphviz()</code>的调用。</p><table><thead><tr><th><img src="/images/1650222105.jpeg" alt="内存标记算法内存结构变化01"></th><th><img src="/images/1650222106.jpeg" alt="内存标记算法内存结构变化02"></th></tr></thead></table><p><strong>注意：</strong><code>对于后面将要说的两种算法来说，当前的内存池模型属于冗余设计。实际设计时因为存在整理算法，所以freeList、usedList这些都可以不要，直接使用一个成员标记最后申请的位置即可。在下次进入申请内存时仅需判断当前块是否有足够的空闲内存，如果没有则动态扩容，否则可直接返回最后申请的位置，在这种情况下算法的时间复杂度仅为O(1)</code></p><h3 id="内存标记整理算法"><a href="#内存标记整理算法" class="headerlink" title="内存标记整理算法"></a>内存标记整理算法</h3><p>在实现整理算法之前还需要两个特别重要的方法需要实现，分别是<code>suspendTheWorld</code>与<code>resumeTheWorld</code>。</p><p>在我们进行内存整理之前需要先对当前进程的除当前线程外的所有线程进行暂停，因为在我们进行整理的过程中不允许出现被整理内存被其他线程访问的情况，否则可能会导致出现数据错误甚至崩溃等问题。</p><p>上代码</p><pre><code>std::vector&lt;HANDLE&gt; MemoryPool::suspendTheWorld()&#123;    std::vector&lt;HANDLE&gt; threadHandles;    auto currentProcessId = ::GetCurrentProcessId();    auto currentThreadId = ::GetCurrentThreadId();    auto snapshotHandle = ::CreateToolhelp32Snapshot(TH32CS_SNAPTHREAD, 0);    if (nullptr != snapshotHandle)    &#123;        THREADENTRY32 threadEntry&#123;&#125;;        threadEntry.dwSize = sizeof(threadEntry);        if (!::Thread32First(snapshotHandle, &amp;threadEntry))            return threadHandles;        do        &#123;            if (currentProcessId != threadEntry.th32OwnerProcessID || currentThreadId == threadEntry.th32ThreadID)                continue;            auto handle = ::OpenThread(THREAD_ALL_ACCESS, false, threadEntry.th32ThreadID);            if (nullptr == handle)                throw std::exception(&quot;OpenThread failed&quot;);            if (-1 == ::SuspendThread(handle))                throw std::exception(&quot;SuspendThread failed&quot;);            threadHandles.push_back(handle);        &#125; while (::Thread32Next(snapshotHandle, &amp;threadEntry));        ::CloseHandle(snapshotHandle);    &#125;    return threadHandles;&#125;void MemoryPool::resumeTheWorld(std::vector&lt;HANDLE&gt; &amp;handles)&#123;    for (auto &amp;handle : handles)    &#123;        if (-1 == ::ResumeThread(handle))            throw std::exception(&quot;ResumeThread failed&quot;);        ::CloseHandle(handle);    &#125;&#125;</code></pre><p>这两个方法实现之后再来实现内存标记整理算法</p><pre><code>void MemoryPool::markedTidyingGC()&#123;    std::set&lt;unit_t *&gt; aliveUnits;    std::vector&lt;unit_t *&gt; deadUnits;    auto threadHandles = suspendTheWorld(); // 砸瓦鲁多    auto block = m_blocks;    do    &#123;        aliveUnits.clear();        deadUnits.clear();        auto unit = block-&gt;usedList;        do        &#123;            if (0 != unit-&gt;refCount)                aliveUnits.insert(unit);            else                deadUnits.push_back(unit);            unit = unit-&gt;nextUnit;        &#125; while (unit != block-&gt;usedList);        // check if alive units is empty        if (aliveUnits.empty())        &#123;            // free all dead units            for (auto &amp;unit : deadUnits)            &#123;                m_refUnits[unit-&gt;refIndex] = nullptr;                freeUnit(unit);            &#125;        &#125;        else        &#123;            // update dead unit reference            for (const auto &amp;unit : deadUnits)                m_refUnits[unit-&gt;refIndex] = nullptr;            // move alive units to the front of the block            auto unitMoveToPosition = reinterpret_cast&lt;unit_t *&gt;(block-&gt;data);            size_t usedTotalSize = 0;            for (auto &amp;unit : aliveUnits)            &#123;                memcpy(unitMoveToPosition, unit, sizeof(unit_t) + unit-&gt;size);                unitMoveToPosition-&gt;data = reinterpret_cast&lt;uint8_t *&gt;(unitMoveToPosition) + sizeof(unit_t);                if (0 == usedTotalSize)                &#123;                    block-&gt;usedList = unitMoveToPosition;                    unitMoveToPosition-&gt;nextUnit = unitMoveToPosition;                    unitMoveToPosition-&gt;prevUnit = unitMoveToPosition;                &#125;                else                &#123;                    block-&gt;usedList-&gt;prevUnit-&gt;nextUnit = unitMoveToPosition;                    unitMoveToPosition-&gt;prevUnit = block-&gt;usedList-&gt;prevUnit;                    unitMoveToPosition-&gt;nextUnit = block-&gt;usedList;                    block-&gt;usedList-&gt;prevUnit = unitMoveToPosition;                &#125;                usedTotalSize += unitMoveToPosition-&gt;size + sizeof(unit_t);                unitMoveToPosition = reinterpret_cast&lt;unit_t *&gt;(unitMoveToPosition-&gt;data + unitMoveToPosition-&gt;size);            &#125;            // reset free unit list            block-&gt;freeTotal = block-&gt;size - usedTotalSize - sizeof(unit_t);            block-&gt;freeList = reinterpret_cast&lt;unit_t *&gt;(block-&gt;data + usedTotalSize);            block-&gt;freeList-&gt;data = reinterpret_cast&lt;uint8_t *&gt;(block-&gt;freeList) + sizeof(unit_t);            block-&gt;freeList-&gt;block = block;            block-&gt;freeList-&gt;size = block-&gt;freeTotal;            block-&gt;freeList-&gt;nextUnit = block-&gt;freeList;            block-&gt;freeList-&gt;prevUnit = block-&gt;freeList;            // update used unit reference            unit = block-&gt;usedList;            do            &#123;                m_refUnits[unit-&gt;refIndex] = unit;                unit = unit-&gt;nextUnit;            &#125; while (unit != block-&gt;usedList);        &#125;        block = block-&gt;nextBlock;    &#125; while (block != m_blocks);    resumeTheWorld(threadHandles); // 使用相同类型的替身&#125;</code></pre><p>可以看到整个整理的过程就是先暂停世界，然后记录在此次GC中仙去与存活的内存单元。</p><p>如果此次GC没有存活的内存单元则直接直接进行内存单元的释放，否则先进行仙去内存单元的指针引用更新，使其变为<code>nullptr</code>，接下来对存活内存单元进行数据移动，将整个内存单元移动至前一个内存单元的后面，使其紧密贴合，如果是第一个移动的话则移动的目标地址是当前内存块的数据地址。</p><p>你问我会不会后面的数据把前面的单元给覆盖了？自然是不会，这是为什么使用<code>std::set</code>而不是<code>std::vector、std::unordered_set</code>等容器来存放存活内存单元地址的原因，因为<code>std::set</code>会自动给我们进行排序，而只要我们保证存活内存单元的移动是顺序的，就不会发生数据覆盖的情况。<br><strong>小提示：</strong><code>std::set基于红黑树实现，如果不需要排序的功能可使用std::unordered_set，std::unordered_set的实现基于哈希表，在性能上可直接吊打</code></p><p>在移动完所有存活的内存单元之后我们需要更新空闲内存空间的信息，因为我们已将使用的内存单元移动到内存块首部，所以剩下的都是可使用的空闲内存，直接分配一个大块空闲内存单元就好了。</p><p>最后我们需要更新已使用的内存单元的指针引用信息并取消整个世界的暂停即可。</p><p>看效果</p><p><img src="/images/1650222107.jpeg" alt="内存标记整理算法结果"></p><p>运行过程内存结构变化的<code>Graphviz</code>图</p><table><thead><tr><th><img src="/images/1650222108.jpeg" alt="内存标记整理算法内存结构变化01"></th><th><img src="/images/1650222109.jpeg" alt="内存标记整理算法内存结构变化02"></th></tr></thead></table><p>可以看到<code>data02</code>被释放后原本使用的地址被<code>data03</code>拿去用了，说明移动整理成功。</p><h3 id="内存分代标记整理算法"><a href="#内存分代标记整理算法" class="headerlink" title="内存分代标记整理算法"></a>内存分代标记整理算法</h3><p><strong>提示：</strong><code>因当前内存池结构不太好实现分代，所以接下来会另外申请一块内存来当作老年代</code></p><p>代码</p><pre><code>void MemoryPool::generationalMarkedTidyingGC()&#123;    static unit_t *elderUnitList = reinterpret_cast&lt;unit_t *&gt;(::VirtualAlloc(nullptr, 32 * 1024 * 1024, MEM_RESERVE | MEM_COMMIT, PAGE_READWRITE));    static size_t elderUnitListIndex = 0;    if (nullptr == elderUnitList)        throw std::exception(&quot;Emulate elder block failed&quot;);    std::set&lt;unit_t *&gt; elderUnits;    std::set&lt;unit_t *&gt; aliveUnits;    std::vector&lt;unit_t *&gt; deadUnits;    auto threadHandles = suspendTheWorld(); // 砸瓦鲁多    auto block = m_blocks;    do    &#123;        if (nullptr == block-&gt;usedList)        &#123;            block = block-&gt;nextBlock;            continue;        &#125;        elderUnits.clear();        aliveUnits.clear();        deadUnits.clear();        auto unit = block-&gt;usedList;        do        &#123;            if (0 != unit-&gt;refCount)            &#123;                if (4 &lt;= ++unit-&gt;aliveCount)                    elderUnits.insert(unit);                else                    aliveUnits.insert(unit);            &#125;            else                deadUnits.push_back(unit);            unit = unit-&gt;nextUnit;        &#125; while (unit != block-&gt;usedList);        // check if alive units and elder units is empty        if (aliveUnits.empty() &amp;&amp; elderUnits.empty())        &#123;            // free all dead units            for (auto &amp;unit : deadUnits)            &#123;                m_refUnits[unit-&gt;refIndex] = nullptr;                freeUnit(unit);            &#125;        &#125;        else        &#123;            // update dead unit reference            for (const auto &amp;unit : deadUnits)                m_refUnits[unit-&gt;refIndex] = nullptr;            // move elder units to the front of the elder block            for (auto &amp;unit : elderUnits)            &#123;                memcpy(elderUnitList + elderUnitListIndex, unit, sizeof(unit_t) + unit-&gt;size);                auto elderUnit = reinterpret_cast&lt;unit_t *&gt;(elderUnitList + elderUnitListIndex);                elderUnit-&gt;data = reinterpret_cast&lt;uint8_t *&gt;(elderUnit) + sizeof(unit_t);                elderUnit-&gt;block = nullptr;                if (0 == elderUnitListIndex)                &#123;                    elderUnit-&gt;nextUnit = elderUnit;                    elderUnit-&gt;prevUnit = elderUnit;                &#125;                else                &#123;                    elderUnitList-&gt;prevUnit-&gt;nextUnit = elderUnit;                    elderUnit-&gt;prevUnit = elderUnitList-&gt;prevUnit;                    elderUnit-&gt;nextUnit = elderUnitList;                    elderUnitList-&gt;prevUnit = elderUnit;                &#125;                // update elder unit reference                m_refUnits[elderUnit-&gt;refIndex] = elderUnit;                elderUnitListIndex += sizeof(unit_t) + elderUnit-&gt;size;            &#125;            // move alive units to the front of the block            auto unitMoveToPosition = reinterpret_cast&lt;unit_t *&gt;(block-&gt;data);            size_t usedTotalSize = 0;            if (0 == aliveUnits.size())                block-&gt;usedList = nullptr;            for (auto &amp;unit : aliveUnits)            &#123;                memcpy(unitMoveToPosition, unit, sizeof(unit_t) + unit-&gt;size);                unitMoveToPosition-&gt;data = reinterpret_cast&lt;uint8_t *&gt;(unitMoveToPosition) + sizeof(unit_t);                if (0 == usedTotalSize)                &#123;                    block-&gt;usedList = unitMoveToPosition;                    unitMoveToPosition-&gt;nextUnit = unitMoveToPosition;                    unitMoveToPosition-&gt;prevUnit = unitMoveToPosition;                &#125;                else                &#123;                    block-&gt;usedList-&gt;prevUnit-&gt;nextUnit = unitMoveToPosition;                    unitMoveToPosition-&gt;prevUnit = block-&gt;usedList-&gt;prevUnit;                    unitMoveToPosition-&gt;nextUnit = block-&gt;usedList;                    block-&gt;usedList-&gt;prevUnit = unitMoveToPosition;                &#125;                usedTotalSize += unitMoveToPosition-&gt;size + sizeof(unit_t);                unitMoveToPosition = reinterpret_cast&lt;unit_t *&gt;(unitMoveToPosition-&gt;data + unitMoveToPosition-&gt;size);            &#125;            // reset free unit list            block-&gt;freeTotal = block-&gt;size - usedTotalSize - sizeof(unit_t);            block-&gt;freeList = reinterpret_cast&lt;unit_t *&gt;(block-&gt;data + usedTotalSize);            block-&gt;freeList-&gt;data = reinterpret_cast&lt;uint8_t *&gt;(block-&gt;freeList) + sizeof(unit_t);            block-&gt;freeList-&gt;block = block;            block-&gt;freeList-&gt;size = block-&gt;freeTotal;            block-&gt;freeList-&gt;nextUnit = block-&gt;freeList;            block-&gt;freeList-&gt;prevUnit = block-&gt;freeList;            // update used unit reference            if (nullptr != block-&gt;usedList)            &#123;                unit = block-&gt;usedList;                do                &#123;                    m_refUnits[unit-&gt;refIndex] = unit;                    unit = unit-&gt;nextUnit;                &#125; while (unit != block-&gt;usedList);            &#125;        &#125;        block = block-&gt;nextBlock;    &#125; while (block != m_blocks);    resumeTheWorld(threadHandles); // 使用相同类型的替身&#125;</code></pre><p>其中<code>elderUnitList</code>就是我们用来模拟老年代的另外申请的内存块。</p><p>另外在内存标记整理算法的基础上加了个判断，当内存单元的GC存活次数<code>&gt;= 4</code>的时候，我们就把它移动到老年代的内存块上，并更新内存单元的指针引用。</p><p>当在所有的已使用内存单元都成为老年代的情况下，我们还需要将当前内存块的已使用内存单元链表设置为<code>nullptr</code>。</p><p>这里分代的基本思路就是将内存分为新生代与老年代，其中新生代就是我们当前的内存池，老年代就是另外申请的那一块大小<code>32MB</code>的内存。发生GC时我们只对新生代做操作，而进入老年代的内存单元基本移动到老年代的内存块上之后就放手不管了，并且设定进入老年代的条件是内存单元能活过<code>4</code>次GC的调用（GC的调用基本只会发生在内存池无法再申请内存的情况下，除非手动调用）。</p><p>写段代码来看看效果</p><p><img src="/images/1650222110.jpeg" alt="内存分代标记整理算法结果"></p><p>可以看到第一次GC之后进行了一次内存整理，并回收了引用计数为<code>0</code>的<code>data02</code>。接下来再进行4次GC，但真正执行的其实只有3次，第4次进去后因为判断到内存块的<code>usedList</code>为<code>nullptr</code>，所以就直接进行了返回。这表明前3次已经将存活次数<code>&gt;= 4</code>的<code>test01</code>与<code>test03</code>两个对应的内存单元移动到了老年代内存块上了。</p><p>来看一下内存结构变化的<code>Graphviz</code>图</p><table><thead><tr><th><img src="/images/1650222111.jpeg" alt="内存分代标记整理算法内存结构变化01"></th><th><img src="/images/1650222112.jpeg" alt="内存分代标记整理算法内存结构变化02"></th><th><img src="/images/1650222113.jpeg" alt="内存分代标记整理算法内存结构变化03"></th></tr></thead></table><p>可以看到运行到最后内存池已不存在使用中的内存单元，所有的内存均已归还，而被使用了的内存单元则被转移到了老年代内存块之上，那么来看一下老年代内存块的<code>Graphviz</code>图</p><p><img src="/images/1650222114.jpeg" alt="老年代内存块结构"></p><p>这两个内存单元就是我们的<code>test01</code>与<code>test03</code>，移动正确。</p><h2 id="GC前后的操作"><a href="#GC前后的操作" class="headerlink" title="GC前后的操作"></a>GC前后的操作</h2><p>在没有必要的时候我们要尽量避免GC的调用，可在仅当内存池超过限定最大可向系统申请的内存大小时才启动GC进行垃圾回收，并且避免手动的去调用GC。</p><p>在GC后若仍无法分配内存则抛出异常<code>std::bad_alloc</code>。</p><p>以上说的两个操作只需要在运行时做一些判断即可，在这里就不实现了，那么到这里我们所要探讨的几种垃圾回收机制就整完了，接下来我们回到GC之前。</p><h2 id="C-使用特化"><a href="#C-使用特化" class="headerlink" title="C++使用特化"></a>C++使用特化</h2><p>为了方便使用，来实现两个简单的包装函数。</p><pre><code>template &lt;typename class_t&gt;class_t &amp;object() requires std::is_pod_v&lt;class_t&gt;&#123;    return *reinterpret_cast&lt;class_t *&gt;(alloc(sizeof(class_t)));&#125;template &lt;typename class_t, typename... params_t&gt;class_t &amp;object(params_t &amp;&amp;...params)&#123;    class_t *placement = (class_t *)alloc(sizeof(class_t));    if (nullptr == placement)        throw std::bad_alloc();    new (placement) class_t(std::forward&lt;params_t&gt;(params)...);    return *placement;&#125;</code></pre><p>然后测试一下</p><table><thead><tr><th><img src="/images/1650222115.jpeg" alt="结构"></th><th><img src="/images/1650222116.jpeg" alt="测试"></th></tr></thead></table><p>然后我这里不需要容器的支持（主要是懒得实现<code>std::allocator</code>），直接对其禁用。</p><p>先在外部声明一个<code>concept</code></p><pre><code>template &lt;typename any_t&gt;concept is_container = requires(any_t any)&#123;    &#123;any.size()&#125;;    &#123;any.begin()&#125;;    &#123;any.end()&#125;;&#125;;</code></pre><p>然后再实现函数</p><pre><code>template &lt;typename class_t, typename... params_t&gt;class_t &amp;object(params_t &amp;&amp;...params) requires is_container&lt;class_t&gt;&#123;    static_assert(false, &quot;Unsupported type of container.&quot;);    return &#123;&#125;;&#125;</code></pre><p>测试</p><p><img src="/images/1650222117.jpeg" alt="测试"></p><p>差不多就这样了。</p><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>想起还有一件事没做，就是在<code>allocUnit</code>的时候需要对齐<code>sizeof(void*)</code>，不过在这里就不再实现了，鸭蛋莫鸭蛋。</p><p>那就这样了，有缘再见~</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>[逆向] 记录小黑盒签名算法的逆向过程</title>
      <link href="/2022/04/18/%E9%80%86%E5%90%91-%E8%AE%B0%E5%BD%95%E5%B0%8F%E9%BB%91%E7%9B%92%E7%AD%BE%E5%90%8D%E7%AE%97%E6%B3%95%E7%9A%84%E9%80%86%E5%90%91%E8%BF%87%E7%A8%8B/"/>
      <url>/2022/04/18/%E9%80%86%E5%90%91-%E8%AE%B0%E5%BD%95%E5%B0%8F%E9%BB%91%E7%9B%92%E7%AD%BE%E5%90%8D%E7%AE%97%E6%B3%95%E7%9A%84%E9%80%86%E5%90%91%E8%BF%87%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<p>白嫖的动力是无限的。</p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本文仅供学习探讨之用，如果侵犯了您的权益请联系我删除。</p><h2 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h2><ol><li><a href="https://www.telerik.com/fiddler" title="Fiddler Official">Fiddler</a></li><li><a href="https://github.com/skylot/jadx" title="JADX Official">JADX</a></li><li><a href="https://hex-rays.com/" title="IDA Official">IDA</a></li><li><a href="https://github.com/frida/frida" title="Frida Official">Frida</a></li></ol><h2 id="抓包"><a href="#抓包" class="headerlink" title="抓包"></a>抓包</h2><p><img src="/images/1650222076.jpg" alt="签到包内容"></p><h2 id="重放测试"><a href="#重放测试" class="headerlink" title="重放测试"></a>重放测试</h2><p>使用<code>Shift + R</code>进行一个包的重放。</p><p><img src="/images/1650222077.jpg" alt="重放测试结果"></p><p>好家伙，那么改一下<code>_time</code>参数试试。</p><p><img src="/images/1650222078.jpg" alt="重放测试结果"></p><p>嗯，看来有签名校验，经过测试后确定是<code>hkey</code>这个参数。</p><h2 id="JADX"><a href="#JADX" class="headerlink" title="JADX"></a>JADX</h2><p>打开<code>jadx</code>并把下载好的<code>.apk</code>文件拖入软件中，等待分析完成。分析完成之后直接打开搜索窗口，输入关键字<code>hkey</code>进行搜索。</p><p><img src="/images/1650222079.jpg" alt="搜索结果"></p><p>发现没有可疑的类，那就用请求路径搜索试试。</p><p><img src="/images/1650222080.jpg" alt="搜索结果"></p><p>嗯，找到目标了，但发现这是一个接口，没有直接进行定义。那么就按下<code>x</code>键跟踪到引用那边。  </p><p><img src="/images/1650222081.jpg" alt="跟踪结果"></p><p>到了这里之后基本就没事，继续往下跟就行，过程省略…</p><p><img src="/images/1650222082.jpg" alt="最终结果"></p><p>最终到了这么一个地方，其中<code>NDKTools.encode</code>就是生成<code>hkey</code>的函数。但是在这里并没有看到<code>hkey</code>这个字段，经过了一番检查之后发现是这么生成的。  </p><pre><code>name = &quot;hey&quot;.replace(&quot;e&quot;, &quot;ke&quot;)</code></pre><p>好，那就没问题了，再来看<code>NDKTools.encode</code>函数，发现其进入了<code>so</code>中。好家伙，那这层就算完了。</p><h2 id="IDA"><a href="#IDA" class="headerlink" title="IDA"></a>IDA</h2><p>找函数的那些过程就省略了，这里直接上伪代码分析结果。</p><pre><code>v11 = (unsigned __int8 *)((__int64 (__fastcall *)(JNIEnv *, __int64, _QWORD))(*v10)-&gt;GetStringUTFChars)(v10, v9, 0LL);// 请求的API路径v12 = ((__int64 (__fastcall *)(JNIEnv *, __int64, _QWORD))(*v10)-&gt;GetStringUTFChars)(v10, v8, 0LL);// 当前时间(1649327297)v13 = (unsigned __int8 *)((__int64 (__fastcall *)(JNIEnv *, __int64, _QWORD))(*v10)-&gt;GetStringUTFChars)(v10, v7, 0LL);// 随机生成的字符串([\da-zA-Z]&#123;32,32&#125;)result = 0LL;// 判断3个参数是否为空if ( v11 &amp;&amp; v12 &amp;&amp; v13 )&#123;    // 参数不为空    v93 = 22872;    v91 = xmmword_3E60;    v92 = 6293310241825115725LL;    v95 = 0;    v15 = strlen(v13);    if ( v15 &lt; 1 )                              // 判断随机字符串长度是否小于1    &#123;    v16 = 0;    &#125;    else    &#123;    // 随机字符串大于1    v16 = 0;                                  // 计数随机字符串中出现0-9的次数    v17 = (unsigned int)v15;                  // 随机字符串的长度    v18 = v94;    do    &#123;        v20 = *v13++;        v19 = v20;        v21 = v20 - 97;        v22 = v20 - 32;        if ( (unsigned int)(v20 - 48) &lt; 0xA )        ++v16;        if ( v21 &lt; 0x1A )        v19 = v22;        --v17;        *v18++ = v19;    &#125;    while ( v17 );    &#125;    v36 = atoi(v12);                            // 当前时间(整型)    dword_6110 = ((unsigned int)(v36 + v16) &gt;&gt; 16) &amp; 0xFF;    dword_6114 = (unsigned __int16)(v36 + v16) &gt;&gt; 8;    v90 = v36 + v16;    v86 = 0;                                    // 存储包含当前时间的向量    v84 = 0u;    v85 = 0u;    v82 = 0u;    v83 = 0u;    v80 = 0u;    v81 = 0u;    v78 = 0u;    v79 = 0u;    v76 = 0u;    v77 = 0u;    v74 = 0u;    v75 = 0u;    v72 = 0u;    v73 = 0u;    dword_6118 = (unsigned int)(v36 + v16) &gt;&gt; 24;    dword_611C = (v36 + v16) &amp; 0xFF;    v87 = (unsigned int)(v36 + v16) &gt;&gt; 24;      // 往向量中存储当前时间以供稍后sub_2BF0函数进行计算，时间是转换成大端存储的时间    v88 = (unsigned int)(v36 + v16) &gt;&gt; 16;    v89 = (unsigned __int16)(v36 + v16) &gt;&gt; 8;    v70 = 0u;    v71 = 0u;    v37 = strlen(v11);    v38 = (unsigned __int8 *)malloc(2                                * (unsigned int)((unsigned __int64)(v37 + 2) * (unsigned __int128)0xAAAAAAAAAAAAAAABLL &gt;&gt; 64) &amp; 0xFFFFFFFC | 1LL);    v39 = strlen(v11);    sub_29F8(v11, v39, v38);                // 将请求的API路径进行Base64编码    v40 = strlen(v38);    sub_2BF0((unsigned __int8 *)&amp;v70, v38, (__int64)&amp;v86, v40, 8LL);// 计算Base64编码后的请求的API路径与时间的哈希值，20字节    v41 = *(_DWORD *)((unsigned __int64)&amp;v70 &amp; 0xFFFFFFFFFFFFFFF0LL | BYTE3(v71) &amp; 0xF);    dword_6124 = BYTE3(v71);    dword_6108 = BYTE3(v71) &amp; 0xF;    dword_610C = v41;    v42 = bswap32(v41);    v43 = v42 &amp; 0x7FFFFFFF;    dword_6104 = (v42 &amp; 0x7FFFFFFF) / 0x271F35A0;    v67 = 15540725856023089LL;    dword_6120 = v42;    v44 = 1307386003LL * ((v42 &gt;&gt; 2) &amp; 0x1FFFFFFF);    v45 = (v42 &amp; 0x7FFFFFFF) / 0x3AuLL;    v46 = *((_BYTE *)&amp;v91 + v43 - 58 * (_DWORD)v45);    v47 = *((unsigned __int8 *)&amp;v91 + (unsigned int)v45 - 58 * (2369637129u * v45 &gt;&gt; 37));    LODWORD(v44) = *((unsigned __int8 *)&amp;v91 + (v44 &gt;&gt; 40) - 58 * (unsigned int)(2369637129u * (v44 &gt;&gt; 40) &gt;&gt; 37));    v48 = *((unsigned __int8 *)&amp;v91 + v43 / 0x2FA28 - 58 * (2369637129u * (v43 / 0x2FA28uLL) &gt;&gt; 37));    v49 = *((unsigned __int8 *)&amp;v91 + v43 / 0xACAD10 - 58 * (2369637129u * (v43 / 0xACAD10uLL) &gt;&gt; 37));    v69 = 0;    LOBYTE(v67) = v46;                          // HKey第一位字节    BYTE1(v67) = v47;                           // HKey第三位字节    BYTE2(v67) = v44;                           // HKey第二位字节    BYTE3(v67) = v48;                           // HKey第五位字节    BYTE4(v67) = v49;                           // HKey第四位字节    v66.n128_u64[0] = __PAIR__(v44, v47);    v66.n128_u64[1] = __PAIR__(v49, v48);    v68 = 0;    sub_23FC((int *)&amp;v66);                      // 计算最后两位校验码数据    v50 = vaddvq_s32(v66);    v51 = v50        - 100        * (((unsigned __int64)(1374389535LL * v50) &gt;&gt; 63)        + ((signed int)((unsigned __int64)(1374389535LL * v50) &gt;&gt; 32) &gt;&gt; 5));    sub_25F4((__int64)&amp;v68, v52, v53, (unsigned int)v51, v54, v55, v56, v57, v66.n128_i64[0]);    v58 = v68;    if ( v51 &gt;= 10 )    v59 = v68;    else    v59 = 48;    if ( v51 &gt;= 10 )    v58 = HIBYTE(v68);    BYTE5(v67) = v59;                           // HKey第六位字节    BYTE6(v67) = v58;                           // HKey第七位字节</code></pre><p>我们需要关注的几个重点是</p><ol><li><code>v11 v12 v13</code>这三个变量分别代表的是什么</li><li><code>sub_29F8</code>这个函数是做什么的</li><li><code>sub_2BF0</code>这个函数是做什么的</li><li>其中<code>sub_2BF0</code>函数中又包含了一个<code>sub_2D50</code>，那么这个函数又是做什么的</li><li><code>sub_23FC</code>这个函数是做什么的</li></ol><p>通过对上下文进行比对，可以发现其实<code>v11 v12 v13</code>这三个变量其实就是在<code>Java</code>层传进来的<code>JString</code>转换成<code>CString</code>后的结果。打上注释。</p><p>再来看<code>sub_29F8</code>这个函数，进入之后发现其对着一个变量疯狂读取。</p><p><img src="/images/1650222085.jpg" alt="sub_29F8"></p><p>有啥这么好看的？来，让我康康！</p><p><img src="/images/1650222086.jpg" alt="byte_41D4"></p><p>过来之后可以看到是个字节数组，那就看看十六进制视图。</p><p><img src="/images/1650222087.jpg" alt="byte_41D4"></p><p>好，<code>base64Encode</code>没跑了，打上注释。</p><p>接下来是<code>sub_2BF0</code>，进入之后看到做了一些没看懂的操作</p><p><img src="/images/1650222088.jpg" alt="sub_2BF0"></p><p><a href="https://developer.arm.com/architectures/instruction-sets/intrinsics/#q=veorq_s8"><img src="/images/1650222089.jpg" alt="veorq_s8"></a></p><p>查了一下指令的<a href="https://developer.arm.com/architectures/instruction-sets/intrinsics/#q=veorq_s8" title="ARM SIMD指令集文档">文档</a>，原来是对一个向量进行异或操作，那就没事了，我们继续。<br>再往下之后又进行了两次函数的调用，这个函数就是<code>sub_2D50</code>。没办法，点进去看看。<br>好像没看到有什么…<br>往下滑到底看一下，这时可以看到返回值是个20字节的数组</p><p><img src="/images/1650222090.jpg" alt="result"></p><p>说到20字节的返回值能有什么呢，第一反应就是<code>sha1</code>啊。不过这里好像也没有看到有<code>initialize values</code>…<br>说到这里，我翻看了《加密与跳楼（第4版）》第6章 找<code>sha1</code>的初始参数。</p><p><img src="/images/1650222091.jpg" alt="book"><br><img src="/images/1650222096.jpg" alt="book"></p><p>嗯…确实没有，直到我把它的参数放入计算器</p><p><img src="/images/1650222092.jpg" alt="calc"></p><p>好家伙，原来是这样！打上注释。</p><p>突然想发个图：<code>TNND，给我玩阴滴是吧.jpg</code></p><p>接下来是<code>sub_23FC</code>，进入之后发现就是对我们传进去的参数进行一堆的运算，然后原路返回，那就没事了，打上注释。</p><h2 id="Frida"><a href="#Frida" class="headerlink" title="Frida"></a>Frida</h2><p>现在来<code>Hook</code>一下我们上面分析的几个函数</p><p><img src="/images/1650222093.jpg" alt="frida"></p><p><img src="/images/1650222094.jpg" alt="hookresult"></p><p><img src="/images/1650222095.jpg" alt="hookresult"></p><p>没得毛病，进入下一步</p><p><img src="/images/sticker_nice.jpg" alt="nice"></p><h2 id="计算过程"><a href="#计算过程" class="headerlink" title="计算过程"></a>计算过程</h2><p>总结一下<code>hkey</code>的计算过程大概就是这样</p><pre><code>input requestPathinput timestampinput randomStringoutput encodedRequestPath = base64Encode(requestPath)process bias = getNumberCount(randomString)output encodedTimestamp = byteSwap(timestamp + bias)alloc timestampBuffer[72]alloc requestPathBuffer[84]process memcpy(timestampBuffer, encodedRequestPath, encodedRequestPath.length)process vectorXor(timestampBuffer, &quot;6666666666666666&quot;)process memcpy(timestampBuffer + 68, encodedTimestamp, 4)output timestampSha1Result = sha1(timestampBuffer, 72)process memcpy(requestPathBuffer, encodedRequestPath, encodedRequestPath.length)process vectorXor(requestPathBuffer, &quot;\\\\\\\\\\\\\\\\&quot;)process memcpy(requestPathBuffer + 64, timestampSha1Result, 20)output requestPathSha1Result = sha1(requestPathBuffer, 84)alloc characterMapping[58] = &quot;23456789BCDFGHJKMNPQRTVWXY&quot; + randomString.toUpperCase()alloc checkSumBuffer[16]alloc hkeyBuffer[7]output indexFactor = byteSwap(requestPathSha1Result[19] &amp; 0xF) &amp; 0x7FFFFFFFprocess hkeyBuffer[0] = characterMapping[indexFactor % 0x3A]process hkeyBuffer[1] = characterMapping[indexFactor / 0x3A % 0x3A]process hkeyBuffer[2] = characterMapping[indexFactor / 0xD24 % 0x3A]process hkeyBuffer[3] = characterMapping[indexFactor / 0x2FA28 % 0x3A]process hkeyBuffer[4] = characterMapping[indexFactor / 0xACAD10 % 0x3A]process memcpy(checkSumBuffer, hkeyBuffer + 1, 4)process checkSumBuffer = calcCheckSum(checkSumBuffer) // 纯数值计算process checkSum = (vectorAdd(checkSumBuffer) % 100).toFixedWidthHexString(2)process hkeyBuffer[5] = checkSum[0]process hkeyBuffer[6] = checkSum[1]output hkey = hkeyBuffer</code></pre><p>其中<code>calcCheckSum</code>函数就是伪代码中的<code>sub_23FC</code>函数。由于函数是纯数值计算，所以直接套用就好了。</p><h2 id="代码验证"><a href="#代码验证" class="headerlink" title="代码验证"></a>代码验证</h2><p>写一份代码验证一下。</p><p><img src="/images/1650222083.jpg" alt="验证代码"></p><p><img src="/images/1650222084.jpg" alt="验证结果"></p><p>可以看到结果符合我们的预期。</p><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>其实过程中在很多地方踩了坑，调试了好几次才懂了233。<br>那就这样了，有缘再见~</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>[学习] 整理并记录一下Markdown的基本语法</title>
      <link href="/2022/04/17/%E5%AD%A6%E4%B9%A0-%E6%95%B4%E7%90%86%E5%B9%B6%E8%AE%B0%E5%BD%95%E4%B8%80%E4%B8%8BMarkdown%E7%9A%84%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/"/>
      <url>/2022/04/17/%E5%AD%A6%E4%B9%A0-%E6%95%B4%E7%90%86%E5%B9%B6%E8%AE%B0%E5%BD%95%E4%B8%80%E4%B8%8BMarkdown%E7%9A%84%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<p>Markdown 是一种轻量级标记语言，它允许人们使用易读易写的纯文本格式编写文档，Markdown文件的后缀名便是“.md”。</p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本文仅供学习探讨之用，如果侵犯了您的权益请联系我删除。</p><h2 id="普通文字"><a href="#普通文字" class="headerlink" title="普通文字"></a>普通文字</h2><p><strong>语法符号</strong>：<code>无</code></p><p>普通文字</p><hr><h2 id="标题"><a href="#标题" class="headerlink" title="标题"></a>标题</h2><p><strong>语法符号</strong>：<code># == --</code></p><!-- > # 一级标题> ## 二级标题> ### 三级标题> #### 四级标题> ##### 五级标题> ###### 六级标题>> 可选语法一级标题> ==> 可选语法二级标题> -- --><p><strong>效果</strong></p><p><img src="/images/1650196000.jpg" alt="标题" title="标题"></p><p><strong>代码</strong></p><pre><code># 一级标题## 二级标题### 三级标题#### 四级标题##### 五级标题###### 六级标题可选语法一级标题==可选语法二级标题--</code></pre><hr><h2 id="段落"><a href="#段落" class="headerlink" title="段落"></a>段落</h2><p><strong>语法符号</strong>：<code>\n\n</code></p><p><strong>效果</strong></p><p>段落文本，每段之间用空行进行分隔。</p><p>I think maybe I should use it to format all of my documents.</p><p><strong>代码</strong></p><pre><code>段落文本，每段之间用空行进行分隔。I think maybe I should use it to format all of my documents.</code></pre><hr><h2 id="换行"><a href="#换行" class="headerlink" title="换行"></a>换行</h2><p><strong>语法符号</strong>：<code>两个空格</code></p><p><strong>效果</strong></p><p>使用空格进行换行<br>这是第二行</p><p>使用<code>&lt;br&gt;</code>进行换行<br /><br>这是第二行</p><p><strong>代码</strong></p><pre><code>使用空格进行换行  这是第二行使用`&lt;br&gt;`进行换行&lt;br /&gt;这是第二行</code></pre><hr><h2 id="强调与斜体"><a href="#强调与斜体" class="headerlink" title="强调与斜体"></a>强调与斜体</h2><p><strong>语法符号</strong>：<code>*</code></p><p><strong>效果</strong></p><p><em>斜体</em><br><strong>强调</strong><br><em><strong>强调且斜体</strong></em></p><p><strong>代码</strong></p><pre><code>*斜体***强调*****强调且斜体***</code></pre><hr><h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><p><strong>语法符号</strong>：<code>&gt;</code></p><p><strong>效果</strong></p><blockquote><p>普通引用</p><p><em>引用中使用其他元素</em></p><blockquote><p>嵌套引用</p><blockquote><p>嵌套引用</p><blockquote><p>嵌套引用</p></blockquote></blockquote></blockquote><p><strong>多段落引用</strong></p></blockquote><p><strong>代码</strong></p><pre><code>&gt; 普通引用&gt;&gt; *引用中使用其他元素*&gt;&gt;&gt; 嵌套引用&gt;&gt;&gt; 嵌套引用&gt;&gt;&gt;&gt; 嵌套引用&gt;&gt; **多段落引用**</code></pre><hr><h2 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h2><p><strong>语法符号</strong>：<code>1-inf +</code></p><p><strong>效果</strong></p><ol><li>有序列表第一个元素<ol><li>有序列表嵌套</li></ol></li><li>有序列表第二个元素<ul><li>无序列表第一个元素<ul><li>无序列表嵌套</li></ul></li><li>无序列表第二个元素</li></ul></li><li>有序列表第三个元素</li></ol><p><strong>代码</strong></p><pre><code>1. 有序列表第一个元素    1. 有序列表嵌套2. 有序列表第二个元素    + 无序列表第一个元素        + 无序列表嵌套    + 无序列表第二个元素3. 有序列表第三个元素</code></pre><hr><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p><strong>语法符号</strong>：<code> ` 每行缩进四个空格</code></p><p><strong>效果</strong></p><p><code>使用 ` 创建的代码块</code></p><pre><code>使用缩进四个空格创建的代码块可以多行使用  </code></pre><p>可以在段落文本中使用<code>`</code>来创建局部代码块，比<code>如这</code>样。</p><p><strong>代码</strong></p><pre><code>``使用 ` 创建的代码块``    使用缩进四个空格创建的代码块    可以多行使用  可以在段落文本中使用`` ` ``来创建局部代码块，比`如这`样。</code></pre><hr><h2 id="分隔线"><a href="#分隔线" class="headerlink" title="分隔线"></a>分隔线</h2><p><strong>语法符号</strong>：<code>---</code></p><p><strong>效果</strong></p><hr><p><strong>代码</strong></p><pre><code>---</code></pre><hr><h2 id="删除线"><a href="#删除线" class="headerlink" title="删除线"></a>删除线</h2><p><strong>语法符号</strong>：<code>~~内容~~</code></p><p><strong>效果</strong></p><p><del>我喜欢学习</del></p><p><strong>代码</strong></p><pre><code>~~我喜欢学习~~</code></pre><hr><h2 id="待办事项"><a href="#待办事项" class="headerlink" title="待办事项"></a>待办事项</h2><p><strong>语法符号</strong>：<code>- []</code></p><p><strong>效果</strong></p><ul><li><input checked="" disabled="" type="checkbox"> 待办事项1</li><li><input disabled="" type="checkbox"> 待办事项2</li></ul><p><strong>代码</strong></p><pre><code>- [x] 待办事项1- [ ] 待办事项2</code></pre><hr><h2 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h2><p><strong>语法符号</strong>：<code>[超链接显示名](超链接地址 &quot;超链接title&quot;)</code></p><p><strong>效果</strong></p><p>这是一个链接 <a href="https://markdown.com.cn/" title="最好的markdown教程">Markdown语法</a>。</p><p>可以使用<code>&lt;&gt;</code>括起来链接或邮箱地址：<a href="mailto:&#x72;&#111;&#115;&#x65;&#98;&#x7a;&#105;&#64;&#102;&#111;&#120;&#109;&#97;&#105;&#x6c;&#46;&#x63;&#x6f;&#x6d;">&#x72;&#111;&#115;&#x65;&#98;&#x7a;&#105;&#64;&#102;&#111;&#120;&#109;&#97;&#105;&#x6c;&#46;&#x63;&#x6f;&#x6d;</a></p><p><a href="https://bzi-han.github.io/" title="Bzi-Han&#39;s blog">占位链接</a></p><p>引用导航1<a href="%E8%BF%99%E9%87%8C%E5%8F%AF%E4%BB%A5%E5%86%99%E5%9C%A8%E9%A1%B5%E9%9D%A2%E4%B8%AD%E7%9A%84%E4%BB%BB%E4%BD%95%E5%9C%B0%E6%96%B9">^1</a><br>引用导航2<a href="https://bzi-han.github.io/">^2</a></p><p><strong>代码</strong></p><pre><code>这是一个链接 [Markdown语法](https://markdown.com.cn &quot;最好的markdown教程&quot;)。可以使用`&lt;&gt;`括起来链接或邮箱地址：&lt;rosebzi@foxmail.com&gt;[占位链接][reservelink][reservelink]: https://bzi-han.github.io/ &quot;Bzi-Han&#39;s blog&quot;引用导航1[^1]引用导航2[^2][^1]: 这里可以写在页面中的任何地方[^2]: https://bzi-han.github.io/</code></pre><hr><h2 id="图片"><a href="#图片" class="headerlink" title="图片"></a>图片</h2><p><strong>语法符号</strong>：<code>![图片alt](图片链接 &quot;图片title&quot;)</code></p><p><strong>效果</strong></p><p>只显示图片</p><p><img src="https://s1.ax1x.com/2020/08/27/dfT9Dx.gif" alt="插画" title="image"></p><p>链接与图片并用，点击图片可跳转</p><p><a href="https://baike.baidu.com/item/ASCII/309296"><img src="https://s1.ax1x.com/2022/04/17/LU1KxI.md.png" alt="ASCII" title="ascii"></a></p><p><strong>代码</strong></p><pre><code>只显示图片![插画](https://s1.ax1x.com/2020/08/27/dfT9Dx.gif &quot;image&quot;)链接与图片并用，点击图片可跳转[![ASCII](https://s1.ax1x.com/2022/04/17/LU1KxI.md.png &quot;ascii&quot;)](https://baike.baidu.com/item/ASCII/309296)</code></pre><hr><h2 id="转义"><a href="#转义" class="headerlink" title="转义"></a>转义</h2><p><strong>语法符号</strong>：<code>\ &amp;xxx;</code></p><p><strong>效果</strong></p><p>&amp;nbsp;普通空格 <code>&amp;nbsp;</code><br>&amp;ensp;半角空格 <code>&amp;ensp;</code><br>&amp;emsp;全角空格 <code>&amp;emsp;</code></p><p>* 这里使用<code>\</code>转义了<code>*</code>符号</p><p><strong>代码</strong></p><pre><code>&amp;nbsp;普通空格 `&amp;nbsp;`  &amp;ensp;半角空格 `&amp;ensp;`  &amp;emsp;全角空格 `&amp;emsp;`\* 这里使用`\`转义了`*`符号</code></pre><hr><h2 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h2><p><strong>语法符号</strong>：<code>| : -</code></p><p><strong>效果</strong></p><table><thead><tr><th align="center">第一列</th><th align="left">第二列</th><th align="right">第三列</th></tr></thead><tbody><tr><td align="center">center aligment</td><td align="left">left aligment</td><td align="right">right aligment</td></tr><tr><td align="center">data1</td><td align="left">data2</td><td align="right">data3</td></tr><tr><td align="center">data1</td><td align="left">data2</td><td align="right">data3</td></tr><tr><td align="center">data1</td><td align="left">data2</td><td align="right">data3</td></tr><tr><td align="center">data1</td><td align="left">data2</td><td align="right">data3</td></tr><tr><td align="center">data1</td><td align="left">data2</td><td align="right">data3</td></tr></tbody></table><p><strong>代码</strong></p><pre><code>| 第一列 | 第二列 | 第三列 || :-: | :- | -: || center aligment | left aligment | right aligment || data1 | data2 | data3 || data1 | data2 | data3 || data1 | data2 | data3 || data1 | data2 | data3 || data1 | data2 | data3 |</code></pre><hr><h2 id="内嵌HTML"><a href="#内嵌HTML" class="headerlink" title="内嵌HTML"></a>内嵌HTML</h2><p><strong>效果</strong></p><p><i>label i</i><br><a src="https://bzi-han.github.io/" style="color:#dd001b;cursor:pointer;">超链接</a></p><p><strong>代码</strong></p><pre><code>&lt;i&gt;label i&lt;/i&gt;  &lt;a src=&quot;https://bzi-han.github.io/&quot; style=&quot;color:#dd001b;cursor:pointer;&quot;&gt;超链接&lt;/a&gt;</code></pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2022/03/30/hello-world/"/>
      <url>/2022/03/30/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre><code class="bash">$ hexo new &quot;My New Post&quot;</code></pre><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre><code class="bash">$ hexo server</code></pre><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre><code class="bash">$ hexo generate</code></pre><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre><code class="bash">$ hexo deploy</code></pre><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
