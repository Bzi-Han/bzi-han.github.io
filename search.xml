<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>[逆向] 记录小黑盒签名算法的逆向过程</title>
      <link href="/2022/04/18/%E9%80%86%E5%90%91-%E8%AE%B0%E5%BD%95%E5%B0%8F%E9%BB%91%E7%9B%92%E7%AD%BE%E5%90%8D%E7%AE%97%E6%B3%95%E7%9A%84%E9%80%86%E5%90%91%E8%BF%87%E7%A8%8B/"/>
      <url>/2022/04/18/%E9%80%86%E5%90%91-%E8%AE%B0%E5%BD%95%E5%B0%8F%E9%BB%91%E7%9B%92%E7%AD%BE%E5%90%8D%E7%AE%97%E6%B3%95%E7%9A%84%E9%80%86%E5%90%91%E8%BF%87%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<p>白嫖的动力是无限的。</p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本文仅供学习探讨之用，如果侵犯了您的权益请联系我删除。</p><h2 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h2><ol><li><a href="https://www.telerik.com/fiddler" title="Fiddler Official">Fiddler</a></li><li><a href="https://github.com/skylot/jadx" title="JADX Official">JADX</a></li><li><a href="https://hex-rays.com/" title="IDA Official">IDA</a></li><li><a href="https://github.com/frida/frida" title="Frida Official">Frida</a></li></ol><h2 id="抓包"><a href="#抓包" class="headerlink" title="抓包"></a>抓包</h2><p><img src="/images/1650222076.jpg" alt="签到包内容"></p><h2 id="重放测试"><a href="#重放测试" class="headerlink" title="重放测试"></a>重放测试</h2><p>使用<code>Shift + R</code>进行一个包的重放。</p><p><img src="/images/1650222077.jpg" alt="重放测试结果"></p><p>好家伙，那么改一下<code>_time</code>参数试试。</p><p><img src="/images/1650222078.jpg" alt="重放测试结果"></p><p>嗯，看来有签名校验，经过测试后确定是<code>hkey</code>这个参数。</p><h2 id="JADX"><a href="#JADX" class="headerlink" title="JADX"></a>JADX</h2><p>打开<code>jadx</code>并把下载好的<code>.apk</code>文件拖入软件中，等待分析完成。分析完成之后直接打开搜索窗口，输入关键字<code>hkey</code>进行搜索。</p><p><img src="/images/1650222079.jpg" alt="搜索结果"></p><p>发现没有可疑的类，那就用请求路径搜索试试。</p><p><img src="/images/1650222080.jpg" alt="搜索结果"></p><p>嗯，找到目标了，但发现这是一个接口，没有直接进行定义。那么就按下<code>x</code>键跟踪到引用那边。  </p><p><img src="/images/1650222081.jpg" alt="跟踪结果"></p><p>到了这里之后基本就没事，继续往下跟就行，过程省略…</p><p><img src="/images/1650222082.jpg" alt="最终结果"></p><p>最终到了这么一个地方，其中<code>NDKTools.encode</code>就是生成<code>hkey</code>的函数。但是在这里并没有看到<code>hkey</code>这个字段，经过了一番检查之后发现是这么生成的。  </p><pre><code>name = &quot;hey&quot;.replace(&quot;e&quot;, &quot;ke&quot;)</code></pre><p>好，那就没问题了，再来看<code>NDKTools.encode</code>函数，发现其进入了<code>so</code>中。好家伙，那这层就算完了。</p><h2 id="IDA"><a href="#IDA" class="headerlink" title="IDA"></a>IDA</h2><p>找函数的那些过程就省略了，这里直接上伪代码分析结果。</p><pre><code>v11 = (unsigned __int8 *)((__int64 (__fastcall *)(JNIEnv *, __int64, _QWORD))(*v10)-&gt;GetStringUTFChars)(v10, v9, 0LL);// 请求的API路径v12 = ((__int64 (__fastcall *)(JNIEnv *, __int64, _QWORD))(*v10)-&gt;GetStringUTFChars)(v10, v8, 0LL);// 当前时间(1649327297)v13 = (unsigned __int8 *)((__int64 (__fastcall *)(JNIEnv *, __int64, _QWORD))(*v10)-&gt;GetStringUTFChars)(v10, v7, 0LL);// 随机生成的字符串([\da-zA-Z]&#123;32,32&#125;)result = 0LL;// 判断3个参数是否为空if ( v11 &amp;&amp; v12 &amp;&amp; v13 )&#123;    // 参数不为空    v93 = 22872;    v91 = xmmword_3E60;    v92 = 6293310241825115725LL;    v95 = 0;    v15 = strlen(v13);    if ( v15 &lt; 1 )                              // 判断随机字符串长度是否小于1    &#123;    v16 = 0;    &#125;    else    &#123;    // 随机字符串大于1    v16 = 0;                                  // 计数随机字符串中出现0-9的次数    v17 = (unsigned int)v15;                  // 随机字符串的长度    v18 = v94;    do    &#123;        v20 = *v13++;        v19 = v20;        v21 = v20 - 97;        v22 = v20 - 32;        if ( (unsigned int)(v20 - 48) &lt; 0xA )        ++v16;        if ( v21 &lt; 0x1A )        v19 = v22;        --v17;        *v18++ = v19;    &#125;    while ( v17 );    &#125;    v36 = atoi(v12);                            // 当前时间(整型)    dword_6110 = ((unsigned int)(v36 + v16) &gt;&gt; 16) &amp; 0xFF;    dword_6114 = (unsigned __int16)(v36 + v16) &gt;&gt; 8;    v90 = v36 + v16;    v86 = 0;                                    // 存储包含当前时间的向量    v84 = 0u;    v85 = 0u;    v82 = 0u;    v83 = 0u;    v80 = 0u;    v81 = 0u;    v78 = 0u;    v79 = 0u;    v76 = 0u;    v77 = 0u;    v74 = 0u;    v75 = 0u;    v72 = 0u;    v73 = 0u;    dword_6118 = (unsigned int)(v36 + v16) &gt;&gt; 24;    dword_611C = (v36 + v16) &amp; 0xFF;    v87 = (unsigned int)(v36 + v16) &gt;&gt; 24;      // 往向量中存储当前时间以供稍后hashSign函数进行计算，时间是转换成大端存储的时间    v88 = (unsigned int)(v36 + v16) &gt;&gt; 16;    v89 = (unsigned __int16)(v36 + v16) &gt;&gt; 8;    v70 = 0u;    v71 = 0u;    v37 = strlen(v11);    v38 = (unsigned __int8 *)malloc(2                                * (unsigned int)((unsigned __int64)(v37 + 2) * (unsigned __int128)0xAAAAAAAAAAAAAAABLL &gt;&gt; 64) &amp; 0xFFFFFFFC | 1LL);    v39 = strlen(v11);    sub_29F8(v11, v39, v38);                // 将请求的API路径进行Base64编码    v40 = strlen(v38);    sub_2BF0((unsigned __int8 *)&amp;v70, v38, (__int64)&amp;v86, v40, 8LL);// 计算Base64编码后的请求的API路径与时间的哈希值，20字节    v41 = *(_DWORD *)((unsigned __int64)&amp;v70 &amp; 0xFFFFFFFFFFFFFFF0LL | BYTE3(v71) &amp; 0xF);    dword_6124 = BYTE3(v71);    dword_6108 = BYTE3(v71) &amp; 0xF;    dword_610C = v41;    v42 = bswap32(v41);                         // 字节反转的result[1], type uint64_t    v43 = v42 &amp; 0x7FFFFFFF;    dword_6104 = (v42 &amp; 0x7FFFFFFF) / 0x271F35A0;    v67 = 15540725856023089LL;    dword_6120 = v42;    v44 = 1307386003LL * ((v42 &gt;&gt; 2) &amp; 0x1FFFFFFF);    v45 = (v42 &amp; 0x7FFFFFFF) / 0x3AuLL;    v46 = *((_BYTE *)&amp;v91 + v43 - 58 * (_DWORD)v45);    v47 = *((unsigned __int8 *)&amp;v91 + (unsigned int)v45 - 58 * (2369637129u * v45 &gt;&gt; 37));    LODWORD(v44) = *((unsigned __int8 *)&amp;v91 + (v44 &gt;&gt; 40) - 58 * (unsigned int)(2369637129u * (v44 &gt;&gt; 40) &gt;&gt; 37));    v48 = *((unsigned __int8 *)&amp;v91 + v43 / 0x2FA28 - 58 * (2369637129u * (v43 / 0x2FA28uLL) &gt;&gt; 37));    v49 = *((unsigned __int8 *)&amp;v91 + v43 / 0xACAD10 - 58 * (2369637129u * (v43 / 0xACAD10uLL) &gt;&gt; 37));    v69 = 0;    LOBYTE(v67) = v46;                          // HKey第一位字节    BYTE1(v67) = v47;                           // HKey第三位字节    BYTE2(v67) = v44;                           // HKey第二位字节    BYTE3(v67) = v48;                           // HKey第五位字节    BYTE4(v67) = v49;                           // HKey第四位字节    v66.n128_u64[0] = __PAIR__(v44, v47);    v66.n128_u64[1] = __PAIR__(v49, v48);    v68 = 0;    sub_23FC((int *)&amp;v66);                      // 计算最后两位校验码数据    v50 = vaddvq_s32(v66);    v51 = v50        - 100        * (((unsigned __int64)(1374389535LL * v50) &gt;&gt; 63)        + ((signed int)((unsigned __int64)(1374389535LL * v50) &gt;&gt; 32) &gt;&gt; 5));    sub_25F4((__int64)&amp;v68, v52, v53, (unsigned int)v51, v54, v55, v56, v57, v66.n128_i64[0]);    v58 = v68;    if ( v51 &gt;= 10 )    v59 = v68;    else    v59 = 48;    if ( v51 &gt;= 10 )    v58 = HIBYTE(v68);    BYTE5(v67) = v59;                           // HKey第六位字节    BYTE6(v67) = v58;                           // HKey第七位字节</code></pre><p>我们需要关注的几个重点是</p><ol><li><code>v11 v12 v13</code>这三个变量分别代表的是什么</li><li><code>sub_29F8</code>这个函数是做什么的</li><li><code>sub_2BF0</code>这个函数是做什么的</li><li>其中<code>sub_2BF0</code>函数中又包含了一个<code>sub_2D50</code>，那么这个函数又是做什么的</li><li><code>sub_23FC</code>这个函数是做什么的</li></ol><p>通过对上下文进行比对，可以发现其实<code>v11 v12 v13</code>这三个变量其实就是在<code>Java</code>层传进来的<code>JString</code>转换成<code>CString</code>后的结果。打上注释。</p><p>再来看<code>sub_29F8</code>这个函数，进入之后发现其对着一个变量疯狂读取。</p><p><img src="/images/1650222085.jpg" alt="sub_29F8"></p><p>有啥这么好看的？来，让我康康！</p><p><img src="/images/1650222086.jpg" alt="byte_41D4"></p><p>过来之后可以看到是个字节数组，那就看看十六进制视图。</p><p><img src="/images/1650222087.jpg" alt="byte_41D4"></p><p>好，<code>base64Encode</code>没跑了，打上注释。</p><p>接下来是<code>sub_2BF0</code>，进入之后看到做了一些没看懂的操作</p><p><img src="/images/1650222088.jpg" alt="sub_2BF0"></p><p><a href="https://developer.arm.com/architectures/instruction-sets/intrinsics/#q=veorq_s8"><img src="/images/1650222089.jpg" alt="veorq_s8"></a></p><p>查了一下指令的<a href="https://developer.arm.com/architectures/instruction-sets/intrinsics/#q=veorq_s8" title="simd指令集文档">文档</a>，原来是对一个向量进行异或操作，那就没事了，我们继续。<br>再往下之后又进行了两次函数的调用，这个函数就是<code>sub_2D50</code>。没办法，点进去看看。<br>没看到有什么，让后往下滑到底，可以看到返回值是个20字节的数组</p><p><img src="/images/1650222090.jpg" alt="result"></p><p>说到20字节的返回值能有什么呢，第一反应就是<code>sha1</code>啊。不过这里好像也没有看到有<code>initialize value</code>…<br>说到这里,我翻看了《加密与跳楼》第6章 找参数。</p><p><img src="/images/1650222091.jpg" alt="result"></p><p>嗯…确实没有，直到我把它的参数放入计算器</p><p><img src="/images/1650222092.jpg" alt="result"></p><p>好家伙，原来是这样！打上注释。</p><p>突然想发个图：<code>TNND，给我玩阴滴是吧.jpg</code></p><p>接下来是<code>sub_23FC</code>，进入之后发现就是对我们传进去的参数进行一堆的运算，然后原路返回，那就没事了，打上注释。</p><h2 id="Frida"><a href="#Frida" class="headerlink" title="Frida"></a>Frida</h2><p>现在来<code>Hook</code>一下我们上面分析的几个函数</p><p><img src="/images/1650222093.jpg" alt="frida"></p><p><img src="/images/1650222094.jpg" alt="hookresult"></p><p><img src="/images/1650222094.jpg" alt="hookresult"></p><p>没得毛病，进入下一步</p><p><img src="/images/sticker_nice.jpg" alt="nice"></p><h2 id="计算过程"><a href="#计算过程" class="headerlink" title="计算过程"></a>计算过程</h2><p>总结一下<code>hkey</code>的计算过程大概就是这样</p><pre><code>input requestPathinput timestampinput randomStringoutput encodedRequestPath = base64Encode(requestPath)process bias = getNumberCount(randomString)output encodedTimestamp = byteSwap(timestamp + bias)alloc timestampBuffer[72]alloc requestPathBuffer[84]process memcpy(timestampBuffer, encodedRequestPath, encodedRequestPath.length)process vectorXor(timestampBuffer, &quot;6666666666666666&quot;)process memcpy(timestampBuffer + 68, encodedTimestamp, 4)output timestampSha1Result = sha1(timestampBuffer, 72)process memcpy(requestPathBuffer, encodedRequestPath, encodedRequestPath.length)process vectorXor(requestPathBuffer, &quot;\\\\\\\\\\\\\\\\&quot;)process memcpy(requestPathBuffer + 64, timestampSha1Result, 20)output requestPathSha1Result = sha1(requestPathBuffer, 84)alloc characterMapping[58] = &quot;23456789BCDFGHJKMNPQRTVWXY&quot; + randomString.toUpperCase()alloc checkSumBuffer[16]alloc hkeyBuffer[7]output indexFactor = byteSwap(requestPathSha1Result[19] &amp; 0xF) &amp; 0x7FFFFFFFprocess hkeyBuffer[0] = characterMapping[indexFactor % 0x3A]process hkeyBuffer[1] = characterMapping[indexFactor / 0x3A % 0x3A]process hkeyBuffer[2] = characterMapping[indexFactor / 0xD24 % 0x3A]process hkeyBuffer[3] = characterMapping[indexFactor / 0x2FA28 % 0x3A]process hkeyBuffer[4] = characterMapping[indexFactor / 0xACAD10 % 0x3A]process memcpy(checkSumBuffer, hkeyBuffer + 1, 4)process checkSumBuffer = calcCheckSum(checkSumBuffer) // 纯数值计算process checkSum = (vectorAdd(checkSumBuffer) % 100).toFixedWidthHexString(2)process hkeyBuffer[5] = checkSum[0]process hkeyBuffer[6] = checkSum[1]output hkey = hkeyBuffer</code></pre><p>其中<code>calcCheckSum</code>函数就是伪代码中的<code>sub_23FC</code>函数。由于函数是纯数值计算，所以直接套用就好了。</p><h2 id="代码验证"><a href="#代码验证" class="headerlink" title="代码验证"></a>代码验证</h2><p>写一份代码验证一下。</p><p><img src="/images/1650222083.jpg" alt="验证代码"></p><p><img src="/images/1650222084.jpg" alt="验证结果"></p><p>可以看到结果符合我们的预期。</p><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>其实过程中在很多地方踩了坑，调试了好几次才懂了233。<br>那就这样了，有缘再见~</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>[学习] 整理并记录一下Markdown的基本语法</title>
      <link href="/2022/04/17/%E5%AD%A6%E4%B9%A0-%E6%95%B4%E7%90%86%E5%B9%B6%E8%AE%B0%E5%BD%95%E4%B8%80%E4%B8%8BMarkdown%E7%9A%84%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/"/>
      <url>/2022/04/17/%E5%AD%A6%E4%B9%A0-%E6%95%B4%E7%90%86%E5%B9%B6%E8%AE%B0%E5%BD%95%E4%B8%80%E4%B8%8BMarkdown%E7%9A%84%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<p>Markdown 是一种轻量级标记语言，它允许人们使用易读易写的纯文本格式编写文档，Markdown文件的后缀名便是“.md”。</p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本文仅供学习探讨之用，如果侵犯了您的权益请联系我删除。</p><h2 id="普通文字"><a href="#普通文字" class="headerlink" title="普通文字"></a>普通文字</h2><p><strong>语法符号</strong>：<code>无</code></p><p>普通文字</p><hr><h2 id="标题"><a href="#标题" class="headerlink" title="标题"></a>标题</h2><p><strong>语法符号</strong>：<code># == --</code></p><!-- > # 一级标题> ## 二级标题> ### 三级标题> #### 四级标题> ##### 五级标题> ###### 六级标题>> 可选语法一级标题> ==> 可选语法二级标题> -- --><p><strong>效果</strong></p><p><img src="/images/1650196000.jpg" alt="标题" title="标题"></p><p><strong>代码</strong></p><pre><code># 一级标题## 二级标题### 三级标题#### 四级标题##### 五级标题###### 六级标题可选语法一级标题==可选语法二级标题--</code></pre><hr><h2 id="段落"><a href="#段落" class="headerlink" title="段落"></a>段落</h2><p><strong>语法符号</strong>：<code>\n\n</code></p><p><strong>效果</strong></p><p>段落文本，每段之间用空行进行分隔。</p><p>I think maybe I should use it to format all of my documents.</p><p><strong>代码</strong></p><pre><code>段落文本，每段之间用空行进行分隔。I think maybe I should use it to format all of my documents.</code></pre><hr><h2 id="换行"><a href="#换行" class="headerlink" title="换行"></a>换行</h2><p><strong>语法符号</strong>：<code>两个空格</code></p><p><strong>效果</strong></p><p>使用空格进行换行<br>这是第二行</p><p>使用<code>&lt;br&gt;</code>进行换行<br /><br>这是第二行</p><p><strong>代码</strong></p><pre><code>使用空格进行换行  这是第二行使用`&lt;br&gt;`进行换行&lt;br /&gt;这是第二行</code></pre><hr><h2 id="强调与斜体"><a href="#强调与斜体" class="headerlink" title="强调与斜体"></a>强调与斜体</h2><p><strong>语法符号</strong>：<code>*</code></p><p><strong>效果</strong></p><p><em>斜体</em><br><strong>强调</strong><br><em><strong>强调且斜体</strong></em></p><p><strong>代码</strong></p><pre><code>*斜体***强调*****强调且斜体***</code></pre><hr><h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><p><strong>语法符号</strong>：<code>&gt;</code></p><p><strong>效果</strong></p><blockquote><p>普通引用</p><p><em>引用中使用其他元素</em></p><blockquote><p>嵌套引用</p><blockquote><p>嵌套引用</p><blockquote><p>嵌套引用</p></blockquote></blockquote></blockquote><p><strong>多段落引用</strong></p></blockquote><p><strong>代码</strong></p><pre><code>&gt; 普通引用&gt;&gt; *引用中使用其他元素*&gt;&gt;&gt; 嵌套引用&gt;&gt;&gt; 嵌套引用&gt;&gt;&gt;&gt; 嵌套引用&gt;&gt; **多段落引用**</code></pre><hr><h2 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h2><p><strong>语法符号</strong>：<code>1-inf +</code></p><p><strong>效果</strong></p><ol><li>有序列表第一个元素<ol><li>有序列表嵌套</li></ol></li><li>有序列表第二个元素<ul><li>无序列表第一个元素<ul><li>无序列表嵌套</li></ul></li><li>无序列表第二个元素</li></ul></li><li>有序列表第三个元素</li></ol><p><strong>代码</strong></p><pre><code>1. 有序列表第一个元素    1. 有序列表嵌套2. 有序列表第二个元素    + 无序列表第一个元素        + 无序列表嵌套    + 无序列表第二个元素3. 有序列表第三个元素</code></pre><hr><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p><strong>语法符号</strong>：<code> ` 每行缩进四个空格</code></p><p><strong>效果</strong></p><p><code>使用 ` 创建的代码块</code></p><pre><code>使用缩进四个空格创建的代码块可以多行使用  </code></pre><p>可以在段落文本中使用<code>`</code>来创建局部代码块，比<code>如这</code>样。</p><p><strong>代码</strong></p><pre><code>``使用 ` 创建的代码块``    使用缩进四个空格创建的代码块    可以多行使用  可以在段落文本中使用`` ` ``来创建局部代码块，比`如这`样。</code></pre><hr><h2 id="分隔线"><a href="#分隔线" class="headerlink" title="分隔线"></a>分隔线</h2><p><strong>语法符号</strong>：<code>---</code></p><p><strong>效果</strong></p><hr><p><strong>代码</strong></p><pre><code>---</code></pre><hr><h2 id="删除线"><a href="#删除线" class="headerlink" title="删除线"></a>删除线</h2><p><strong>语法符号</strong>：<code>~~内容~~</code></p><p><strong>效果</strong></p><p><del>我喜欢学习</del></p><p><strong>代码</strong></p><pre><code>~~我喜欢学习~~</code></pre><hr><h2 id="待办事项"><a href="#待办事项" class="headerlink" title="待办事项"></a>待办事项</h2><p><strong>语法符号</strong>：<code>- []</code></p><p><strong>效果</strong></p><ul><li><input checked="" disabled="" type="checkbox"> 待办事项1</li><li><input disabled="" type="checkbox"> 待办事项2</li></ul><p><strong>代码</strong></p><pre><code>- [x] 待办事项1- [ ] 待办事项2</code></pre><hr><h2 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h2><p><strong>语法符号</strong>：<code>[超链接显示名](超链接地址 &quot;超链接title&quot;)</code></p><p><strong>效果</strong></p><p>这是一个链接 <a href="https://markdown.com.cn/" title="最好的markdown教程">Markdown语法</a>。</p><p>可以使用<code>&lt;&gt;</code>括起来链接或邮箱地址：<a href="mailto:&#114;&#x6f;&#115;&#101;&#x62;&#x7a;&#x69;&#64;&#102;&#x6f;&#x78;&#x6d;&#97;&#x69;&#x6c;&#x2e;&#99;&#x6f;&#109;">&#114;&#x6f;&#115;&#101;&#x62;&#x7a;&#x69;&#64;&#102;&#x6f;&#x78;&#x6d;&#97;&#x69;&#x6c;&#x2e;&#99;&#x6f;&#109;</a></p><p><a href="https://bzi-han.github.io/" title="Bzi-Han&#39;s blog">占位链接</a></p><p>引用导航1<a href="%E8%BF%99%E9%87%8C%E5%8F%AF%E4%BB%A5%E5%86%99%E5%9C%A8%E9%A1%B5%E9%9D%A2%E4%B8%AD%E7%9A%84%E4%BB%BB%E4%BD%95%E5%9C%B0%E6%96%B9">^1</a><br>引用导航2<a href="https://bzi-han.github.io/">^2</a></p><p><strong>代码</strong></p><pre><code>这是一个链接 [Markdown语法](https://markdown.com.cn &quot;最好的markdown教程&quot;)。可以使用`&lt;&gt;`括起来链接或邮箱地址：&lt;rosebzi@foxmail.com&gt;[占位链接][reservelink][reservelink]: https://bzi-han.github.io/ &quot;Bzi-Han&#39;s blog&quot;引用导航1[^1]引用导航2[^2][^1]: 这里可以写在页面中的任何地方[^2]: https://bzi-han.github.io/</code></pre><hr><h2 id="图片"><a href="#图片" class="headerlink" title="图片"></a>图片</h2><p><strong>语法符号</strong>：<code>![图片alt](图片链接 &quot;图片title&quot;)</code></p><p><strong>效果</strong></p><p>只显示图片</p><p><img src="https://s1.ax1x.com/2020/08/27/dfT9Dx.gif" alt="插画" title="image"></p><p>链接与图片并用，点击图片可跳转</p><p><a href="https://baike.baidu.com/item/ASCII/309296"><img src="https://s1.ax1x.com/2022/04/17/LU1KxI.md.png" alt="ASCII" title="ascii"></a></p><p><strong>代码</strong></p><pre><code>只显示图片![插画](https://s1.ax1x.com/2020/08/27/dfT9Dx.gif &quot;image&quot;)链接与图片并用，点击图片可跳转[![ASCII](https://s1.ax1x.com/2022/04/17/LU1KxI.md.png &quot;ascii&quot;)](https://baike.baidu.com/item/ASCII/309296)</code></pre><hr><h2 id="转义"><a href="#转义" class="headerlink" title="转义"></a>转义</h2><p><strong>语法符号</strong>：<code>\ &amp;xxx;</code></p><p><strong>效果</strong></p><p>&amp;nbsp;普通空格 <code>&amp;nbsp;</code><br>&amp;ensp;半角空格 <code>&amp;ensp;</code><br>&amp;emsp;全角空格 <code>&amp;emsp;</code></p><p>* 这里使用<code>\</code>转义了<code>*</code>符号</p><p><strong>代码</strong></p><pre><code>&amp;nbsp;普通空格 `&amp;nbsp;`  &amp;ensp;半角空格 `&amp;ensp;`  &amp;emsp;全角空格 `&amp;emsp;`\* 这里使用`\`转义了`*`符号</code></pre><hr><h2 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h2><p><strong>语法符号</strong>：<code>| : -</code></p><p><strong>效果</strong></p><table><thead><tr><th align="center">第一列</th><th align="left">第二列</th><th align="right">第三列</th></tr></thead><tbody><tr><td align="center">center aligment</td><td align="left">left aligment</td><td align="right">right aligment</td></tr><tr><td align="center">data1</td><td align="left">data2</td><td align="right">data3</td></tr><tr><td align="center">data1</td><td align="left">data2</td><td align="right">data3</td></tr><tr><td align="center">data1</td><td align="left">data2</td><td align="right">data3</td></tr><tr><td align="center">data1</td><td align="left">data2</td><td align="right">data3</td></tr><tr><td align="center">data1</td><td align="left">data2</td><td align="right">data3</td></tr></tbody></table><p><strong>代码</strong></p><pre><code>| 第一列 | 第二列 | 第三列 || :-: | :- | -: || center aligment | left aligment | right aligment || data1 | data2 | data3 || data1 | data2 | data3 || data1 | data2 | data3 || data1 | data2 | data3 || data1 | data2 | data3 |</code></pre><hr><h2 id="内嵌HTML"><a href="#内嵌HTML" class="headerlink" title="内嵌HTML"></a>内嵌HTML</h2><p><strong>效果</strong></p><p><i>label i</i><br><a src="https://bzi-han.github.io/" style="color:#dd001b;cursor:pointer;">超链接</a></p><p><strong>代码</strong></p><pre><code>&lt;i&gt;label i&lt;/i&gt;  &lt;a src=&quot;https://bzi-han.github.io/&quot; style=&quot;color:#dd001b;cursor:pointer;&quot;&gt;超链接&lt;/a&gt;</code></pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2022/03/30/hello-world/"/>
      <url>/2022/03/30/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre><code class="bash">$ hexo new &quot;My New Post&quot;</code></pre><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre><code class="bash">$ hexo server</code></pre><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre><code class="bash">$ hexo generate</code></pre><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre><code class="bash">$ hexo deploy</code></pre><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
