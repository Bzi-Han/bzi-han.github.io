<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Bzi-Han的博客</title>
  
  <subtitle>Bzi-Han&#39;s blog</subtitle>
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2022-08-08T17:05:55.207Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>Bzi-Han</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>[项目] Taskcloud基本重构完成与后续填坑记录计划贴</title>
    <link href="http://example.com/2022/07/02/%E9%A1%B9%E7%9B%AE-Taskcloud%E5%9F%BA%E6%9C%AC%E9%87%8D%E6%9E%84%E5%AE%8C%E6%88%90%E4%B8%8E%E5%90%8E%E7%BB%AD%E5%A1%AB%E5%9D%91%E8%AE%B0%E5%BD%95%E8%AE%A1%E5%88%92%E8%B4%B4/"/>
    <id>http://example.com/2022/07/02/%E9%A1%B9%E7%9B%AE-Taskcloud%E5%9F%BA%E6%9C%AC%E9%87%8D%E6%9E%84%E5%AE%8C%E6%88%90%E4%B8%8E%E5%90%8E%E7%BB%AD%E5%A1%AB%E5%9D%91%E8%AE%B0%E5%BD%95%E8%AE%A1%E5%88%92%E8%B4%B4/</id>
    <published>2022-07-02T07:37:51.000Z</published>
    <updated>2022-08-08T17:05:55.207Z</updated>
    
    <content type="html"><![CDATA[<p>记录以防忘记。</p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本文仅供学习探讨之用，如果侵犯了您的权益请联系我删除。</p><h2 id="项目地址"><a href="#项目地址" class="headerlink" title="项目地址"></a>项目地址</h2><p>本文只做简要介绍，如果有兴趣还请移步主项目阅读<code>README.md</code>。</p><h3 id="主项目"><a href="#主项目" class="headerlink" title="主项目"></a>主项目</h3><p><a href="https://github.com/Bzi-Han/taskcloud">https://github.com/Bzi-Han/taskcloud</a></p><h3 id="子项目"><a href="#子项目" class="headerlink" title="子项目"></a>子项目</h3><p><em>前端</em> <code>vue3</code> <a href="https://github.com/Bzi-Han/taskcloud_web">https://github.com/Bzi-Han/taskcloud_web</a></p><p><em>后端</em> <code>java</code> <a href="https://github.com/Bzi-Han/taskcloud_backend">https://github.com/Bzi-Han/taskcloud_backend</a></p><p><em>核心</em> <code>c++</code> <a href="https://github.com/Bzi-Han/taskcloud_core">https://github.com/Bzi-Han/taskcloud_core</a></p><h2 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h2><p>云任务是一套定时任务处理程序，用户通过与前端交互添加需要执行的任务到指定的任务包中，并设定任务包的激活状态与定时启动时间(可设定是否只运行一次或每天都运行)。除了用户手动投递的任务包外，系统会在第一次启动时与每天<code>00:00</code>时自动分发当天需要执行的任务。</p><p>任务执行所用的脚本可以是<code>Lua</code> <code>Python</code> <code>Javascript</code>这三种语言编写的代码，可以使用语言自带的各种工具函数和此程序导出的<a href="https://github.com/Bzi-Han/taskcloud/blob/main/docs/APIDocumentaion.md">API</a>接口来进行编程，任务执行的结果与执行过程中的各种日志与报错日志均可在前端控制台中看到，可作为脚本执行问题的参考数据。</p><p>若是任务的开发者还可以在帮助中心发布帮助文档，以更好地帮助用户使用。</p><h2 id="架构"><a href="#架构" class="headerlink" title="架构"></a>架构</h2><p>整个项目的架构图</p><p><img src="/images/1650222128.jpg" alt="项目架构图"></p><p>数据库的结构图</p><p><img src="/images/1650222129.png" alt="数据库结构图"></p><h2 id="基于Docker构建核心项目的编译环境"><a href="#基于Docker构建核心项目的编译环境" class="headerlink" title="基于Docker构建核心项目的编译环境"></a>基于Docker构建核心项目的编译环境</h2><p>因为<a href="https://github.com/Bzi-Han/taskcloud_core">核心项目</a>使用了<code>CMake</code>来帮助构建，所以理论上可以跨<code>Windows</code>与<code>Linux</code>进行编译(没有试过<code>Mac</code>)，但不能保证一定不会遇到问题，因此这里仅作为一个备选解决手段。</p><p>也可以作为构建基于<code>docker-debian</code> <code>clang-14</code>编译环境的参考吧。</p><ol><li>确保<code>docker</code>服务运行中。</li><li>执行<code>docker run -d --name taskcloud_builder -it debian /bin/bash</code>创建基本容器。如果需要 <strong>ssh</strong> 服务的话可再添加<code>-p 外部端口:内部端口</code>进行端口映射，后续再安装 <strong>ssh</strong> 服务即可，但我这里就不需要了。</li><li>执行<code>docker exec -it taskcloud_builder /bin/bash</code>进入容器命令行。</li><li>执行<code>cp /etc/apt/sources.list /etc/apt/sources.list.bak</code>备份 <strong>apt</strong> 源。</li><li>执行<code>sed -i &#39;s/deb.debian.org/mirrors.ustc.edu.cn/g&#39; /etc/apt/sources.list</code>替换 <strong>apt</strong> 源为中科大源，可自行设置其他源。</li><li>执行<code>sed -i &#39;s|security.debian.org/debian-security|mirrors.ustc.edu.cn/debian-security|g&#39; /etc/apt/sources.list</code>替换 <strong>apt-security</strong> 源为中科大源，可自行设置其他源。</li><li>执行<code>apt-get update</code>更新源。</li><li>执行<code>apt-get install wget -y</code>安装 <strong>wget</strong> 工具。</li><li>执行<code>apt install lsb-release wget software-properties-common -y</code>安装 <strong>lsb-release</strong> 为后续安装提供支持。</li><li>执行<code>apt install gnupg -y</code>安装 <strong>gnupg</strong> 为后续安装提供支持，否则会出现<code>Cannot write to &#39;-&#39; (Broken pipe).</code>的情况。</li><li>执行<code>cd /tmp &amp;&amp; wget https://apt.llvm.org/llvm.sh</code>切换到 <strong>tmp</strong> 目录同时下载 <strong>clang</strong> 安装脚本。</li><li>执行<code>chmod +x llvm.sh &amp;&amp; ./llvm.sh 14 all</code>添加执行权限以及直接运行脚本安装 <strong>clang-14</strong> 所有工具链。</li><li>安装完成后执行<code>update-alternatives --install /usr/bin/clang clang /usr/bin/clang-14 1 --slave /usr/bin/clang++ clang++ /usr/bin/clang++-14</code>来设置默认的 <strong>clang</strong> 与 <strong>clang++</strong> 。</li><li>执行<code>apt-get install python3-dev -y</code>安装 <strong>python3-dev</strong> 提供所需的编译环境之一。</li><li>执行<code>apt-get install libssl-dev -y</code>安装 <strong>libssl-dev</strong> 提供所需的编译环境之一。</li><li>环境搭建完毕，可以开始编译项目了。</li></ol><h2 id="TODO"><a href="#TODO" class="headerlink" title="TODO"></a>TODO</h2><ul><li><input checked="" disabled="" type="checkbox"> 添加<code>crypto.gbkToUTF8</code>函数</li><li><input checked="" disabled="" type="checkbox"> 添加<code>crypto.utf8ToGBK</code>函数</li><li><input checked="" disabled="" type="checkbox"> 添加<code>crypto.urlEncode</code>函数</li><li><input checked="" disabled="" type="checkbox"> 添加<code>crypto.urlDecode</code>函数</li><li><input checked="" disabled="" type="checkbox"> 添加<code>crypto.rsaGenerateKeyPair</code>函数</li><li><input checked="" disabled="" type="checkbox"> 添加<code>crypto.rsaEncrypt</code>函数</li><li><input checked="" disabled="" type="checkbox"> 添加<code>crypto.rsaDecrypt</code>函数</li><li><input checked="" disabled="" type="checkbox"> 修改默认管理员账号密码</li><li><input checked="" disabled="" type="checkbox"> 提醒使用<code>java -jar</code>运行后端时添加<code>-Dfile.encoding=UTF-8</code>防止默认编码导致的乱码问题</li><li><input checked="" disabled="" type="checkbox"> 修复后端<code>python</code>与<code>javascript</code>审核错误问题</li><li><input checked="" disabled="" type="checkbox"> 添加<code>system</code>模块与<code>system.delay</code>函数</li><li><input checked="" disabled="" type="checkbox"> 添加<code>requests.put</code>函数</li><li><input checked="" disabled="" type="checkbox"> 添加<code>requests.delete</code>函数</li><li><input disabled="" type="checkbox"> 添加脚本共享机制，中央仓库或者拉取指定github仓库之类的，然后自动导入数据库中。可设定此次拉取是否需要审核，不需要则直接导入为可用状态，且此功能属于管理员功能。</li><li><input disabled="" type="checkbox"> 前端添加设置中心，并添加可动态指定后端API地址得设置，配置保存到<code>localStorage</code>中。</li></ul><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>暂时告一段落了，填坑的话还是慢慢来吧。<br><img src="/images/sticker_darksee.jpg" alt="暗中观察"></p><p>那就这样了，有缘再见~ </p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;记录以防忘记。&lt;/p&gt;
&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;本文仅供学习探讨之用，如果侵犯了您的权益请联系我删除。&lt;/p&gt;
&lt;h2 id=&quot;项目地址&quot;&gt;&lt;a href=&quot;</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>[编程] 在Android Studio中使用Kotlin编写一个控制电脑远程开机的APP(WOL技术)</title>
    <link href="http://example.com/2022/06/12/%E7%BC%96%E7%A8%8B-%E5%9C%A8Android-Studio%E4%B8%AD%E4%BD%BF%E7%94%A8Kotlin%E7%BC%96%E5%86%99%E4%B8%80%E4%B8%AA%E6%8E%A7%E5%88%B6%E7%94%B5%E8%84%91%E8%BF%9C%E7%A8%8B%E5%BC%80%E6%9C%BA%E7%9A%84APP-WOL%E6%8A%80%E6%9C%AF/"/>
    <id>http://example.com/2022/06/12/%E7%BC%96%E7%A8%8B-%E5%9C%A8Android-Studio%E4%B8%AD%E4%BD%BF%E7%94%A8Kotlin%E7%BC%96%E5%86%99%E4%B8%80%E4%B8%AA%E6%8E%A7%E5%88%B6%E7%94%B5%E8%84%91%E8%BF%9C%E7%A8%8B%E5%BC%80%E6%9C%BA%E7%9A%84APP-WOL%E6%8A%80%E6%9C%AF/</id>
    <published>2022-06-12T06:49:11.000Z</published>
    <updated>2022-07-02T08:14:42.532Z</updated>
    
    <content type="html"><![CDATA[<p>本文章将只围绕坑与几个技术难点与WOL的一些相关知识展开，不会过多的描述具体细节，如若想知道还请自行查阅项目源码。</p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本文仅供学习探讨之用，如果侵犯了您的权益请联系我删除。</p><h2 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h2><ol><li><a href="https://docs.microsoft.com/en-us/windows/wsl/install" title="WSL Install Documentation">Ubuntu(WSL)</a></li><li><a href="http://manpages.ubuntu.com/manpages/bionic/man1/nslookup.1.html" title="nslookup Documentation">nslookup(Ubuntu)</a></li><li><a href="https://www.wireshark.org/" title="Wireshark Official">Wireshark</a></li><li><a href="https://developer.android.com/studio" title="Official Download">Android Studio</a></li></ol><h2 id="基本原理"><a href="#基本原理" class="headerlink" title="基本原理"></a>基本原理</h2><p>核心依赖的东西只有一个，就是WOL(Wake-on-LAN)技术，即允许通过网络消息远程打开或唤醒网络中的某台计算机。</p><p>WOL技术依赖于主板与网卡，想要使用此功能必须确保你的设备支持此技术。就现代计算机来说，应该已经没有不支持的机器了吧？(心虚)</p><p>WOL唤醒的关键点是一个叫做<code>MagicPacket(魔术包)</code>的东西，当网卡接收到发送往此网卡的魔术包并且经过校验后确认无误后就会通知主板进行系统的唤醒。</p><p><code>MagicPacket</code>的构造十分的简单，由前缀<code>6</code>个<code>0xFF</code>跟后面的重复<code>16</code>次的<code>6</code>个字节的目标机器的网卡MAC地址构成。你可以使用任何传输层的协议进行发送魔术包到目标主机，但通常会使用<code>UDP</code>协议。</p><pre><code>// MAC地址为 11:22:33:44:55:66 的示例魔术包00000000        FF FF FF FF FF FF 11 22 33 44 55 66 11 22 33 44        .......&quot;3DUf.&quot;3D00000010        55 66 11 22 33 44 55 66 11 22 33 44 55 66 11 22        Uf.&quot;3DUf.&quot;3DUf.&quot;00000020        33 44 55 66 11 22 33 44 55 66 11 22 33 44 55 66        3DUf.&quot;3DUf.&quot;3DUf00000030        11 22 33 44 55 66 11 22 33 44 55 66 11 22 33 44        .&quot;3DUf.&quot;3DUf.&quot;3D00000040        55 66 11 22 33 44 55 66 11 22 33 44 55 66 11 22        Uf.&quot;3DUf.&quot;3DUf.&quot;00000050        33 44 55 66 11 22 33 44 55 66 11 22 33 44 55 66        3DUf.&quot;3DUf.&quot;3DUf00000060        11 22 33 44 55 66                                      .&quot;3DUf</code></pre><p>我们只需要将此魔术包发往目标机器即可实现远程唤醒机器。</p><p>参考资料:</p><ol><li><a href="https://en.wikipedia.org/wiki/Wake-on-LAN" title="Wiki">Wake-on-LAN</a></li><li><a href="https://baike.baidu.com/item/%E8%BF%9C%E7%A8%8B%E5%94%A4%E9%86%92" title="百度百科">远程唤醒</a></li></ol><h2 id="需求分析"><a href="#需求分析" class="headerlink" title="需求分析"></a>需求分析</h2><p>其实只实现远程唤醒很简单，上面的内容我觉得也已经说的比较清晰了，就是组包与发包的过程。</p><p>但是如果我们要写成APP的话就只有个唤醒功能肯定是不够的。毕竟不可能每次进入APP还要手动输入一次MAC地址IP地址吧，而且配置也很麻烦。所以我们需要一个扫描局域网在线设备的功能，并可以保存配置到本地，免去手动配置的麻烦。但同时我们也需要保留手动配置的选项作为最终解决手段。</p><p>此外还有一个问题就是如果我们的电脑的IP是动态获取的(DHCP)，则我们的配置可能会失效，例如我现在的一个配置他的目标IP地址为<code>192.168.1.233</code>，而真实记录的IP地址为<code>192.168.1.234</code>。当我们往配置中的IP地址发送魔术包时由于真实机器并没有接收到，所以不会发生任何事情，于是我们需要一个可以控制是否精准唤醒目标机器的开关选项，如果是非精准唤醒则我们会向局域网广播地址<code>192.168.1.255</code>发送魔术包，使得目标机器即使与配置IP不同也可以接收到我们发送的唤醒魔术包。</p><p>在局域网扫描中我们需要获取的信息有IP地址、MAC地址、主机名。其中主机名将作为默认的配置名称，IP地址与MAC地址为唤醒目标机器的主要参数。</p><h2 id="技术难点"><a href="#技术难点" class="headerlink" title="技术难点"></a>技术难点</h2><ol><li>如何扫描局域网中的在线机器，并获取在线机器的IP地址与MAC地址。</li><li>如何通过目标机器的IP地址获取到目标机器的主机名。</li></ol><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><ol><li>使用<code>UDP</code>协议往此网段中的<code>1-254</code>台机器发送数据包使其产生ARP缓存，然后通过<code>cat /proc/net/arp</code>指令获取ARP表，解析ARP表即可获得IP地址与MAC地址。</li><li>使用<code>LLMNR</code>协议协议通过IP地址反向查询目标机器的主机名。</li></ol><h2 id="通过IP地址获取主机名功能的实现"><a href="#通过IP地址获取主机名功能的实现" class="headerlink" title="通过IP地址获取主机名功能的实现"></a>通过IP地址获取主机名功能的实现</h2><p>在Linux中有一款叫<code>nslookup</code>的工具，其功能为通过IP地址可反向查询出目标机器的主机名，接下来我们将通过对这款工具的分析来搞清楚如何实现我们需要的功能。</p><p>打开我们的Ubuntu(Linux子系统 WSL)，输入<code>nslookup ip</code>即可查看到目标机器的主机名</p><p><img src="/images/1650222118.jpeg" alt="nslookup结果"></p><p>可以看到成功查询出了主机名。</p><h2 id="Wireshark"><a href="#Wireshark" class="headerlink" title="Wireshark"></a>Wireshark</h2><p>打开Wireshark，选择以太网开始监听，在filter一栏中我们输入<code>dns || llmnr</code>过滤我们只需要看的协议。</p><p><img src="/images/1650222119.jpeg" alt="Wireshark"></p><p><img src="/images/1650222120.jpeg" alt="Wireshark"></p><p>回到控制台再一次执行我们刚才的命令</p><p><img src="/images/1650222121.jpeg" alt="执行命令Wireshark结果"></p><p>数据出来了之后我们停止抓包，来分析一下它获取主机名的流程。在这里我们只关注<code>IPV4</code>的东西，<code>IPV6</code>可以忽略不看。</p><p><img src="/images/1650222122.jpeg" alt="DNS反向查询请求结果"></p><p>可以看到他先是向默认的DNS服务器发送了一个反向查询主机名的请求（毕竟如果能直接在DNS服务器上找到就不需要进行多播了），但是DNS服务器上并没有找到相关的信息，所以它返回的数据包中并没有包含<code>Answer</code>。</p><p><code>.in-addr.arpa</code>是反向查询的专属命名空间，例如图中查询<code>192.168.3.102</code>则它的Name为<code>102.3.168.192.in-addr.arpa</code>。</p><p>在查询DNS服务器无果后它又使用LLMNR协议向局域网中广播了一则”寻机启示”，其中<code>224.0.0.252</code>这个地址是LLMNR协议的固定地址，而查询的数据包内容是不变的，因为LLMNR是基于DNS协议的一个小分支。</p><p>在广播了”寻机启示”之后，视网络状况而定目标主机如果接收到了信息，他就会主动向本机发送主机名等信息。</p><p>如图所示</p><p><img src="/images/1650222123.jpeg" alt="LLMNR广播请求结果"></p><p>其中红色框起来的是发送地址与目标地址，可以看到结果是由我们要查询的目标机器主动发往我们本机的。橙色框圈起来的<code>Domain Name</code>就是我们要查询的目标机器的主机名。</p><p>至此问题解决。</p><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><p>对于<code>DeviceDiscovery.getComputerName</code>的实现</p><pre><code>fun getComputerName(targetIp: String): String &#123;    var domainNameOffset: Int    // 组包    val packet = targetIp.let &#123;        val ips = it.split(&quot;.&quot;)        val hard01 = byteArrayOf(0x01, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00)        val hard02 = byteArrayOf(0x00, 0x0c, 0x00, 0x01)        val packetBuilder = ByteBuffer.allocate(256)        packetBuilder.putShort(888) //标识符        packetBuilder.put(hard01) //硬编码01        // 编码查询地址        domainNameOffset = packetBuilder.position()        for (i in 3 downTo 0) &#123;            packetBuilder.put(ips[i].length.toByte())            packetBuilder.put(ips[i].toByteArray())        &#125;        packetBuilder.put(7)        packetBuilder.put(&quot;in-addr&quot;.toByteArray())        packetBuilder.put(4)        packetBuilder.put(&quot;arpa&quot;.toByteArray())        packetBuilder.put(0)        packetBuilder.put(hard02) //硬编码02        domainNameOffset = packetBuilder.position() - domainNameOffset + 6 + packetBuilder.position()        DatagramPacket(packetBuilder.array(), 0, packetBuilder.position(), InetAddress.getByName(&quot;224.0.0.252&quot;), 5355)    &#125;    // 发送请求    kotlin.runCatching &#123; sender.send(packet) &#125;.onFailure &#123; return &quot;UnReachableDevice&quot; &#125;    // 接收返回    val recvBuffer = ByteBuffer.allocate(1024)    val recvPacket = DatagramPacket(recvBuffer.array(), recvBuffer.capacity())    sender.soTimeout = 1000    kotlin.runCatching &#123;        sender.receive(recvPacket)    &#125;.onFailure &#123; return &quot;UnKnowDevice&quot; &#125;    // 读取域名    recvBuffer.position(domainNameOffset)    val domainNameByteArray = ByteBuffer.allocate(recvBuffer.get().toInt())    recvBuffer.get(domainNameByteArray.array())    return String(domainNameByteArray.array())&#125;</code></pre><p>对于<code>DeviceDiscovery.scan</code>的实现</p><pre><code>fun scan(networkSegmentPrefix: String, progress: (Float) -&gt; Unit = &#123;&#125;): ArrayList&lt;LanDeviceInfo&gt; &#123;    val result = ArrayList&lt;LanDeviceInfo&gt;()    val data = ByteArray(1)    progress(0f)    for (i in 1..254) &#123;        kotlin.runCatching &#123; sender.send(DatagramPacket(data, 0, 1, InetAddress.getByName(networkSegmentPrefix + i), 888)) &#125;        progress(i / 254f)    &#125;    progress(1f)    progress(0f)    val table = runCommand(&quot;cat&quot;, &quot;/proc/net/arp&quot;)!!            .replace(&quot;\r&quot;, &quot;&quot;)            .split(&quot;\n&quot;)    for ((i, row) in table.withIndex()) &#123;        val col = row.let &#123;            val results = ArrayList&lt;String&gt;()            var flag = true            val sb = StringBuilder()            for (c in it.trim()) &#123;                when (c) &#123;                    &#39; &#39; -&gt; &#123;                        if (flag) &#123;                            results.add(sb.toString())                            sb.clear()                            flag = false                        &#125;                    &#125;                    else -&gt; &#123;                        sb.append(c)                        flag = true                    &#125;                &#125;            &#125;            if (flag)                results.add(sb.toString())            results        &#125;        when (col.size) &#123;            6 -&gt; &#123;                if (&quot;00:00:00:00:00:00&quot; != col[3] &amp;&amp; col[0].contains(networkSegmentPrefix)) &#123;                    result.add(LanDeviceInfo(                            getComputerName(col[0]),                            col[0],                            col[3],                            col[5],                            &quot;888&quot;                    ))                &#125;            &#125;        &#125;        progress(i / table.size.toFloat())    &#125;    progress(1f)    return result&#125;</code></pre><h2 id="最终效果"><a href="#最终效果" class="headerlink" title="最终效果"></a>最终效果</h2><p><img src="/images/1650222124.jpeg" alt="APP最终结果01"></p><p><img src="/images/1650222125.jpeg" alt="APP最终结果02"></p><p><img src="/images/1650222126.jpeg" alt="APP最终结果03"></p><p><img src="/images/1650222127.jpeg" alt="APP最终结果04"></p><h2 id="完整代码仓库地址"><a href="#完整代码仓库地址" class="headerlink" title="完整代码仓库地址"></a>完整代码仓库地址</h2><p><a href="https://github.com/Bzi-Han/WOLDeviceManager">GitHub</a></p><h2 id="避坑指南"><a href="#避坑指南" class="headerlink" title="避坑指南"></a>避坑指南</h2><ol><li>扫描是扫描局域网中目前在线的机器。</li><li>对于<code>真·关机</code>的机器是没法唤醒的，例如使用<code>shutdown -s -t 0</code>进行关机或者长按电源键强制关机与断电导致关机的，这三种情况无法唤醒。</li><li>Android10+的系统<a href="https://developer.android.com/about/versions/10/privacy/changes#proc-net-filesystem">无法使用</a>扫描功能，因为从Android10开始应用无法访问<code>/proc/net</code>，所以导致无法读取ARP表来进行获取IP地址与MAC地址。</li></ol><h2 id="一些思考"><a href="#一些思考" class="headerlink" title="一些思考"></a>一些思考</h2><ol><li>在配置中添加修改配置功能。</li><li>在配置中添加配置分组功能。</li><li>在配置中添加批量唤醒某个分组机器的功能。</li><li>寻找Android10+无法扫描的解决方案。</li></ol><p><del>算是遗留问题了，懒狗不想实现</del></p><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p><img src="/images/sticker_newfolder.jpg" alt="新建文件夹"></p><p>那就这样了，有缘再见~</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;本文章将只围绕坑与几个技术难点与WOL的一些相关知识展开，不会过多的描述具体细节，如若想知道还请自行查阅项目源码。&lt;/p&gt;
&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;本文仅供学</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>[编程] 在C++中实现一个内存池与几种垃圾回收机制(GC策略)</title>
    <link href="http://example.com/2022/04/28/%E7%BC%96%E7%A8%8B-%E5%9C%A8C++%E4%B8%AD%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E5%86%85%E5%AD%98%E6%B1%A0%E4%B8%8E%E5%87%A0%E7%A7%8D%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6(GC%E7%AD%96%E7%95%A5)/"/>
    <id>http://example.com/2022/04/28/%E7%BC%96%E7%A8%8B-%E5%9C%A8C++%E4%B8%AD%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E5%86%85%E5%AD%98%E6%B1%A0%E4%B8%8E%E5%87%A0%E7%A7%8D%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6(GC%E7%AD%96%E7%95%A5)/</id>
    <published>2022-04-28T04:04:16.000Z</published>
    <updated>2022-07-02T08:14:51.734Z</updated>
    
    <content type="html"><![CDATA[<p>在特定情况下使用内存池可显著提高性能。</p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本文仅供学习探讨之用，如果侵犯了您的权益请联系我删除。</p><h2 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h2><ol><li><a href="https://code.visualstudio.com/" title="Visual Studio Code Official">Visual Studio Code</a></li><li><a href="http://graphviz.org/" title="Graphviz Official">Graphviz</a></li></ol><h2 id="需求与思考"><a href="#需求与思考" class="headerlink" title="需求与思考"></a>需求与思考</h2><ol><li>可限定内存池最大可向系统申请的内存大小</li><li>尽量保证池中的内存单元都在连续的内存上</li><li>内存池每次可申请任意大小的内存</li><li>进行内存的申请时若内存池的空闲空间不足且所需内存未超过内存池最大限定可申请的内存时将进行动态扩容</li><li>内存单元释放的同时进行临近内存碎片的合并</li><li>当前需要申请的内存加上已申请的内存若超过限定最大可向系统申请的内存大小时抛出异常</li></ol><ul><li>Garbage Collection<ul><li>内存标记算法</li><li>内存标记整理算法</li><li>内存分代标记整理算法</li></ul></li><li>当前需要申请的内存加上已申请的内存若超过限定最大可向系统申请的内存大小时启动GC进行垃圾回收</li><li>若启动GC后仍无法分配内存则抛出异常</li></ul><h2 id="内存池数据结构"><a href="#内存池数据结构" class="headerlink" title="内存池数据结构"></a>内存池数据结构</h2><pre><code>// 内存单元struct MemoryUnit&#123;    uint8_t *data;        // 内存单元的数据地址    size_t size;          // 内存的数据大小    MemoryBlock *block;   // 内存单元所属的内存块    MemoryUnit *nextUnit; // 下一个内存单元    MemoryUnit *prevUnit; // 上一个内存单元&#125;;// 内存块struct MemoryBlock&#123;    uint8_t *data;          // 内存块的数据地址    size_t size;            // 内存块的数据大小    size_t freeTotal;       // 内存块中剩余的空闲内存大小    MemoryUnit *freeList;   // 内存块中的空闲内存单元    MemoryUnit *usedList;   // 内存块中的已使用内存单元    MemoryBlock *nextBlock; // 下一个内存块    MemoryBlock *prevBlock; // 上一个内存块&#125;;// 内存池struct MemoryPool&#123;    size_t systemPageSize; // 当前操作系统的内存页定义大小    size_t blockMinSize;   // 申请内存块时至少申请不能小于块最小大小    size_t poolMaxSize;    // 内存池的最大可向系统申请的内存大小    size_t poolSize;       // 内存池的当前大小    MemoryBlock *blocks;   // 内存块单向循环链表&#125;;</code></pre><h2 id="需求的解决方案"><a href="#需求的解决方案" class="headerlink" title="需求的解决方案"></a>需求的解决方案</h2><ol><li>结构体<code>MemoryPool</code>的成员<code>poolMaxSize</code>与<code>poolSize</code>用于对比并限定最大可申请的内存大小</li><li>结构体<code>MemoryPool</code>的成员<code>blockMinSize</code>用于确保单次申请过小的内存单元导致过多的不连续内存块</li><li>结构体<code>MemoryUnit</code>的成员<code>size</code>用于存放当前内存单元所使用的内存大小</li><li>若当前条件满足动态扩容的条件时，向系统申请新的内存块并使用头插法插入结构体<code>MemoryPool</code>的成员<code>blocks</code>链表中，这也是将其设计为单项循环链表的原因。与此同此还要更新成员<code>poolSize</code>的数值。</li><li>内存碎片的合并将会在内存单元释放时自动进行<strong>临近</strong>单元合并，这也是结构体<code>MemoryUnit</code>设计为双向链表的原因之一</li><li>使用当前想要申请的内存大小加上结构体<code>MemoryPool</code>的成员<code>poolSize</code>的数值进行判断即可</li></ol><h2 id="内存池代码定义与实现"><a href="#内存池代码定义与实现" class="headerlink" title="内存池代码定义与实现"></a>内存池代码定义与实现</h2><p>类<code>MemoryPool</code>的定义</p><pre><code>class MemoryPool&#123;public:    struct MemoryBlock;    struct MemoryUnit    &#123;        uint8_t *data;        size_t size;        MemoryBlock *block;        MemoryUnit *nextUnit;        MemoryUnit *prevUnit;    &#125;;    struct MemoryBlock    &#123;        uint8_t *data;        size_t size;        size_t freeTotal;        MemoryUnit *freeList;        MemoryUnit *usedList;        MemoryBlock *nextBlock;        MemoryBlock *prevBlock;    &#125;;    using unit_t = MemoryUnit;    using block_t = MemoryBlock;public:    MemoryPool(size_t poolMaxSize = 128 * 1024 * 1024, size_t blockMinSize = 4 * 1024 * 1024);    ~MemoryPool();    void *alloc(size_t size);    void free(void *data);private:    block_t *allocBlock(size_t size);    void freeBlock(block_t *block);    unit_t *allocUnit(size_t size);    void freeUnit(unit_t *unit);private:    size_t m_systemPageSize = 0;    size_t m_poolMaxSize = 0;    size_t m_blockMinSize = 0;    size_t m_poolSize = 0;    block_t *m_blocks = nullptr;&#125;;</code></pre><p>对于<code>MemoryPool::allocBlock</code>方法的实现</p><pre><code>MemoryPool::block_t *MemoryPool::allocBlock(size_t size)&#123;    // allocate memory block    auto alignedSize = size + sizeof(block_t) + sizeof(unit_t);    alignedSize = (alignedSize + (m_systemPageSize - 1)) &amp; ~(m_systemPageSize - 1); // align to system page size    if (m_blockMinSize &gt; alignedSize)        alignedSize = m_blockMinSize;    auto block = reinterpret_cast&lt;block_t *&gt;(::VirtualAlloc(nullptr, alignedSize, MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE));    if (nullptr == block)        return nullptr;    // initialize memory block    block-&gt;data = reinterpret_cast&lt;uint8_t *&gt;(block) + sizeof(block_t);    block-&gt;size = alignedSize - sizeof(block_t);    auto dataPosition = block-&gt;data;    // initialize memory used unit    block-&gt;usedList = nullptr;    // initialize memory free unit    block-&gt;freeList = reinterpret_cast&lt;unit_t *&gt;(dataPosition);    dataPosition += sizeof(unit_t);    block-&gt;freeList-&gt;data = dataPosition;    block-&gt;freeList-&gt;size = block-&gt;size - (dataPosition - block-&gt;data);    block-&gt;freeList-&gt;nextUnit = block-&gt;freeList;    block-&gt;freeList-&gt;prevUnit = block-&gt;freeList;    block-&gt;freeList-&gt;block = block;    block-&gt;freeTotal = block-&gt;freeList-&gt;size;    // add to block list    if (nullptr != m_blocks)    &#123;        block-&gt;prevBlock = m_blocks-&gt;prevBlock;        block-&gt;nextBlock = m_blocks;        m_blocks-&gt;prevBlock-&gt;nextBlock = block;        m_blocks-&gt;prevBlock = block;    &#125;    else    &#123;        block-&gt;prevBlock = block;        block-&gt;nextBlock = block;        m_blocks = block;    &#125;    // update pool size    m_poolSize += block-&gt;size + sizeof(block_t);    return block;&#125;</code></pre><p>这里在申请内存时确保与当前操作系统内存页定义大小对齐。</p><p>对于<code>MemoryPool::freeBlock</code>方法的实现</p><pre><code>void MemoryPool::freeBlock(block_t *block)&#123;    // remove from block list    if (m_blocks-&gt;prevBlock == block &amp;&amp; m_blocks-&gt;nextBlock == block)        m_blocks = nullptr;    else    &#123;        block-&gt;prevBlock-&gt;nextBlock = block-&gt;nextBlock;        block-&gt;nextBlock-&gt;prevBlock = block-&gt;prevBlock;        if (m_blocks == block)            m_blocks = block-&gt;nextBlock;    &#125;    // update pool size    m_poolSize -= block-&gt;size + sizeof(block_t);    // free memory block    ::VirtualFree(block, 0, MEM_RELEASE);&#125;</code></pre><p>对于<code>MemoryPool::allocUnit</code>方法的实现</p><pre><code>MemoryPool::unit_t *MemoryPool::allocUnit(size_t size)&#123;    // check if no block is available    if (nullptr == m_blocks)        return nullptr;    // allocate memory unit    auto block = m_blocks; // first block    do    &#123;        // check if is there no enough memory in the block        if (size &gt; block-&gt;freeTotal)        &#123;            block = block-&gt;nextBlock;            continue;        &#125;        auto unit = block-&gt;freeList; // first free unit        do        &#123;            // check if is there no enough memory in the unit            if (size &gt; unit-&gt;size)            &#123;                unit = unit-&gt;nextUnit;                continue;            &#125;            // check if unit size is more than wanted size, split unit            if (unit-&gt;size &gt; size + sizeof(unit_t))            &#123;                auto newUnit = reinterpret_cast&lt;unit_t *&gt;(unit-&gt;data + size);                newUnit-&gt;data = unit-&gt;data + size + sizeof(unit_t);                newUnit-&gt;size = unit-&gt;size - size - sizeof(unit_t);                newUnit-&gt;nextUnit = unit-&gt;nextUnit;                newUnit-&gt;prevUnit = unit;                newUnit-&gt;block = unit-&gt;block;                unit-&gt;nextUnit-&gt;prevUnit = newUnit;                unit-&gt;nextUnit = newUnit;                unit-&gt;size = size;            &#125;            // remove unit from free list            unit-&gt;prevUnit-&gt;nextUnit = unit-&gt;nextUnit;            unit-&gt;nextUnit-&gt;prevUnit = unit-&gt;prevUnit;            if (block-&gt;freeList == unit)                block-&gt;freeList = unit-&gt;nextUnit;            // add unit to used list            if (nullptr == block-&gt;usedList)            &#123;                block-&gt;usedList = unit;                unit-&gt;nextUnit = unit;                unit-&gt;prevUnit = unit;            &#125;            else            &#123;                unit-&gt;nextUnit = block-&gt;usedList;                unit-&gt;prevUnit = block-&gt;usedList-&gt;prevUnit;                block-&gt;usedList-&gt;prevUnit-&gt;nextUnit = unit;                block-&gt;usedList-&gt;prevUnit = unit;            &#125;            // update free total            block-&gt;freeTotal -= unit-&gt;size;            return unit;        &#125; while (unit != block-&gt;freeList);    &#125; while (block != m_blocks);    return nullptr;&#125;</code></pre><p>对于<code>MemoryPool::freeUnit</code>方法的实现</p><pre><code>void MemoryPool::freeUnit(unit_t *unit)&#123;    auto freeSize = unit-&gt;size;    // remove unit from used list    if (unit-&gt;prevUnit == unit &amp;&amp; unit-&gt;nextUnit == unit)        unit-&gt;block-&gt;usedList = nullptr;    else    &#123;        unit-&gt;prevUnit-&gt;nextUnit = unit-&gt;nextUnit;        unit-&gt;nextUnit-&gt;prevUnit = unit-&gt;prevUnit;        if (unit-&gt;block-&gt;usedList == unit)            unit-&gt;block-&gt;usedList = unit-&gt;nextUnit;    &#125;    // add the unit to the free list, order by address    if (nullptr == unit-&gt;block-&gt;freeList)    &#123;        unit-&gt;nextUnit = unit;        unit-&gt;prevUnit = unit;        unit-&gt;block-&gt;freeList = unit;    &#125;    else    &#123;        auto prevUnit = unit-&gt;block-&gt;freeList;        auto nextUnit = unit-&gt;block-&gt;freeList-&gt;nextUnit;        if (prevUnit == prevUnit-&gt;prevUnit &amp;&amp; prevUnit == prevUnit-&gt;nextUnit)        &#123;            // combine units if is there near units            if (unit-&gt;data + unit-&gt;size == reinterpret_cast&lt;uint8_t *&gt;(nextUnit)) // combine next unit            &#123;                unit-&gt;size += nextUnit-&gt;size + sizeof(unit_t);                unit-&gt;nextUnit = unit;                unit-&gt;prevUnit = unit;                unit-&gt;block-&gt;freeList = unit;            &#125;            else if (prevUnit-&gt;data + prevUnit-&gt;size == reinterpret_cast&lt;uint8_t *&gt;(unit)) // combine prev unit                prevUnit-&gt;size += unit-&gt;size + sizeof(unit_t);            else // add unit to free list            &#123;                unit-&gt;nextUnit = nextUnit;                unit-&gt;prevUnit = nextUnit;                nextUnit-&gt;prevUnit = unit;                nextUnit-&gt;nextUnit = unit;                unit-&gt;block-&gt;freeList = nextUnit &lt; unit ? nextUnit : unit;            &#125;        &#125;        else        &#123;            // find insert position            while (nextUnit != unit-&gt;block-&gt;freeList &amp;&amp; nextUnit &lt; unit)            &#123;                prevUnit = nextUnit;                nextUnit = nextUnit-&gt;nextUnit;            &#125;            // combine the units if is there are near units            if (unit-&gt;data + unit-&gt;size == reinterpret_cast&lt;uint8_t *&gt;(nextUnit)) // combine next unit            &#123;                unit-&gt;size += nextUnit-&gt;size + sizeof(unit_t);                unit-&gt;nextUnit = nextUnit-&gt;nextUnit;                unit-&gt;prevUnit = nextUnit-&gt;prevUnit;                nextUnit-&gt;prevUnit-&gt;nextUnit = unit;                nextUnit-&gt;nextUnit-&gt;prevUnit = unit;                nextUnit = nextUnit-&gt;nextUnit;            &#125;            if (prevUnit-&gt;data + prevUnit-&gt;size == reinterpret_cast&lt;uint8_t *&gt;(unit)) // combine prev unit            &#123;                prevUnit-&gt;size += unit-&gt;size + sizeof(unit_t);                prevUnit-&gt;nextUnit = nextUnit;                nextUnit-&gt;prevUnit = prevUnit;            &#125;        &#125;    &#125;    // update free total    m_blocks-&gt;freeTotal += freeSize;&#125;</code></pre><p>这4个主要的方法实现好之后就是<code>MemoryPool::alloc</code>与<code>MemoryPool::free</code>两个方法的实现了，我们要做的只需要对上面4个方法进行逻辑的封装就好了。</p><p>对于<code>MemoryPool::alloc</code>方法的实现</p><pre><code>void *MemoryPool::alloc(size_t size)&#123;    if (0 == size)        return nullptr;    if (nullptr == m_blocks)        m_blocks = allocBlock(size);    auto unit = allocUnit(size);    if (nullptr == unit)    &#123;        if (size + m_poolSize &gt; m_poolMaxSize)            throw std::bad_alloc();        auto block = allocBlock(size);        if (nullptr == block)            return nullptr;        unit = allocUnit(size);        if (nullptr == unit)            return nullptr;    &#125;    return unit-&gt;data;&#125;</code></pre><p>对于<code>MemoryPool::free</code>方法的实现</p><pre><code>void MemoryPool::free(void *data)&#123;    if (nullptr == data)        return;    auto unit = reinterpret_cast&lt;unit_t *&gt;(reinterpret_cast&lt;uint8_t *&gt;(data) - sizeof(unit_t));    if (nullptr == unit)        return;    if (nullptr == unit-&gt;block)        return;    freeUnit(unit);&#125;</code></pre><p>到这里，内存池的主体已经搭建好了，那接下来就对比一下性能。</p><h2 id="性能对比"><a href="#性能对比" class="headerlink" title="性能对比"></a>性能对比</h2><p>测试用的代码如下</p><pre><code>MemoryPool g_memoryPool(1 * 1024 * 1024 * 1024);template &lt;typename runable_t&gt;struct RunTickCount&#123;    runable_t &amp;&amp;runable;    uint64_t operator()() const noexcept    &#123;        auto result = __rdtsc();        runable();        return __rdtsc() - result;    &#125;&#125;;void test01()&#123;    for (size_t i = 0; i &lt; 100; i++)    &#123;        auto data = new char[8 * 1024 * 1024];        delete[] data;    &#125;&#125;void test02()&#123;    for (size_t i = 0; i &lt; 100; i++)    &#123;        auto data = ::VirtualAlloc(nullptr, 8 * 1024 * 1024, MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE);        ::VirtualFree(data, 0, MEM_RELEASE);    &#125;&#125;void test03()&#123;    for (size_t i = 0; i &lt; 100; i++)    &#123;        auto data = g_memoryPool.alloc(8 * 1024 * 1024);        g_memoryPool.free(data);    &#125;&#125;void test04()&#123;    for (size_t i = 0; i &lt; 100; i++)        auto data = new char[8 * 1024 * 1024];&#125;void test05()&#123;    for (size_t i = 0; i &lt; 100; i++)        auto data = ::VirtualAlloc(nullptr, 8 * 1024 * 1024, MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE);&#125;void test06()&#123;    for (size_t i = 0; i &lt; 100; i++)        auto data = g_memoryPool.alloc(8 * 1024 * 1024);&#125;int main()&#123;    try    &#123;        std::cout &lt;&lt; &quot;[*] test 100 loop with allocating and freeing the memory of 8MB&quot; &lt;&lt; std::endl;        std::cout &lt;&lt; &quot;[=] std new-delete time: &quot; &lt;&lt; RunTickCount&lt;decltype(test01)&gt;&#123;test01&#125;() &lt;&lt; &quot; ticks&quot; &lt;&lt; std::endl;        std::cout &lt;&lt; &quot;[=] windows virtualAlloc-Free time: &quot; &lt;&lt; RunTickCount&lt;decltype(test02)&gt;&#123;test02&#125;() &lt;&lt; &quot; ticks&quot; &lt;&lt; std::endl;        std::cout &lt;&lt; &quot;[=] memory pool alloc-free time: &quot; &lt;&lt; RunTickCount&lt;decltype(test03)&gt;&#123;test03&#125;() &lt;&lt; &quot; ticks&quot; &lt;&lt; std::endl;        std::cout &lt;&lt; &quot;[=] std just new time: &quot; &lt;&lt; RunTickCount&lt;decltype(test04)&gt;&#123;test04&#125;() &lt;&lt; &quot; ticks&quot; &lt;&lt; std::endl;        std::cout &lt;&lt; &quot;[=] windows just virtualAlloc time: &quot; &lt;&lt; RunTickCount&lt;decltype(test05)&gt;&#123;test05&#125;() &lt;&lt; &quot; ticks&quot; &lt;&lt; std::endl;        std::cout &lt;&lt; &quot;[=] memory pool just alloc time: &quot; &lt;&lt; RunTickCount&lt;decltype(test06)&gt;&#123;test06&#125;() &lt;&lt; &quot; ticks&quot; &lt;&lt; std::endl;        std::cout &lt;&lt; &quot;[+] test passed&quot; &lt;&lt; std::endl;    &#125;    catch (const std::exception &amp;e)    &#123;        std::cerr &lt;&lt; &quot;[-] &quot; &lt;&lt; e.what() &lt;&lt; std::endl;    &#125;    return 0;&#125;</code></pre><p>编译使用的参数<code>cl .\test_memorypool.cc /O2 /EHsc /std:c++20</code></p><p><img src="/images/1650222097.jpg" alt="性能测试结果"></p><p>这里仅用WindowsAPI与内存池的性能做比较，对于<code>new</code>与<code>delete</code>就当看个乐呵。</p><p>可以看到，内存池在循环申请与释放的测试中一骑绝尘。<br>这是因为在<code>freeUnit</code>时我们并没有真的把内存还给系统，而是交给内存池来保管。<br>而第二次进入<code>allocUnit</code>时因为还有可用的内存，所以可以直接分配，不需要向系统申请新的内存！</p><p>但是内存池在仅申请内存不释放的测试中被WindowsAPI所击败，这是因为仅申请内存的话调用WindowsAPI仅需一次<code>VirtualAlloc</code>的费用。<br>而内存池每次进行动态扩容时，不仅需要一次<code>VirtualAlloc</code>的费用，还需要对内存池中的各项参数进行调整，所以导致费用升高。</p><p>那么是因为这个内存池太垃圾了？其实不然，我们默认设定了内存池的最小块大小时4MB，而每次申请的内存大小为8MB，这就导致了内存池需要不断地进行动态扩容。<br>如果我们这里把内存池的块内存大小设置的更大，或者说我们每次申请的内存大小并不超过默认块大小，那么情况又会有所不同。</p><p>我们把每次申请的内存大小修改为4KB</p><pre><code>void test05()&#123;    for (size_t i = 0; i &lt; 100; i++)        auto data = ::VirtualAlloc(nullptr, 4 * 1024, MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE);&#125;void test06()&#123;    for (size_t i = 0; i &lt; 100; i++)        auto data = g_memoryPool.alloc(4 * 1024);&#125;</code></pre><p>再来看结果</p><p><img src="/images/1650222098.jpg" alt="性能测试结果"></p><p>这次轮到WindowsAPI被内存池击败了。由此可见，并不是所有情况下内存池都是适用的，仅在特定情况下内存池能较好的发挥其作用。</p><p>接下来我们写一段程序来dump内存池的内存结构，了解一下在<code>freeUnit</code>时究竟发生了什么。</p><h2 id="内存池释放单元时的Graphviz图"><a href="#内存池释放单元时的Graphviz图" class="headerlink" title="内存池释放单元时的Graphviz图"></a>内存池释放单元时的Graphviz图</h2><p>先修改一下代码，创建一个新的类<code>MemoryPoolX</code>并继承<code>MemoryPool</code>，我们将在这个类里面进行dump操作</p><pre><code>class MemoryPoolX final : public MemoryPool&#123;public:    MemoryPoolX(size_t poolMaxSize = 128 * 1024 * 1024, size_t blockMinSize = 4 * 1024 * 1024)        : MemoryPool(poolMaxSize, blockMinSize)    &#123;    &#125;    ~MemoryPoolX()    &#123;    &#125;    void dumpGraphviz()    &#123;        std::ofstream out(&quot;test_memorypool.dot&quot;);        out &lt;&lt; &quot;digraph DataStructure &#123;\n&quot;;        out &lt;&lt; &quot;node [shape=record];\n&quot;;        out &lt;&lt; &quot;\&quot;&quot; &lt;&lt; this &lt;&lt; &quot;\&quot; [label=\&quot;&#123;&lt;f0&gt;MemoryPool|&quot;            &lt;&lt; this &lt;&lt; &quot;|&quot;            &lt;&lt; &quot;&#123;systemPageSize|&quot; &lt;&lt; m_systemPageSize &lt;&lt; &quot;&#125;|&quot;            &lt;&lt; &quot;&#123;poolMaxSize|&quot; &lt;&lt; m_poolMaxSize &lt;&lt; &quot;&#125;|&quot;            &lt;&lt; &quot;&#123;blockMinSize|&quot; &lt;&lt; m_blockMinSize &lt;&lt; &quot;&#125;|&quot;            &lt;&lt; &quot;&#123;poolSize|&quot; &lt;&lt; m_poolSize &lt;&lt; &quot;&#125;|&quot;            &lt;&lt; &quot;&#123;&lt;f1&gt;blocks|&quot; &lt;&lt; m_blocks &lt;&lt; &quot;&#125;&quot;            &lt;&lt; &quot;&#125;\&quot; color=\&quot;#409eff\&quot;];\n&quot;;        block_t *block = m_blocks;        do        &#123;            out &lt;&lt; &quot;\&quot;&quot; &lt;&lt; block &lt;&lt; &quot;\&quot; [label=\&quot;&#123;&lt;f0&gt;MemoryBlock|&quot;                &lt;&lt; block &lt;&lt; &quot;|&quot;                &lt;&lt; &quot;&#123;data|&quot; &lt;&lt; block-&gt;data &lt;&lt; &quot;&#125;|&quot;                &lt;&lt; &quot;&#123;size|&quot; &lt;&lt; block-&gt;size &lt;&lt; &quot;&#125;|&quot;                &lt;&lt; &quot;&#123;freeTotal|&quot; &lt;&lt; block-&gt;freeTotal &lt;&lt; &quot;&#125;|&quot;                &lt;&lt; &quot;&#123;&lt;f1&gt;freeList|&quot; &lt;&lt; block-&gt;freeList &lt;&lt; &quot;&#125;|&quot;                &lt;&lt; &quot;&#123;&lt;f2&gt;usedList|&quot; &lt;&lt; block-&gt;usedList &lt;&lt; &quot;&#125;|&quot;                &lt;&lt; &quot;&#123;&lt;f3&gt;nextBlock|&quot; &lt;&lt; block-&gt;nextBlock &lt;&lt; &quot;&#125;|&quot;                &lt;&lt; &quot;&#123;&lt;f4&gt;prevBlock|&quot; &lt;&lt; block-&gt;prevBlock &lt;&lt; &quot;&#125;&quot;                &lt;&lt; &quot;&#125;\&quot; color=\&quot;#909399\&quot;];\n&quot;;            unit_t *unit = block-&gt;usedList;            do            &#123;                out &lt;&lt; &quot;\&quot;&quot; &lt;&lt; unit &lt;&lt; &quot;\&quot; [label=\&quot;&#123;&lt;f0&gt;MemoryUnit|&quot;                    &lt;&lt; unit &lt;&lt; &quot;|&quot;                    &lt;&lt; &quot;&#123;data|&quot; &lt;&lt; unit-&gt;data &lt;&lt; &quot;&#125;|&quot;                    &lt;&lt; &quot;&#123;size|&quot; &lt;&lt; unit-&gt;size &lt;&lt; &quot;&#125;|&quot;                    &lt;&lt; &quot;&#123;block|&quot; &lt;&lt; unit-&gt;block &lt;&lt; &quot;&#125;|&quot;                    &lt;&lt; &quot;&#123;&lt;f1&gt;nextUnit|&quot; &lt;&lt; unit-&gt;nextUnit &lt;&lt; &quot;&#125;|&quot;                    &lt;&lt; &quot;&#123;&lt;f2&gt;prevUnit|&quot; &lt;&lt; unit-&gt;prevUnit &lt;&lt; &quot;&#125;&quot;                    &lt;&lt; &quot;&#125;\&quot; color=\&quot;#f56c6c\&quot;];\n&quot;;                if (unit == block-&gt;usedList)                &#123;                    out &lt;&lt; &quot;subgraph cluster_&quot; &lt;&lt; unit &lt;&lt; &quot; &#123;\n&quot;                        &lt;&lt; &quot;label=\&quot;usedList\&quot;;\n&quot;;                    out &lt;&lt; &quot;\&quot;&quot; &lt;&lt; block &lt;&lt; &quot;\&quot;:f2 -&gt; \&quot;&quot; &lt;&lt; unit &lt;&lt; &quot;\&quot;:f0 [style=\&quot;dotted\&quot; color=\&quot;#0000ff\&quot;];\n&quot;;                &#125;                else                    out &lt;&lt; &quot;\&quot;&quot; &lt;&lt; unit-&gt;nextUnit &lt;&lt; &quot;\&quot;:f2 -&gt; \&quot;&quot; &lt;&lt; unit &lt;&lt; &quot;\&quot;:f0 [style=\&quot;dotted\&quot; color=\&quot;#0000ff\&quot;];\n&quot;;                unit = unit-&gt;nextUnit;            &#125; while (unit != block-&gt;usedList);            out &lt;&lt; &quot;&#125;\n&quot;;            unit = block-&gt;freeList;            do            &#123;                out &lt;&lt; &quot;\&quot;&quot; &lt;&lt; unit &lt;&lt; &quot;\&quot; [label=\&quot;&#123;&lt;f0&gt;MemoryUnit|&quot;                    &lt;&lt; unit &lt;&lt; &quot;|&quot;                    &lt;&lt; &quot;&#123;data|&quot; &lt;&lt; unit-&gt;data &lt;&lt; &quot;&#125;|&quot;                    &lt;&lt; &quot;&#123;size|&quot; &lt;&lt; unit-&gt;size &lt;&lt; &quot;&#125;|&quot;                    &lt;&lt; &quot;&#123;block|&quot; &lt;&lt; unit-&gt;block &lt;&lt; &quot;&#125;|&quot;                    &lt;&lt; &quot;&#123;&lt;f1&gt;nextUnit|&quot; &lt;&lt; unit-&gt;nextUnit &lt;&lt; &quot;&#125;|&quot;                    &lt;&lt; &quot;&#123;&lt;f2&gt;prevUnit|&quot; &lt;&lt; unit-&gt;prevUnit &lt;&lt; &quot;&#125;&quot;                    &lt;&lt; &quot;&#125;\&quot; color=\&quot;#67c23a\&quot;];\n&quot;;                if (unit == block-&gt;freeList)                &#123;                    out &lt;&lt; &quot;subgraph cluster_&quot; &lt;&lt; unit &lt;&lt; &quot; &#123;\n&quot;                        &lt;&lt; &quot;label=\&quot;freeList\&quot;;\n&quot;;                    out &lt;&lt; &quot;\&quot;&quot; &lt;&lt; block &lt;&lt; &quot;\&quot;:f1 -&gt; \&quot;&quot; &lt;&lt; unit &lt;&lt; &quot;\&quot;:f0 [style=\&quot;dashed\&quot; color=\&quot;#0000ff\&quot;];\n&quot;;                &#125;                else                    out &lt;&lt; &quot;\&quot;&quot; &lt;&lt; unit-&gt;nextUnit &lt;&lt; &quot;\&quot;:f1 -&gt; \&quot;&quot; &lt;&lt; unit &lt;&lt; &quot;\&quot;:f0 [style=\&quot;dashed\&quot; color=\&quot;#0000ff\&quot;];\n&quot;;                unit = unit-&gt;nextUnit;            &#125; while (unit != block-&gt;freeList);            out &lt;&lt; &quot;&#125;\n&quot;;            if (block == m_blocks)                out &lt;&lt; &quot;\&quot;&quot; &lt;&lt; this &lt;&lt; &quot;\&quot;:f1 -&gt; \&quot;&quot; &lt;&lt; block &lt;&lt; &quot;\&quot;:f0 [color=\&quot;#0000ff\&quot;];\n&quot;;            else                out &lt;&lt; &quot;\&quot;&quot; &lt;&lt; block-&gt;nextBlock &lt;&lt; &quot;\&quot;:f3 -&gt; \&quot;&quot; &lt;&lt; block &lt;&lt; &quot;\&quot;:f0 [color=\&quot;#0000ff\&quot;];\n&quot;;            block = block-&gt;nextBlock;        &#125; while (block != m_blocks);        out &lt;&lt; &quot;&#125;&quot;;        out.close();    &#125;&#125;;MemoryPoolX g_memoryPool(1 * 1024 * 1024 * 1024);void dumpGraphviz()&#123;    std::vector&lt;void *&gt; datas;    for (size_t i = 0; i &lt; 6; i++)        datas.push_back(g_memoryPool.alloc(i * 1024));    datas.push_back(g_memoryPool.alloc(8 * 1024 * 1024));    datas.push_back(g_memoryPool.alloc(8 * 1024 * 1024));    g_memoryPool.dumpGraphviz();    std::cout &lt;&lt; &quot;dump01&quot; &lt;&lt; std::endl;    getchar();    g_memoryPool.free(datas[2]);    g_memoryPool.dumpGraphviz();    std::cout &lt;&lt; &quot;dump02&quot; &lt;&lt; std::endl;    getchar();    g_memoryPool.free(datas[3]);    g_memoryPool.dumpGraphviz();    std::cout &lt;&lt; &quot;dump03&quot; &lt;&lt; std::endl;    getchar();&#125;</code></pre><p>然后在<code>main</code>函数中调用<code>dumpGraphviz</code>就好了，直接看结果(若看不清可对着图片右键，然后选择<code>在新标签页中打开图片</code>)</p><p>申请完内存后的内存布局情况，其中红色为已使用的，绿色为空闲的</p><p><img src="/images/1650222099.jpeg" alt="graphvizDump01"></p><p>释放大小为<code>2048</code>的这个内存单元后的内存布局情况</p><p><img src="/images/1650222100.jpeg" alt="graphvizDump02"></p><p>可以看到第一个内存块的空闲内存单元链表中多出了一个大小为<code>2048</code>的空闲内存单元，因为其与大小为<code>4178648</code>的空闲内存单元并不临近，所以并没有进行内存单元(碎片)的合并。</p><p>释放大小为<code>3072</code>的这个内存单元后的内存布局情况</p><p><img src="/images/1650222101.jpeg" alt="graphvizDump03"></p><p>在释放大小为<code>3072</code>的内存单元的同时检测到其与大小为<code>2048</code>的空闲内存单元为临近内存单元，所以会进行碎片的合并。<br>为什么会生成一个大小为<code>5160</code>的空闲内存单元而不是大小为<code>5120</code>的单元是因为合并成一个时需要丢弃被合并的内存单元的头部信息，而头部信息占用的内存大小为<code>40</code>字节，因此合并后就是<code>5160</code>字节。其他单元依此类推。</p><p>到这里，内存池的内容基本就讲完了，接下来我们来看看垃圾回收机制。</p><h2 id="Garbage-Collection"><a href="#Garbage-Collection" class="headerlink" title="Garbage Collection"></a>Garbage Collection</h2><p><strong>注意：</strong><code>这里所说的标记使用的是引用计数的方式来模拟，真正的GC中不应出现引用计数这种东西。</code></p><p>其实个人觉得在C++中使用GC的意义不大，虽然会更方便一点，但是使用智能指针与作用域限定进行自动内存管理其实也差不多，所以GC这里的内容就算是写着玩的了。</p><p>想要在C++中实现GC，我们要做的第一件事情是要对<code>raw pointer</code>进行封装，因为如果使用的是<code>raw pointer</code>的话，我们无法对数据的引用进行更新，也无法跟踪指针的使用。例如：GC运行后仍有未知代码对被GC的指针(<code>raw pointer</code>)进行访问，造成程序的崩溃。</p><h3 id="原始指针的封装"><a href="#原始指针的封装" class="headerlink" title="原始指针的封装"></a>原始指针的封装</h3><p>我们这里使用引用计数的方式来跟踪指针，上代码。</p><p>先给内存单元添加三个属性</p><pre><code>// 内存单元struct MemoryUnit&#123;    uint8_t *data;        // 内存单元的数据地址    size_t size;          // 内存的数据大小    size_t refIndex;      // 内存单元引用表的对应的索引(用于内存整理算法更新引用)    size_t refCount;      // 内存单元引用计数(用于内存标记算法)    size_t aliveCount;    // 内存单元的GC存活计数(用于分代理论)    MemoryBlock *block;   // 内存单元所属的内存块    MemoryUnit *nextUnit; // 下一个内存单元    MemoryUnit *prevUnit; // 上一个内存单元&#125;;</code></pre><p>然后给<code>MemoryPool</code>添加一个成员<code>std::unordered_map&lt;size_t, unit_t *&gt; m_refUnits</code>，用来记录用于整理算法的指针引用。并添加一个<code>[]</code>运算符的重载</p><pre><code>unit_t *operator[](size_t index)&#123;    return m_refUnits[index];&#125;</code></pre><p>方便对于内存单元的访问。</p><p>原始指针的封装类</p><pre><code>class GCMemory&#123;public:    friend MemoryPool;public:    GCMemory(MemoryPool *pool, size_t unitIndex)        : m_pool(pool),          m_unitIndex(unitIndex)    &#123;        (*m_pool)[m_unitIndex]-&gt;refCount++;    &#125;    GCMemory()        : m_pool(nullptr),          m_unitIndex(0)    &#123;    &#125;    ~GCMemory()    &#123;        if (nullptr == m_pool)            return;        auto unit = (*m_pool)[m_unitIndex];        if (nullptr != unit)            unit-&gt;refCount--;    &#125;    GCMemory(GCMemory &amp;other)        : m_pool(other.m_pool)    &#123;        (*m_pool)[m_unitIndex]-&gt;refCount++;    &#125;    GCMemory(GCMemory &amp;&amp;other)        : m_pool(other.m_pool)    &#123;        other.m_pool = nullptr;    &#125;    GCMemory &amp;operator=(GCMemory &amp;other)    &#123;        m_pool = other.m_pool;        (*m_pool)[m_unitIndex]-&gt;refCount++;        return *this;    &#125;    GCMemory &amp;operator=(GCMemory &amp;&amp;other)    &#123;        m_pool = other.m_pool;        other.m_pool = nullptr;        return *this;    &#125;    GCMemory &amp;operator++()    &#123;        (*m_pool)[m_unitIndex]-&gt;refCount++;        return *this;    &#125;    GCMemory &amp;operator--()    &#123;        auto unit = (*m_pool)[m_unitIndex];        if (unit-&gt;refCount &gt; 0)            unit-&gt;refCount--;        return *this;    &#125;    operator bool() const    &#123;        auto unit = (*m_pool)[m_unitIndex];        return nullptr != m_pool &amp;&amp; nullptr != unit &amp;&amp; unit-&gt;refCount &gt; 0;    &#125;    operator void *() const noexcept    &#123;        auto unit = (*m_pool)[m_unitIndex];        return nullptr == unit ? nullptr : unit-&gt;data;    &#125;    operator uint8_t *() const noexcept    &#123;        auto unit = (*m_pool)[m_unitIndex];        return nullptr == unit ? nullptr : unit-&gt;data;    &#125;private:    MemoryPool *m_pool;    size_t m_unitIndex;&#125;;using gc_t = GCMemory;</code></pre><p>对于<code>MemoryPool::allocGC</code>方法的实现</p><pre><code>MemoryPool::gc_t MemoryPool::allocGC(size_t size)&#123;    if (0 == size)        return &#123;&#125;;    if (nullptr == m_blocks)        m_blocks = allocBlock(size);    auto unit = allocUnit(size);    if (nullptr == unit)    &#123;        if (size + m_poolSize &gt; m_poolMaxSize)            throw std::bad_alloc();        auto block = allocBlock(size);        if (nullptr == block)            return &#123;&#125;;        unit = allocUnit(size);        if (nullptr == unit)            return &#123;&#125;;    &#125;    static size_t unitIndex = 0;    m_refUnits[unitIndex] = unit;    unit-&gt;refIndex = unitIndex++;    unit-&gt;refCount = 0;    unit-&gt;aliveCount = 0;    return gc_t(this, unit-&gt;refIndex);&#125;</code></pre><p>那么来稍微测试一下</p><p><img src="/images/1650222102.jpeg" alt="作用域测试01"></p><p><img src="/images/1650222103.jpeg" alt="作用域测试01"></p><p>可以看到，在刚申请完的时候引用计数为<code>1</code>，并在走出作用域后变为了<code>0</code>。</p><h3 id="内存标记算法"><a href="#内存标记算法" class="headerlink" title="内存标记算法"></a>内存标记算法</h3><pre><code>void MemoryPool::markedGC()&#123;    for (auto &amp;unit : m_refUnits)    &#123;        if (0 != unit.second-&gt;refCount)            continue;        freeUnit(unit.second);        unit.second = nullptr;    &#125;&#125;</code></pre><p>这个其实没什么好说的，当发生GC的时候检查内存单元的引用计数，若为<code>0</code>则表示没有使用，进行内存的回收。</p><p>看一下效果</p><p><img src="/images/1650222104.jpeg" alt="内存标记算法结果"></p><p>在这里我们手动将<code>data02</code>的引用计数<code>-1</code>来模拟无引用的情况。</p><p>可以看到，在执行GC之后引用计数为<code>0</code>的<code>data02</code>的引用指针变成了<code>nullptr</code>，说明GC运行成功。正常情况下只论标记回收算法的话内存池会产生大量的内存碎片，但我们这里在释放的时候会自动进行临近碎片的合并，所以情况其实还好。</p><p>看一下内存结构变化的<code>Graphviz</code>图，对应代码中两处<code>g_memoryPool.dumpGraphviz()</code>的调用。</p><table><thead><tr><th><img src="/images/1650222105.jpeg" alt="内存标记算法内存结构变化01"></th><th><img src="/images/1650222106.jpeg" alt="内存标记算法内存结构变化02"></th></tr></thead></table><p><strong>注意：</strong><code>对于后面将要说的两种算法来说，当前的内存池模型属于冗余设计。实际设计时因为存在整理算法，所以freeList、usedList这些都可以不要，直接使用一个成员标记最后申请的位置即可。在下次进入申请内存时仅需判断当前块是否有足够的空闲内存，如果没有则动态扩容，否则可直接返回最后申请的位置，在这种情况下算法的时间复杂度仅为O(1)</code></p><h3 id="内存标记整理算法"><a href="#内存标记整理算法" class="headerlink" title="内存标记整理算法"></a>内存标记整理算法</h3><p>在实现整理算法之前还需要两个特别重要的方法需要实现，分别是<code>suspendTheWorld</code>与<code>resumeTheWorld</code>。</p><p>在我们进行内存整理之前需要先对当前进程的除当前线程外的所有线程进行暂停，因为在我们进行整理的过程中不允许出现被整理内存被其他线程访问的情况，否则可能会导致出现数据错误甚至崩溃等问题。</p><p>上代码</p><pre><code>std::vector&lt;HANDLE&gt; MemoryPool::suspendTheWorld()&#123;    std::vector&lt;HANDLE&gt; threadHandles;    auto currentProcessId = ::GetCurrentProcessId();    auto currentThreadId = ::GetCurrentThreadId();    auto snapshotHandle = ::CreateToolhelp32Snapshot(TH32CS_SNAPTHREAD, 0);    if (nullptr != snapshotHandle)    &#123;        THREADENTRY32 threadEntry&#123;&#125;;        threadEntry.dwSize = sizeof(threadEntry);        if (!::Thread32First(snapshotHandle, &amp;threadEntry))            return threadHandles;        do        &#123;            if (currentProcessId != threadEntry.th32OwnerProcessID || currentThreadId == threadEntry.th32ThreadID)                continue;            auto handle = ::OpenThread(THREAD_ALL_ACCESS, false, threadEntry.th32ThreadID);            if (nullptr == handle)                throw std::exception(&quot;OpenThread failed&quot;);            if (-1 == ::SuspendThread(handle))                throw std::exception(&quot;SuspendThread failed&quot;);            threadHandles.push_back(handle);        &#125; while (::Thread32Next(snapshotHandle, &amp;threadEntry));        ::CloseHandle(snapshotHandle);    &#125;    return threadHandles;&#125;void MemoryPool::resumeTheWorld(std::vector&lt;HANDLE&gt; &amp;handles)&#123;    for (auto &amp;handle : handles)    &#123;        if (-1 == ::ResumeThread(handle))            throw std::exception(&quot;ResumeThread failed&quot;);        ::CloseHandle(handle);    &#125;&#125;</code></pre><p>这两个方法实现之后再来实现内存标记整理算法</p><pre><code>void MemoryPool::markedTidyingGC()&#123;    std::set&lt;unit_t *&gt; aliveUnits;    std::vector&lt;unit_t *&gt; deadUnits;    auto threadHandles = suspendTheWorld(); // 砸瓦鲁多    auto block = m_blocks;    do    &#123;        aliveUnits.clear();        deadUnits.clear();        auto unit = block-&gt;usedList;        do        &#123;            if (0 != unit-&gt;refCount)                aliveUnits.insert(unit);            else                deadUnits.push_back(unit);            unit = unit-&gt;nextUnit;        &#125; while (unit != block-&gt;usedList);        // check if alive units is empty        if (aliveUnits.empty())        &#123;            // free all dead units            for (auto &amp;unit : deadUnits)            &#123;                m_refUnits[unit-&gt;refIndex] = nullptr;                freeUnit(unit);            &#125;        &#125;        else        &#123;            // update dead unit reference            for (const auto &amp;unit : deadUnits)                m_refUnits[unit-&gt;refIndex] = nullptr;            // move alive units to the front of the block            auto unitMoveToPosition = reinterpret_cast&lt;unit_t *&gt;(block-&gt;data);            size_t usedTotalSize = 0;            for (auto &amp;unit : aliveUnits)            &#123;                memcpy(unitMoveToPosition, unit, sizeof(unit_t) + unit-&gt;size);                unitMoveToPosition-&gt;data = reinterpret_cast&lt;uint8_t *&gt;(unitMoveToPosition) + sizeof(unit_t);                if (0 == usedTotalSize)                &#123;                    block-&gt;usedList = unitMoveToPosition;                    unitMoveToPosition-&gt;nextUnit = unitMoveToPosition;                    unitMoveToPosition-&gt;prevUnit = unitMoveToPosition;                &#125;                else                &#123;                    block-&gt;usedList-&gt;prevUnit-&gt;nextUnit = unitMoveToPosition;                    unitMoveToPosition-&gt;prevUnit = block-&gt;usedList-&gt;prevUnit;                    unitMoveToPosition-&gt;nextUnit = block-&gt;usedList;                    block-&gt;usedList-&gt;prevUnit = unitMoveToPosition;                &#125;                usedTotalSize += unitMoveToPosition-&gt;size + sizeof(unit_t);                unitMoveToPosition = reinterpret_cast&lt;unit_t *&gt;(unitMoveToPosition-&gt;data + unitMoveToPosition-&gt;size);            &#125;            // reset free unit list            block-&gt;freeTotal = block-&gt;size - usedTotalSize - sizeof(unit_t);            block-&gt;freeList = reinterpret_cast&lt;unit_t *&gt;(block-&gt;data + usedTotalSize);            block-&gt;freeList-&gt;data = reinterpret_cast&lt;uint8_t *&gt;(block-&gt;freeList) + sizeof(unit_t);            block-&gt;freeList-&gt;block = block;            block-&gt;freeList-&gt;size = block-&gt;freeTotal;            block-&gt;freeList-&gt;nextUnit = block-&gt;freeList;            block-&gt;freeList-&gt;prevUnit = block-&gt;freeList;            // update used unit reference            unit = block-&gt;usedList;            do            &#123;                m_refUnits[unit-&gt;refIndex] = unit;                unit = unit-&gt;nextUnit;            &#125; while (unit != block-&gt;usedList);        &#125;        block = block-&gt;nextBlock;    &#125; while (block != m_blocks);    resumeTheWorld(threadHandles); // 使用相同类型的替身&#125;</code></pre><p>可以看到整个整理的过程就是先暂停世界，然后记录在此次GC中仙去与存活的内存单元。</p><p>如果此次GC没有存活的内存单元则直接直接进行内存单元的释放，否则先进行仙去内存单元的指针引用更新，使其变为<code>nullptr</code>，接下来对存活内存单元进行数据移动，将整个内存单元移动至前一个内存单元的后面，使其紧密贴合，如果是第一个移动的话则移动的目标地址是当前内存块的数据地址。</p><p>你问我会不会后面的数据把前面的单元给覆盖了？自然是不会，这是为什么使用<code>std::set</code>而不是<code>std::vector、std::unordered_set</code>等容器来存放存活内存单元地址的原因，因为<code>std::set</code>会自动给我们进行排序，而只要我们保证存活内存单元的移动是顺序的，就不会发生数据覆盖的情况。<br><strong>小提示：</strong><code>std::set基于红黑树实现，如果不需要排序的功能可使用std::unordered_set，std::unordered_set的实现基于哈希表，在性能上可直接吊打</code></p><p>在移动完所有存活的内存单元之后我们需要更新空闲内存空间的信息，因为我们已将使用的内存单元移动到内存块首部，所以剩下的都是可使用的空闲内存，直接分配一个大块空闲内存单元就好了。</p><p>最后我们需要更新已使用的内存单元的指针引用信息并取消整个世界的暂停即可。</p><p>看效果</p><p><img src="/images/1650222107.jpeg" alt="内存标记整理算法结果"></p><p>运行过程内存结构变化的<code>Graphviz</code>图</p><table><thead><tr><th><img src="/images/1650222108.jpeg" alt="内存标记整理算法内存结构变化01"></th><th><img src="/images/1650222109.jpeg" alt="内存标记整理算法内存结构变化02"></th></tr></thead></table><p>可以看到<code>data02</code>被释放后原本使用的地址被<code>data03</code>拿去用了，说明移动整理成功。</p><h3 id="内存分代标记整理算法"><a href="#内存分代标记整理算法" class="headerlink" title="内存分代标记整理算法"></a>内存分代标记整理算法</h3><p><strong>提示：</strong><code>因当前内存池结构不太好实现分代，所以接下来会另外申请一块内存来当作老年代</code></p><p>代码</p><pre><code>void MemoryPool::generationalMarkedTidyingGC()&#123;    static unit_t *elderUnitList = reinterpret_cast&lt;unit_t *&gt;(::VirtualAlloc(nullptr, 32 * 1024 * 1024, MEM_RESERVE | MEM_COMMIT, PAGE_READWRITE));    static size_t elderUnitListIndex = 0;    if (nullptr == elderUnitList)        throw std::exception(&quot;Emulate elder block failed&quot;);    std::set&lt;unit_t *&gt; elderUnits;    std::set&lt;unit_t *&gt; aliveUnits;    std::vector&lt;unit_t *&gt; deadUnits;    auto threadHandles = suspendTheWorld(); // 砸瓦鲁多    auto block = m_blocks;    do    &#123;        if (nullptr == block-&gt;usedList)        &#123;            block = block-&gt;nextBlock;            continue;        &#125;        elderUnits.clear();        aliveUnits.clear();        deadUnits.clear();        auto unit = block-&gt;usedList;        do        &#123;            if (0 != unit-&gt;refCount)            &#123;                if (4 &lt;= ++unit-&gt;aliveCount)                    elderUnits.insert(unit);                else                    aliveUnits.insert(unit);            &#125;            else                deadUnits.push_back(unit);            unit = unit-&gt;nextUnit;        &#125; while (unit != block-&gt;usedList);        // check if alive units and elder units is empty        if (aliveUnits.empty() &amp;&amp; elderUnits.empty())        &#123;            // free all dead units            for (auto &amp;unit : deadUnits)            &#123;                m_refUnits[unit-&gt;refIndex] = nullptr;                freeUnit(unit);            &#125;        &#125;        else        &#123;            // update dead unit reference            for (const auto &amp;unit : deadUnits)                m_refUnits[unit-&gt;refIndex] = nullptr;            // move elder units to the front of the elder block            for (auto &amp;unit : elderUnits)            &#123;                memcpy(elderUnitList + elderUnitListIndex, unit, sizeof(unit_t) + unit-&gt;size);                auto elderUnit = reinterpret_cast&lt;unit_t *&gt;(elderUnitList + elderUnitListIndex);                elderUnit-&gt;data = reinterpret_cast&lt;uint8_t *&gt;(elderUnit) + sizeof(unit_t);                elderUnit-&gt;block = nullptr;                if (0 == elderUnitListIndex)                &#123;                    elderUnit-&gt;nextUnit = elderUnit;                    elderUnit-&gt;prevUnit = elderUnit;                &#125;                else                &#123;                    elderUnitList-&gt;prevUnit-&gt;nextUnit = elderUnit;                    elderUnit-&gt;prevUnit = elderUnitList-&gt;prevUnit;                    elderUnit-&gt;nextUnit = elderUnitList;                    elderUnitList-&gt;prevUnit = elderUnit;                &#125;                // update elder unit reference                m_refUnits[elderUnit-&gt;refIndex] = elderUnit;                elderUnitListIndex += sizeof(unit_t) + elderUnit-&gt;size;            &#125;            // move alive units to the front of the block            auto unitMoveToPosition = reinterpret_cast&lt;unit_t *&gt;(block-&gt;data);            size_t usedTotalSize = 0;            if (0 == aliveUnits.size())                block-&gt;usedList = nullptr;            for (auto &amp;unit : aliveUnits)            &#123;                memcpy(unitMoveToPosition, unit, sizeof(unit_t) + unit-&gt;size);                unitMoveToPosition-&gt;data = reinterpret_cast&lt;uint8_t *&gt;(unitMoveToPosition) + sizeof(unit_t);                if (0 == usedTotalSize)                &#123;                    block-&gt;usedList = unitMoveToPosition;                    unitMoveToPosition-&gt;nextUnit = unitMoveToPosition;                    unitMoveToPosition-&gt;prevUnit = unitMoveToPosition;                &#125;                else                &#123;                    block-&gt;usedList-&gt;prevUnit-&gt;nextUnit = unitMoveToPosition;                    unitMoveToPosition-&gt;prevUnit = block-&gt;usedList-&gt;prevUnit;                    unitMoveToPosition-&gt;nextUnit = block-&gt;usedList;                    block-&gt;usedList-&gt;prevUnit = unitMoveToPosition;                &#125;                usedTotalSize += unitMoveToPosition-&gt;size + sizeof(unit_t);                unitMoveToPosition = reinterpret_cast&lt;unit_t *&gt;(unitMoveToPosition-&gt;data + unitMoveToPosition-&gt;size);            &#125;            // reset free unit list            block-&gt;freeTotal = block-&gt;size - usedTotalSize - sizeof(unit_t);            block-&gt;freeList = reinterpret_cast&lt;unit_t *&gt;(block-&gt;data + usedTotalSize);            block-&gt;freeList-&gt;data = reinterpret_cast&lt;uint8_t *&gt;(block-&gt;freeList) + sizeof(unit_t);            block-&gt;freeList-&gt;block = block;            block-&gt;freeList-&gt;size = block-&gt;freeTotal;            block-&gt;freeList-&gt;nextUnit = block-&gt;freeList;            block-&gt;freeList-&gt;prevUnit = block-&gt;freeList;            // update used unit reference            if (nullptr != block-&gt;usedList)            &#123;                unit = block-&gt;usedList;                do                &#123;                    m_refUnits[unit-&gt;refIndex] = unit;                    unit = unit-&gt;nextUnit;                &#125; while (unit != block-&gt;usedList);            &#125;        &#125;        block = block-&gt;nextBlock;    &#125; while (block != m_blocks);    resumeTheWorld(threadHandles); // 使用相同类型的替身&#125;</code></pre><p>其中<code>elderUnitList</code>就是我们用来模拟老年代的另外申请的内存块。</p><p>另外在内存标记整理算法的基础上加了个判断，当内存单元的GC存活次数<code>&gt;= 4</code>的时候，我们就把它移动到老年代的内存块上，并更新内存单元的指针引用。</p><p>当在所有的已使用内存单元都成为老年代的情况下，我们还需要将当前内存块的已使用内存单元链表设置为<code>nullptr</code>。</p><p>这里分代的基本思路就是将内存分为新生代与老年代，其中新生代就是我们当前的内存池，老年代就是另外申请的那一块大小<code>32MB</code>的内存。发生GC时我们只对新生代做操作，而进入老年代的内存单元基本移动到老年代的内存块上之后就放手不管了，并且设定进入老年代的条件是内存单元能活过<code>4</code>次GC的调用（GC的调用基本只会发生在内存池无法再申请内存的情况下，除非手动调用）。</p><p>写段代码来看看效果</p><p><img src="/images/1650222110.jpeg" alt="内存分代标记整理算法结果"></p><p>可以看到第一次GC之后进行了一次内存整理，并回收了引用计数为<code>0</code>的<code>data02</code>。接下来再进行4次GC，但真正执行的其实只有3次，第4次进去后因为判断到内存块的<code>usedList</code>为<code>nullptr</code>，所以就直接进行了返回。这表明前3次已经将存活次数<code>&gt;= 4</code>的<code>test01</code>与<code>test03</code>两个对应的内存单元移动到了老年代内存块上了。</p><p>来看一下内存结构变化的<code>Graphviz</code>图</p><table><thead><tr><th><img src="/images/1650222111.jpeg" alt="内存分代标记整理算法内存结构变化01"></th><th><img src="/images/1650222112.jpeg" alt="内存分代标记整理算法内存结构变化02"></th><th><img src="/images/1650222113.jpeg" alt="内存分代标记整理算法内存结构变化03"></th></tr></thead></table><p>可以看到运行到最后内存池已不存在使用中的内存单元，所有的内存均已归还，而被使用了的内存单元则被转移到了老年代内存块之上，那么来看一下老年代内存块的<code>Graphviz</code>图</p><p><img src="/images/1650222114.jpeg" alt="老年代内存块结构"></p><p>这两个内存单元就是我们的<code>test01</code>与<code>test03</code>，移动正确。</p><h2 id="GC前后的操作"><a href="#GC前后的操作" class="headerlink" title="GC前后的操作"></a>GC前后的操作</h2><p>在没有必要的时候我们要尽量避免GC的调用，可在仅当内存池超过限定最大可向系统申请的内存大小时才启动GC进行垃圾回收，并且避免手动的去调用GC。</p><p>在GC后若仍无法分配内存则抛出异常<code>std::bad_alloc</code>。</p><p>以上说的两个操作只需要在运行时做一些判断即可，在这里就不实现了，那么到这里我们所要探讨的几种垃圾回收机制就整完了，接下来我们回到GC之前。</p><h2 id="C-使用特化"><a href="#C-使用特化" class="headerlink" title="C++使用特化"></a>C++使用特化</h2><p>为了方便使用，来实现两个简单的包装函数。</p><pre><code>template &lt;typename class_t&gt;class_t &amp;object() requires std::is_pod_v&lt;class_t&gt;&#123;    return *reinterpret_cast&lt;class_t *&gt;(alloc(sizeof(class_t)));&#125;template &lt;typename class_t, typename... params_t&gt;class_t &amp;object(params_t &amp;&amp;...params)&#123;    class_t *placement = (class_t *)alloc(sizeof(class_t));    if (nullptr == placement)        throw std::bad_alloc();    new (placement) class_t(std::forward&lt;params_t&gt;(params)...);    return *placement;&#125;</code></pre><p>然后测试一下</p><table><thead><tr><th><img src="/images/1650222115.jpeg" alt="结构"></th><th><img src="/images/1650222116.jpeg" alt="测试"></th></tr></thead></table><p>然后我这里不需要容器的支持（主要是懒得实现<code>std::allocator</code>），直接对其禁用。</p><p>先在外部声明一个<code>concept</code></p><pre><code>template &lt;typename any_t&gt;concept is_container = requires(any_t any)&#123;    &#123;any.size()&#125;;    &#123;any.begin()&#125;;    &#123;any.end()&#125;;&#125;;</code></pre><p>然后再实现函数</p><pre><code>template &lt;typename class_t, typename... params_t&gt;class_t &amp;object(params_t &amp;&amp;...params) requires is_container&lt;class_t&gt;&#123;    static_assert(false, &quot;Unsupported type of container.&quot;);    return &#123;&#125;;&#125;</code></pre><p>测试</p><p><img src="/images/1650222117.jpeg" alt="测试"></p><p>差不多就这样了。</p><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>想起还有一件事没做，就是在<code>allocUnit</code>的时候需要对齐<code>sizeof(void*)</code>，不过在这里就不再实现了，鸭蛋莫鸭蛋。</p><p>那就这样了，有缘再见~</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;在特定情况下使用内存池可显著提高性能。&lt;/p&gt;
&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;本文仅供学习探讨之用，如果侵犯了您的权益请联系我删除。&lt;/p&gt;
&lt;h2 id=&quot;工具&quot;</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>[逆向] 记录小黑盒签名算法的逆向过程</title>
    <link href="http://example.com/2022/04/18/%E9%80%86%E5%90%91-%E8%AE%B0%E5%BD%95%E5%B0%8F%E9%BB%91%E7%9B%92%E7%AD%BE%E5%90%8D%E7%AE%97%E6%B3%95%E7%9A%84%E9%80%86%E5%90%91%E8%BF%87%E7%A8%8B/"/>
    <id>http://example.com/2022/04/18/%E9%80%86%E5%90%91-%E8%AE%B0%E5%BD%95%E5%B0%8F%E9%BB%91%E7%9B%92%E7%AD%BE%E5%90%8D%E7%AE%97%E6%B3%95%E7%9A%84%E9%80%86%E5%90%91%E8%BF%87%E7%A8%8B/</id>
    <published>2022-04-17T18:45:42.000Z</published>
    <updated>2022-07-02T08:14:57.136Z</updated>
    
    <content type="html"><![CDATA[<p>白嫖的动力是无限的。</p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本文仅供学习探讨之用，如果侵犯了您的权益请联系我删除。</p><h2 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h2><ol><li><a href="https://www.telerik.com/fiddler" title="Fiddler Official">Fiddler</a></li><li><a href="https://github.com/skylot/jadx" title="JADX Official">JADX</a></li><li><a href="https://hex-rays.com/" title="IDA Official">IDA</a></li><li><a href="https://github.com/frida/frida" title="Frida Official">Frida</a></li></ol><h2 id="抓包"><a href="#抓包" class="headerlink" title="抓包"></a>抓包</h2><p><img src="/images/1650222076.jpg" alt="签到包内容"></p><h2 id="重放测试"><a href="#重放测试" class="headerlink" title="重放测试"></a>重放测试</h2><p>使用<code>Shift + R</code>进行一个包的重放。</p><p><img src="/images/1650222077.jpg" alt="重放测试结果"></p><p>好家伙，那么改一下<code>_time</code>参数试试。</p><p><img src="/images/1650222078.jpg" alt="重放测试结果"></p><p>嗯，看来有签名校验，经过测试后确定是<code>hkey</code>这个参数。</p><h2 id="JADX"><a href="#JADX" class="headerlink" title="JADX"></a>JADX</h2><p>打开<code>jadx</code>并把下载好的<code>.apk</code>文件拖入软件中，等待分析完成。分析完成之后直接打开搜索窗口，输入关键字<code>hkey</code>进行搜索。</p><p><img src="/images/1650222079.jpg" alt="搜索结果"></p><p>发现没有可疑的类，那就用请求路径搜索试试。</p><p><img src="/images/1650222080.jpg" alt="搜索结果"></p><p>嗯，找到目标了，但发现这是一个接口，没有直接进行定义。那么就按下<code>x</code>键跟踪到引用那边。  </p><p><img src="/images/1650222081.jpg" alt="跟踪结果"></p><p>到了这里之后基本就没事，继续往下跟就行，过程省略…</p><p><img src="/images/1650222082.jpg" alt="最终结果"></p><p>最终到了这么一个地方，其中<code>NDKTools.encode</code>就是生成<code>hkey</code>的函数。但是在这里并没有看到<code>hkey</code>这个字段，经过了一番检查之后发现是这么生成的。  </p><pre><code>name = &quot;hey&quot;.replace(&quot;e&quot;, &quot;ke&quot;)</code></pre><p>好，那就没问题了，再来看<code>NDKTools.encode</code>函数，发现其进入了<code>so</code>中。好家伙，那这层就算完了。</p><h2 id="IDA"><a href="#IDA" class="headerlink" title="IDA"></a>IDA</h2><p>找函数的那些过程就省略了，这里直接上伪代码分析结果。</p><pre><code>v11 = (unsigned __int8 *)((__int64 (__fastcall *)(JNIEnv *, __int64, _QWORD))(*v10)-&gt;GetStringUTFChars)(v10, v9, 0LL);// 请求的API路径v12 = ((__int64 (__fastcall *)(JNIEnv *, __int64, _QWORD))(*v10)-&gt;GetStringUTFChars)(v10, v8, 0LL);// 当前时间(1649327297)v13 = (unsigned __int8 *)((__int64 (__fastcall *)(JNIEnv *, __int64, _QWORD))(*v10)-&gt;GetStringUTFChars)(v10, v7, 0LL);// 随机生成的字符串([\da-zA-Z]&#123;32,32&#125;)result = 0LL;// 判断3个参数是否为空if ( v11 &amp;&amp; v12 &amp;&amp; v13 )&#123;    // 参数不为空    v93 = 22872;    v91 = xmmword_3E60;    v92 = 6293310241825115725LL;    v95 = 0;    v15 = strlen(v13);    if ( v15 &lt; 1 )                              // 判断随机字符串长度是否小于1    &#123;    v16 = 0;    &#125;    else    &#123;    // 随机字符串大于1    v16 = 0;                                  // 计数随机字符串中出现0-9的次数    v17 = (unsigned int)v15;                  // 随机字符串的长度    v18 = v94;    do    &#123;        v20 = *v13++;        v19 = v20;        v21 = v20 - 97;        v22 = v20 - 32;        if ( (unsigned int)(v20 - 48) &lt; 0xA )        ++v16;        if ( v21 &lt; 0x1A )        v19 = v22;        --v17;        *v18++ = v19;    &#125;    while ( v17 );    &#125;    v36 = atoi(v12);                            // 当前时间(整型)    dword_6110 = ((unsigned int)(v36 + v16) &gt;&gt; 16) &amp; 0xFF;    dword_6114 = (unsigned __int16)(v36 + v16) &gt;&gt; 8;    v90 = v36 + v16;    v86 = 0;                                    // 存储包含当前时间的向量    v84 = 0u;    v85 = 0u;    v82 = 0u;    v83 = 0u;    v80 = 0u;    v81 = 0u;    v78 = 0u;    v79 = 0u;    v76 = 0u;    v77 = 0u;    v74 = 0u;    v75 = 0u;    v72 = 0u;    v73 = 0u;    dword_6118 = (unsigned int)(v36 + v16) &gt;&gt; 24;    dword_611C = (v36 + v16) &amp; 0xFF;    v87 = (unsigned int)(v36 + v16) &gt;&gt; 24;      // 往向量中存储当前时间以供稍后sub_2BF0函数进行计算，时间是转换成大端存储的时间    v88 = (unsigned int)(v36 + v16) &gt;&gt; 16;    v89 = (unsigned __int16)(v36 + v16) &gt;&gt; 8;    v70 = 0u;    v71 = 0u;    v37 = strlen(v11);    v38 = (unsigned __int8 *)malloc(2                                * (unsigned int)((unsigned __int64)(v37 + 2) * (unsigned __int128)0xAAAAAAAAAAAAAAABLL &gt;&gt; 64) &amp; 0xFFFFFFFC | 1LL);    v39 = strlen(v11);    sub_29F8(v11, v39, v38);                // 将请求的API路径进行Base64编码    v40 = strlen(v38);    sub_2BF0((unsigned __int8 *)&amp;v70, v38, (__int64)&amp;v86, v40, 8LL);// 计算Base64编码后的请求的API路径与时间的哈希值，20字节    v41 = *(_DWORD *)((unsigned __int64)&amp;v70 &amp; 0xFFFFFFFFFFFFFFF0LL | BYTE3(v71) &amp; 0xF);    dword_6124 = BYTE3(v71);    dword_6108 = BYTE3(v71) &amp; 0xF;    dword_610C = v41;    v42 = bswap32(v41);    v43 = v42 &amp; 0x7FFFFFFF;    dword_6104 = (v42 &amp; 0x7FFFFFFF) / 0x271F35A0;    v67 = 15540725856023089LL;    dword_6120 = v42;    v44 = 1307386003LL * ((v42 &gt;&gt; 2) &amp; 0x1FFFFFFF);    v45 = (v42 &amp; 0x7FFFFFFF) / 0x3AuLL;    v46 = *((_BYTE *)&amp;v91 + v43 - 58 * (_DWORD)v45);    v47 = *((unsigned __int8 *)&amp;v91 + (unsigned int)v45 - 58 * (2369637129u * v45 &gt;&gt; 37));    LODWORD(v44) = *((unsigned __int8 *)&amp;v91 + (v44 &gt;&gt; 40) - 58 * (unsigned int)(2369637129u * (v44 &gt;&gt; 40) &gt;&gt; 37));    v48 = *((unsigned __int8 *)&amp;v91 + v43 / 0x2FA28 - 58 * (2369637129u * (v43 / 0x2FA28uLL) &gt;&gt; 37));    v49 = *((unsigned __int8 *)&amp;v91 + v43 / 0xACAD10 - 58 * (2369637129u * (v43 / 0xACAD10uLL) &gt;&gt; 37));    v69 = 0;    LOBYTE(v67) = v46;                          // HKey第一位字节    BYTE1(v67) = v47;                           // HKey第三位字节    BYTE2(v67) = v44;                           // HKey第二位字节    BYTE3(v67) = v48;                           // HKey第五位字节    BYTE4(v67) = v49;                           // HKey第四位字节    v66.n128_u64[0] = __PAIR__(v44, v47);    v66.n128_u64[1] = __PAIR__(v49, v48);    v68 = 0;    sub_23FC((int *)&amp;v66);                      // 计算最后两位校验码数据    v50 = vaddvq_s32(v66);    v51 = v50        - 100        * (((unsigned __int64)(1374389535LL * v50) &gt;&gt; 63)        + ((signed int)((unsigned __int64)(1374389535LL * v50) &gt;&gt; 32) &gt;&gt; 5));    sub_25F4((__int64)&amp;v68, v52, v53, (unsigned int)v51, v54, v55, v56, v57, v66.n128_i64[0]);    v58 = v68;    if ( v51 &gt;= 10 )    v59 = v68;    else    v59 = 48;    if ( v51 &gt;= 10 )    v58 = HIBYTE(v68);    BYTE5(v67) = v59;                           // HKey第六位字节    BYTE6(v67) = v58;                           // HKey第七位字节</code></pre><p>我们需要关注的几个重点是</p><ol><li><code>v11 v12 v13</code>这三个变量分别代表的是什么</li><li><code>sub_29F8</code>这个函数是做什么的</li><li><code>sub_2BF0</code>这个函数是做什么的</li><li>其中<code>sub_2BF0</code>函数中又包含了一个<code>sub_2D50</code>，那么这个函数又是做什么的</li><li><code>sub_23FC</code>这个函数是做什么的</li></ol><p>通过对上下文进行比对，可以发现其实<code>v11 v12 v13</code>这三个变量其实就是在<code>Java</code>层传进来的<code>JString</code>转换成<code>CString</code>后的结果。打上注释。</p><p>再来看<code>sub_29F8</code>这个函数，进入之后发现其对着一个变量疯狂读取。</p><p><img src="/images/1650222085.jpg" alt="sub_29F8"></p><p>有啥这么好看的？来，让我康康！</p><p><img src="/images/1650222086.jpg" alt="byte_41D4"></p><p>过来之后可以看到是个字节数组，那就看看十六进制视图。</p><p><img src="/images/1650222087.jpg" alt="byte_41D4"></p><p>好，<code>base64Encode</code>没跑了，打上注释。</p><p>接下来是<code>sub_2BF0</code>，进入之后看到做了一些没看懂的操作</p><p><img src="/images/1650222088.jpg" alt="sub_2BF0"></p><p><a href="https://developer.arm.com/architectures/instruction-sets/intrinsics/#q=veorq_s8"><img src="/images/1650222089.jpg" alt="veorq_s8"></a></p><p>查了一下指令的<a href="https://developer.arm.com/architectures/instruction-sets/intrinsics/#q=veorq_s8" title="ARM SIMD指令集文档">文档</a>，原来是对一个向量进行异或操作，那就没事了，我们继续。<br>再往下之后又进行了两次函数的调用，这个函数就是<code>sub_2D50</code>。没办法，点进去看看。<br>好像没看到有什么…<br>往下滑到底看一下，这时可以看到返回值是个20字节的数组</p><p><img src="/images/1650222090.jpg" alt="result"></p><p>说到20字节的返回值能有什么呢，第一反应就是<code>sha1</code>啊。不过这里好像也没有看到有<code>initialize values</code>…<br>说到这里，我翻看了《加密与跳楼（第4版）》第6章 找<code>sha1</code>的初始参数。</p><p><img src="/images/1650222091.jpg" alt="book"><br><img src="/images/1650222096.jpg" alt="book"></p><p>嗯…确实没有，直到我把它的参数放入计算器</p><p><img src="/images/1650222092.jpg" alt="calc"></p><p>好家伙，原来是这样！打上注释。</p><p>突然想发个图：<code>TNND，给我玩阴滴是吧.jpg</code></p><p>接下来是<code>sub_23FC</code>，进入之后发现就是对我们传进去的参数进行一堆的运算，然后原路返回，那就没事了，打上注释。</p><h2 id="Frida"><a href="#Frida" class="headerlink" title="Frida"></a>Frida</h2><p>现在来<code>Hook</code>一下我们上面分析的几个函数</p><p><img src="/images/1650222093.jpg" alt="frida"></p><p><img src="/images/1650222094.jpg" alt="hookresult"></p><p><img src="/images/1650222095.jpg" alt="hookresult"></p><p>没得毛病，进入下一步</p><p><img src="/images/sticker_nice.jpg" alt="nice"></p><h2 id="计算过程"><a href="#计算过程" class="headerlink" title="计算过程"></a>计算过程</h2><p>总结一下<code>hkey</code>的计算过程大概就是这样</p><pre><code>input requestPathinput timestampinput randomStringoutput encodedRequestPath = base64Encode(requestPath)process bias = getNumberCount(randomString)output encodedTimestamp = byteSwap(timestamp + bias)alloc timestampBuffer[72]alloc requestPathBuffer[84]process memcpy(timestampBuffer, encodedRequestPath, encodedRequestPath.length)process vectorXor(timestampBuffer, &quot;6666666666666666&quot;)process memcpy(timestampBuffer + 68, encodedTimestamp, 4)output timestampSha1Result = sha1(timestampBuffer, 72)process memcpy(requestPathBuffer, encodedRequestPath, encodedRequestPath.length)process vectorXor(requestPathBuffer, &quot;\\\\\\\\\\\\\\\\&quot;)process memcpy(requestPathBuffer + 64, timestampSha1Result, 20)output requestPathSha1Result = sha1(requestPathBuffer, 84)alloc characterMapping[58] = &quot;23456789BCDFGHJKMNPQRTVWXY&quot; + randomString.toUpperCase()alloc checkSumBuffer[16]alloc hkeyBuffer[7]output indexFactor = byteSwap(requestPathSha1Result[19] &amp; 0xF) &amp; 0x7FFFFFFFprocess hkeyBuffer[0] = characterMapping[indexFactor % 0x3A]process hkeyBuffer[1] = characterMapping[indexFactor / 0x3A % 0x3A]process hkeyBuffer[2] = characterMapping[indexFactor / 0xD24 % 0x3A]process hkeyBuffer[3] = characterMapping[indexFactor / 0x2FA28 % 0x3A]process hkeyBuffer[4] = characterMapping[indexFactor / 0xACAD10 % 0x3A]process memcpy(checkSumBuffer, hkeyBuffer + 1, 4)process checkSumBuffer = calcCheckSum(checkSumBuffer) // 纯数值计算process checkSum = (vectorAdd(checkSumBuffer) % 100).toFixedWidthHexString(2)process hkeyBuffer[5] = checkSum[0]process hkeyBuffer[6] = checkSum[1]output hkey = hkeyBuffer</code></pre><p>其中<code>calcCheckSum</code>函数就是伪代码中的<code>sub_23FC</code>函数。由于函数是纯数值计算，所以直接套用就好了。</p><h2 id="代码验证"><a href="#代码验证" class="headerlink" title="代码验证"></a>代码验证</h2><p>写一份代码验证一下。</p><p><img src="/images/1650222083.jpg" alt="验证代码"></p><p><img src="/images/1650222084.jpg" alt="验证结果"></p><p>可以看到结果符合我们的预期。</p><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>其实过程中在很多地方踩了坑，调试了好几次才懂了233。<br>那就这样了，有缘再见~</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;白嫖的动力是无限的。&lt;/p&gt;
&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;本文仅供学习探讨之用，如果侵犯了您的权益请联系我删除。&lt;/p&gt;
&lt;h2 id=&quot;工具&quot;&gt;&lt;a href=</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>[学习] 整理并记录一下Markdown的基本语法</title>
    <link href="http://example.com/2022/04/17/%E5%AD%A6%E4%B9%A0-%E6%95%B4%E7%90%86%E5%B9%B6%E8%AE%B0%E5%BD%95%E4%B8%80%E4%B8%8BMarkdown%E7%9A%84%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/"/>
    <id>http://example.com/2022/04/17/%E5%AD%A6%E4%B9%A0-%E6%95%B4%E7%90%86%E5%B9%B6%E8%AE%B0%E5%BD%95%E4%B8%80%E4%B8%8BMarkdown%E7%9A%84%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/</id>
    <published>2022-04-17T11:00:04.000Z</published>
    <updated>2022-07-02T08:14:38.011Z</updated>
    
    <content type="html"><![CDATA[<p>Markdown 是一种轻量级标记语言，它允许人们使用易读易写的纯文本格式编写文档，Markdown文件的后缀名便是“.md”。</p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本文仅供学习探讨之用，如果侵犯了您的权益请联系我删除。</p><h2 id="普通文字"><a href="#普通文字" class="headerlink" title="普通文字"></a>普通文字</h2><p><strong>语法符号</strong>：<code>无</code></p><p>普通文字</p><hr><h2 id="标题"><a href="#标题" class="headerlink" title="标题"></a>标题</h2><p><strong>语法符号</strong>：<code># == --</code></p><!-- > # 一级标题> ## 二级标题> ### 三级标题> #### 四级标题> ##### 五级标题> ###### 六级标题>> 可选语法一级标题> ==> 可选语法二级标题> -- --><p><strong>效果</strong></p><p><img src="/images/1650196000.jpg" alt="标题" title="标题"></p><p><strong>代码</strong></p><pre><code># 一级标题## 二级标题### 三级标题#### 四级标题##### 五级标题###### 六级标题可选语法一级标题==可选语法二级标题--</code></pre><hr><h2 id="段落"><a href="#段落" class="headerlink" title="段落"></a>段落</h2><p><strong>语法符号</strong>：<code>\n\n</code></p><p><strong>效果</strong></p><p>段落文本，每段之间用空行进行分隔。</p><p>I think maybe I should use it to format all of my documents.</p><p><strong>代码</strong></p><pre><code>段落文本，每段之间用空行进行分隔。I think maybe I should use it to format all of my documents.</code></pre><hr><h2 id="换行"><a href="#换行" class="headerlink" title="换行"></a>换行</h2><p><strong>语法符号</strong>：<code>两个空格</code></p><p><strong>效果</strong></p><p>使用空格进行换行<br>这是第二行</p><p>使用<code>&lt;br&gt;</code>进行换行<br /><br>这是第二行</p><p><strong>代码</strong></p><pre><code>使用空格进行换行  这是第二行使用`&lt;br&gt;`进行换行&lt;br /&gt;这是第二行</code></pre><hr><h2 id="强调与斜体"><a href="#强调与斜体" class="headerlink" title="强调与斜体"></a>强调与斜体</h2><p><strong>语法符号</strong>：<code>*</code></p><p><strong>效果</strong></p><p><em>斜体</em><br><strong>强调</strong><br><em><strong>强调且斜体</strong></em></p><p><strong>代码</strong></p><pre><code>*斜体***强调*****强调且斜体***</code></pre><hr><h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><p><strong>语法符号</strong>：<code>&gt;</code></p><p><strong>效果</strong></p><blockquote><p>普通引用</p><p><em>引用中使用其他元素</em></p><blockquote><p>嵌套引用</p><blockquote><p>嵌套引用</p><blockquote><p>嵌套引用</p></blockquote></blockquote></blockquote><p><strong>多段落引用</strong></p></blockquote><p><strong>代码</strong></p><pre><code>&gt; 普通引用&gt;&gt; *引用中使用其他元素*&gt;&gt;&gt; 嵌套引用&gt;&gt;&gt; 嵌套引用&gt;&gt;&gt;&gt; 嵌套引用&gt;&gt; **多段落引用**</code></pre><hr><h2 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h2><p><strong>语法符号</strong>：<code>1-inf +</code></p><p><strong>效果</strong></p><ol><li>有序列表第一个元素<ol><li>有序列表嵌套</li></ol></li><li>有序列表第二个元素<ul><li>无序列表第一个元素<ul><li>无序列表嵌套</li></ul></li><li>无序列表第二个元素</li></ul></li><li>有序列表第三个元素</li></ol><p><strong>代码</strong></p><pre><code>1. 有序列表第一个元素    1. 有序列表嵌套2. 有序列表第二个元素    + 无序列表第一个元素        + 无序列表嵌套    + 无序列表第二个元素3. 有序列表第三个元素</code></pre><hr><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p><strong>语法符号</strong>：<code> ` 每行缩进四个空格</code></p><p><strong>效果</strong></p><p><code>使用 ` 创建的代码块</code></p><pre><code>使用缩进四个空格创建的代码块可以多行使用  </code></pre><p>可以在段落文本中使用<code>`</code>来创建局部代码块，比<code>如这</code>样。</p><p><strong>代码</strong></p><pre><code>``使用 ` 创建的代码块``    使用缩进四个空格创建的代码块    可以多行使用  可以在段落文本中使用`` ` ``来创建局部代码块，比`如这`样。</code></pre><hr><h2 id="分隔线"><a href="#分隔线" class="headerlink" title="分隔线"></a>分隔线</h2><p><strong>语法符号</strong>：<code>---</code></p><p><strong>效果</strong></p><hr><p><strong>代码</strong></p><pre><code>---</code></pre><hr><h2 id="删除线"><a href="#删除线" class="headerlink" title="删除线"></a>删除线</h2><p><strong>语法符号</strong>：<code>~~内容~~</code></p><p><strong>效果</strong></p><p><del>我喜欢学习</del></p><p><strong>代码</strong></p><pre><code>~~我喜欢学习~~</code></pre><hr><h2 id="待办事项"><a href="#待办事项" class="headerlink" title="待办事项"></a>待办事项</h2><p><strong>语法符号</strong>：<code>- []</code></p><p><strong>效果</strong></p><ul><li><input checked="" disabled="" type="checkbox"> 待办事项1</li><li><input disabled="" type="checkbox"> 待办事项2</li></ul><p><strong>代码</strong></p><pre><code>- [x] 待办事项1- [ ] 待办事项2</code></pre><hr><h2 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h2><p><strong>语法符号</strong>：<code>[超链接显示名](超链接地址 &quot;超链接title&quot;)</code></p><p><strong>效果</strong></p><p>这是一个链接 <a href="https://markdown.com.cn/" title="最好的markdown教程">Markdown语法</a>。</p><p>可以使用<code>&lt;&gt;</code>括起来链接或邮箱地址：<a href="mailto:&#x72;&#111;&#115;&#x65;&#98;&#x7a;&#105;&#64;&#102;&#111;&#120;&#109;&#97;&#105;&#x6c;&#46;&#x63;&#x6f;&#x6d;">&#x72;&#111;&#115;&#x65;&#98;&#x7a;&#105;&#64;&#102;&#111;&#120;&#109;&#97;&#105;&#x6c;&#46;&#x63;&#x6f;&#x6d;</a></p><p><a href="https://bzi-han.github.io/" title="Bzi-Han&#39;s blog">占位链接</a></p><p>引用导航1<a href="%E8%BF%99%E9%87%8C%E5%8F%AF%E4%BB%A5%E5%86%99%E5%9C%A8%E9%A1%B5%E9%9D%A2%E4%B8%AD%E7%9A%84%E4%BB%BB%E4%BD%95%E5%9C%B0%E6%96%B9">^1</a><br>引用导航2<a href="https://bzi-han.github.io/">^2</a></p><p><strong>代码</strong></p><pre><code>这是一个链接 [Markdown语法](https://markdown.com.cn &quot;最好的markdown教程&quot;)。可以使用`&lt;&gt;`括起来链接或邮箱地址：&lt;rosebzi@foxmail.com&gt;[占位链接][reservelink][reservelink]: https://bzi-han.github.io/ &quot;Bzi-Han&#39;s blog&quot;引用导航1[^1]引用导航2[^2][^1]: 这里可以写在页面中的任何地方[^2]: https://bzi-han.github.io/</code></pre><hr><h2 id="图片"><a href="#图片" class="headerlink" title="图片"></a>图片</h2><p><strong>语法符号</strong>：<code>![图片alt](图片链接 &quot;图片title&quot;)</code></p><p><strong>效果</strong></p><p>只显示图片</p><p><img src="https://s1.ax1x.com/2020/08/27/dfT9Dx.gif" alt="插画" title="image"></p><p>链接与图片并用，点击图片可跳转</p><p><a href="https://baike.baidu.com/item/ASCII/309296"><img src="https://s1.ax1x.com/2022/04/17/LU1KxI.md.png" alt="ASCII" title="ascii"></a></p><p><strong>代码</strong></p><pre><code>只显示图片![插画](https://s1.ax1x.com/2020/08/27/dfT9Dx.gif &quot;image&quot;)链接与图片并用，点击图片可跳转[![ASCII](https://s1.ax1x.com/2022/04/17/LU1KxI.md.png &quot;ascii&quot;)](https://baike.baidu.com/item/ASCII/309296)</code></pre><hr><h2 id="转义"><a href="#转义" class="headerlink" title="转义"></a>转义</h2><p><strong>语法符号</strong>：<code>\ &amp;xxx;</code></p><p><strong>效果</strong></p><p>&amp;nbsp;普通空格 <code>&amp;nbsp;</code><br>&amp;ensp;半角空格 <code>&amp;ensp;</code><br>&amp;emsp;全角空格 <code>&amp;emsp;</code></p><p>* 这里使用<code>\</code>转义了<code>*</code>符号</p><p><strong>代码</strong></p><pre><code>&amp;nbsp;普通空格 `&amp;nbsp;`  &amp;ensp;半角空格 `&amp;ensp;`  &amp;emsp;全角空格 `&amp;emsp;`\* 这里使用`\`转义了`*`符号</code></pre><hr><h2 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h2><p><strong>语法符号</strong>：<code>| : -</code></p><p><strong>效果</strong></p><table><thead><tr><th align="center">第一列</th><th align="left">第二列</th><th align="right">第三列</th></tr></thead><tbody><tr><td align="center">center aligment</td><td align="left">left aligment</td><td align="right">right aligment</td></tr><tr><td align="center">data1</td><td align="left">data2</td><td align="right">data3</td></tr><tr><td align="center">data1</td><td align="left">data2</td><td align="right">data3</td></tr><tr><td align="center">data1</td><td align="left">data2</td><td align="right">data3</td></tr><tr><td align="center">data1</td><td align="left">data2</td><td align="right">data3</td></tr><tr><td align="center">data1</td><td align="left">data2</td><td align="right">data3</td></tr></tbody></table><p><strong>代码</strong></p><pre><code>| 第一列 | 第二列 | 第三列 || :-: | :- | -: || center aligment | left aligment | right aligment || data1 | data2 | data3 || data1 | data2 | data3 || data1 | data2 | data3 || data1 | data2 | data3 || data1 | data2 | data3 |</code></pre><hr><h2 id="内嵌HTML"><a href="#内嵌HTML" class="headerlink" title="内嵌HTML"></a>内嵌HTML</h2><p><strong>效果</strong></p><p><i>label i</i><br><a src="https://bzi-han.github.io/" style="color:#dd001b;cursor:pointer;">超链接</a></p><p><strong>代码</strong></p><pre><code>&lt;i&gt;label i&lt;/i&gt;  &lt;a src=&quot;https://bzi-han.github.io/&quot; style=&quot;color:#dd001b;cursor:pointer;&quot;&gt;超链接&lt;/a&gt;</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Markdown 是一种轻量级标记语言，它允许人们使用易读易写的纯文本格式编写文档，Markdown文件的后缀名便是“.md”。&lt;/p&gt;
&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="http://example.com/2022/03/30/hello-world/"/>
    <id>http://example.com/2022/03/30/hello-world/</id>
    <published>2022-03-30T02:06:52.211Z</published>
    <updated>2022-03-30T02:06:52.212Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre><code class="bash">$ hexo new &quot;My New Post&quot;</code></pre><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre><code class="bash">$ hexo server</code></pre><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre><code class="bash">$ hexo generate</code></pre><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre><code class="bash">$ hexo deploy</code></pre><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.io/docs/&quot;&gt;documentation&lt;/a&gt; for</summary>
      
    
    
    
    
  </entry>
  
</feed>
