<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Bzi-Han的博客</title>
  
  <subtitle>Bzi-Han&#39;s blog</subtitle>
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2022-04-27T19:01:07.405Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>Bzi-Han</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>[编程] 在C++中实现一个内存池与几种垃圾回收机制(GC策略)</title>
    <link href="http://example.com/2022/04/28/%E7%BC%96%E7%A8%8B-%E5%9C%A8C-%E4%B8%AD%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84%E5%86%85%E5%AD%98%E6%B1%A0/"/>
    <id>http://example.com/2022/04/28/%E7%BC%96%E7%A8%8B-%E5%9C%A8C-%E4%B8%AD%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84%E5%86%85%E5%AD%98%E6%B1%A0/</id>
    <published>2022-04-28T04:04:16.000Z</published>
    <updated>2022-04-27T19:01:07.405Z</updated>
    
    <content type="html"><![CDATA[<p>在特定情况下使用内存池可显著提高性能。</p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本文仅供学习探讨之用，如果侵犯了您的权益请联系我删除。</p><h2 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h2><ol><li><a href="https://code.visualstudio.com/" title="Visual Studio Code Official">Visual Studio Code</a></li><li><a href="http://graphviz.org/" title="Graphviz Official">Graphviz</a></li></ol><h2 id="需求与思考"><a href="#需求与思考" class="headerlink" title="需求与思考"></a>需求与思考</h2><ol><li>可限定内存池最大可向系统申请的内存大小</li><li>尽量保证池中的内存单元都在连续的内存上</li><li>内存池每次可申请任意大小的内存</li><li>进行内存的申请时若内存池的空闲空间不足且所需内存未超过内存池最大限定可申请的内存时将进行动态扩容</li><li>内存单元释放的同时进行临近内存碎片的合并</li><li>当前需要申请的内存加上已申请的内存若超过限定最大可向系统申请的内存大小时抛出异常</li></ol><ul><li>Garbage Collection<ul><li>内存标记算法</li><li>内存标记整理算法</li><li>内存分代标记整理算法</li></ul></li><li>当前需要申请的内存加上已申请的内存若超过限定最大可向系统申请的内存大小时启动GC进行垃圾回收</li><li>若启动GC后仍无法分配内存则抛出异常</li></ul><h2 id="内存池数据结构"><a href="#内存池数据结构" class="headerlink" title="内存池数据结构"></a>内存池数据结构</h2><pre><code>// 内存单元struct MemoryUnit&#123;    uint8_t *data;        // 内存单元的数据地址    size_t size;          // 内存的数据大小    MemoryBlock *block;   // 内存单元所属的内存块    MemoryUnit *nextUnit; // 下一个内存单元    MemoryUnit *prevUnit; // 上一个内存单元&#125;;// 内存块struct MemoryBlock&#123;    uint8_t *data;          // 内存块的数据地址    size_t size;            // 内存块的数据大小    size_t freeTotal;       // 内存块中剩余的空闲内存大小    MemoryUnit *freeList;   // 内存块中的空闲内存单元    MemoryUnit *usedList;   // 内存块中的已使用内存单元    MemoryBlock *nextBlock; // 下一个内存块    MemoryBlock *prevBlock; // 上一个内存块&#125;;// 内存池struct MemoryPool&#123;    size_t systemPageSize; // 当前操作系统的内存页定义大小    size_t blockMinSize;   // 申请内存块时至少申请不能小于块最小大小    size_t poolMaxSize;    // 内存池的最大可向系统申请的内存大小    size_t poolSize;       // 内存池的当前大小    MemoryBlock *blocks;   // 内存块单向循环链表&#125;;</code></pre><h2 id="需求的解决方案"><a href="#需求的解决方案" class="headerlink" title="需求的解决方案"></a>需求的解决方案</h2><ol><li>结构体<code>MemoryPool</code>的成员<code>poolMaxSize</code>与<code>poolSize</code>用于对比并限定最大可申请的内存大小</li><li>结构体<code>MemoryPool</code>的成员<code>blockMinSize</code>用于确保单次申请过小的内存单元导致过多的不连续内存块</li><li>结构体<code>MemoryUnit</code>的成员<code>size</code>用于存放当前内存单元所使用的内存大小</li><li>若当前条件满足动态扩容的条件时，向系统申请新的内存块并使用头插法插入结构体<code>MemoryPool</code>的成员<code>blocks</code>链表中，这也是将其设计为单项循环链表的原因。与此同此还要更新成员<code>poolSize</code>的数值。</li><li>内存碎片的合并将会在内存单元释放时自动进行<strong>临近</strong>单元合并，这也是结构体<code>MemoryUnit</code>设计为双向链表的原因之一</li><li>使用当前想要申请的内存大小加上结构体<code>MemoryPool</code>的成员<code>poolSize</code>的数值进行判断即可</li></ol><h2 id="内存池代码定义与实现"><a href="#内存池代码定义与实现" class="headerlink" title="内存池代码定义与实现"></a>内存池代码定义与实现</h2><p>类<code>MemoryPool</code>的定义</p><pre><code>class MemoryPool&#123;public:    struct MemoryBlock;    struct MemoryUnit    &#123;        uint8_t *data;        size_t size;        MemoryBlock *block;        MemoryUnit *nextUnit;        MemoryUnit *prevUnit;    &#125;;    struct MemoryBlock    &#123;        uint8_t *data;        size_t size;        size_t freeTotal;        MemoryUnit *freeList;        MemoryUnit *usedList;        MemoryBlock *nextBlock;        MemoryBlock *prevBlock;    &#125;;    using unit_t = MemoryUnit;    using block_t = MemoryBlock;public:    MemoryPool(size_t poolMaxSize = 128 * 1024 * 1024, size_t blockMinSize = 4 * 1024 * 1024);    ~MemoryPool();    void *alloc(size_t size);    void free(void *data);private:    block_t *allocBlock(size_t size);    void freeBlock(block_t *block);    unit_t *allocUnit(size_t size);    void freeUnit(unit_t *unit);private:    size_t m_systemPageSize = 0;    size_t m_poolMaxSize = 0;    size_t m_blockMinSize = 0;    size_t m_poolSize = 0;    block_t *m_blocks = nullptr;&#125;;</code></pre><p>对于<code>MemoryPool::allocBlock</code>方法的实现</p><pre><code>MemoryPool::block_t *MemoryPool::allocBlock(size_t size)&#123;    // allocate memory block    auto alignedSize = size + sizeof(block_t) + sizeof(unit_t);    alignedSize = (alignedSize + (m_systemPageSize - 1)) &amp; ~(m_systemPageSize - 1); // align to system page size    if (m_blockMinSize &gt; alignedSize)        alignedSize = m_blockMinSize;    auto block = reinterpret_cast&lt;block_t *&gt;(::VirtualAlloc(nullptr, alignedSize, MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE));    if (nullptr == block)        return nullptr;    // initialize memory block    block-&gt;data = reinterpret_cast&lt;uint8_t *&gt;(block) + sizeof(block_t);    block-&gt;size = alignedSize - sizeof(block_t);    auto dataPosition = block-&gt;data;    // initialize memory used unit    block-&gt;usedList = nullptr;    // initialize memory free unit    block-&gt;freeList = reinterpret_cast&lt;unit_t *&gt;(dataPosition);    dataPosition += sizeof(unit_t);    block-&gt;freeList-&gt;data = dataPosition;    block-&gt;freeList-&gt;size = block-&gt;size - (dataPosition - block-&gt;data);    block-&gt;freeList-&gt;nextUnit = block-&gt;freeList;    block-&gt;freeList-&gt;prevUnit = block-&gt;freeList;    block-&gt;freeList-&gt;block = block;    block-&gt;freeTotal = block-&gt;freeList-&gt;size;    // add to block list    if (nullptr != m_blocks)    &#123;        block-&gt;prevBlock = m_blocks-&gt;prevBlock;        block-&gt;nextBlock = m_blocks;        m_blocks-&gt;prevBlock-&gt;nextBlock = block;        m_blocks-&gt;prevBlock = block;    &#125;    else    &#123;        block-&gt;prevBlock = block;        block-&gt;nextBlock = block;        m_blocks = block;    &#125;    // update pool size    m_poolSize += block-&gt;size + sizeof(block_t);    return block;&#125;</code></pre><p>这里在申请内存时确保与当前操作系统内存页定义大小对齐。</p><p>对于<code>MemoryPool::freeBlock</code>方法的实现</p><pre><code>void MemoryPool::freeBlock(block_t *block)&#123;    // remove from block list    if (m_blocks-&gt;prevBlock == block &amp;&amp; m_blocks-&gt;nextBlock == block)        m_blocks = nullptr;    else    &#123;        block-&gt;prevBlock-&gt;nextBlock = block-&gt;nextBlock;        block-&gt;nextBlock-&gt;prevBlock = block-&gt;prevBlock;        if (m_blocks == block)            m_blocks = block-&gt;nextBlock;    &#125;    // update pool size    m_poolSize -= block-&gt;size + sizeof(block_t);    // free memory block    ::VirtualFree(block, 0, MEM_RELEASE);&#125;</code></pre><p>对于<code>MemoryPool::allocUnit</code>方法的实现</p><pre><code>MemoryPool::unit_t *MemoryPool::allocUnit(size_t size)&#123;    // check if no block is available    if (nullptr == m_blocks)        return nullptr;    // allocate memory unit    auto block = m_blocks; // first block    do    &#123;        // check if is there no enough memory in the block        if (size &gt; block-&gt;freeTotal)        &#123;            block = block-&gt;nextBlock;            continue;        &#125;        auto unit = block-&gt;freeList; // first free unit        do        &#123;            // check if is there no enough memory in the unit            if (size &gt; unit-&gt;size)            &#123;                unit = unit-&gt;nextUnit;                continue;            &#125;            // check if unit size is more than wanted size, split unit            if (unit-&gt;size &gt; size + sizeof(unit_t))            &#123;                auto newUnit = reinterpret_cast&lt;unit_t *&gt;(unit-&gt;data + size);                newUnit-&gt;data = unit-&gt;data + size + sizeof(unit_t);                newUnit-&gt;size = unit-&gt;size - size - sizeof(unit_t);                newUnit-&gt;nextUnit = unit-&gt;nextUnit;                newUnit-&gt;prevUnit = unit;                newUnit-&gt;block = unit-&gt;block;                unit-&gt;nextUnit-&gt;prevUnit = newUnit;                unit-&gt;nextUnit = newUnit;                unit-&gt;size = size;            &#125;            // remove unit from free list            unit-&gt;prevUnit-&gt;nextUnit = unit-&gt;nextUnit;            unit-&gt;nextUnit-&gt;prevUnit = unit-&gt;prevUnit;            if (block-&gt;freeList == unit)                block-&gt;freeList = unit-&gt;nextUnit;            // add unit to used list            if (nullptr == block-&gt;usedList)            &#123;                block-&gt;usedList = unit;                unit-&gt;nextUnit = unit;                unit-&gt;prevUnit = unit;            &#125;            else            &#123;                unit-&gt;nextUnit = block-&gt;usedList;                unit-&gt;prevUnit = block-&gt;usedList-&gt;prevUnit;                block-&gt;usedList-&gt;prevUnit-&gt;nextUnit = unit;                block-&gt;usedList-&gt;prevUnit = unit;            &#125;            // update free total            block-&gt;freeTotal -= unit-&gt;size;            return unit;        &#125; while (unit != block-&gt;freeList);    &#125; while (block != m_blocks);    return nullptr;&#125;</code></pre><p>对于<code>MemoryPool::freeUnit</code>方法的实现</p><pre><code>void MemoryPool::freeUnit(unit_t *unit)&#123;    auto freeSize = unit-&gt;size;    // remove unit from used list    if (unit-&gt;prevUnit == unit &amp;&amp; unit-&gt;nextUnit == unit)        unit-&gt;block-&gt;usedList = nullptr;    else    &#123;        unit-&gt;prevUnit-&gt;nextUnit = unit-&gt;nextUnit;        unit-&gt;nextUnit-&gt;prevUnit = unit-&gt;prevUnit;        if (unit-&gt;block-&gt;usedList == unit)            unit-&gt;block-&gt;usedList = unit-&gt;nextUnit;    &#125;    // add the unit to the free list, order by address    if (nullptr == unit-&gt;block-&gt;freeList)    &#123;        unit-&gt;nextUnit = unit;        unit-&gt;prevUnit = unit;        unit-&gt;block-&gt;freeList = unit;    &#125;    else    &#123;        auto prevUnit = unit-&gt;block-&gt;freeList;        auto nextUnit = unit-&gt;block-&gt;freeList-&gt;nextUnit;        if (prevUnit == prevUnit-&gt;prevUnit &amp;&amp; prevUnit == prevUnit-&gt;nextUnit)        &#123;            // combine units if is there near units            if (unit-&gt;data + unit-&gt;size == reinterpret_cast&lt;uint8_t *&gt;(nextUnit)) // combine next unit            &#123;                unit-&gt;size += nextUnit-&gt;size + sizeof(unit_t);                unit-&gt;nextUnit = unit;                unit-&gt;prevUnit = unit;                unit-&gt;block-&gt;freeList = unit;            &#125;            else if (prevUnit-&gt;data + prevUnit-&gt;size == reinterpret_cast&lt;uint8_t *&gt;(unit)) // combine prev unit                prevUnit-&gt;size += unit-&gt;size + sizeof(unit_t);            else // add unit to free list            &#123;                unit-&gt;nextUnit = nextUnit;                unit-&gt;prevUnit = nextUnit;                nextUnit-&gt;prevUnit = unit;                nextUnit-&gt;nextUnit = unit;                unit-&gt;block-&gt;freeList = nextUnit &lt; unit ? nextUnit : unit;            &#125;        &#125;        else        &#123;            // find insert position            while (nextUnit != unit-&gt;block-&gt;freeList &amp;&amp; nextUnit &lt; unit)            &#123;                prevUnit = nextUnit;                nextUnit = nextUnit-&gt;nextUnit;            &#125;            // combine the units if is there are near units            if (unit-&gt;data + unit-&gt;size == reinterpret_cast&lt;uint8_t *&gt;(nextUnit)) // combine next unit            &#123;                unit-&gt;size += nextUnit-&gt;size + sizeof(unit_t);                unit-&gt;nextUnit = nextUnit-&gt;nextUnit;                unit-&gt;prevUnit = nextUnit-&gt;prevUnit;                nextUnit-&gt;prevUnit-&gt;nextUnit = unit;                nextUnit-&gt;nextUnit-&gt;prevUnit = unit;                nextUnit = nextUnit-&gt;nextUnit;            &#125;            if (prevUnit-&gt;data + prevUnit-&gt;size == reinterpret_cast&lt;uint8_t *&gt;(unit)) // combine prev unit            &#123;                prevUnit-&gt;size += unit-&gt;size + sizeof(unit_t);                prevUnit-&gt;nextUnit = nextUnit;                nextUnit-&gt;prevUnit = prevUnit;            &#125;        &#125;    &#125;    // update free total    m_blocks-&gt;freeTotal += freeSize;&#125;</code></pre><p>这4个主要的方法实现好之后就是<code>MemoryPool::alloc</code>与<code>MemoryPool::free</code>两个方法的实现了，我们要做的只需要对上面4个方法进行逻辑的封装就好了。</p><p>对于<code>MemoryPool::alloc</code>方法的实现</p><pre><code>void *MemoryPool::alloc(size_t size)&#123;    if (0 == size)        return nullptr;    if (nullptr == m_blocks)        m_blocks = allocBlock(size);    auto unit = allocUnit(size);    if (nullptr == unit)    &#123;        if (size + m_poolSize &gt; m_poolMaxSize)            throw std::bad_alloc();        auto block = allocBlock(size);        if (nullptr == block)            return nullptr;        unit = allocUnit(size);        if (nullptr == unit)            return nullptr;    &#125;    return unit-&gt;data;&#125;</code></pre><p>对于<code>MemoryPool::free</code>方法的实现</p><pre><code>void MemoryPool::free(void *data)&#123;    if (nullptr == data)        return;    auto unit = reinterpret_cast&lt;unit_t *&gt;(reinterpret_cast&lt;uint8_t *&gt;(data) - sizeof(unit_t));    if (nullptr == unit)        return;    if (nullptr == unit-&gt;block)        return;    freeUnit(unit);&#125;</code></pre><p>到这里，内存池的主体已经搭建好了，那接下来就对比以下性能。</p><h2 id="性能对比"><a href="#性能对比" class="headerlink" title="性能对比"></a>性能对比</h2><p>测试用的代码如下</p><pre><code>MemoryPool g_memoryPool(1 * 1024 * 1024 * 1024);template &lt;typename runable_t&gt;struct RunTickCount&#123;    runable_t &amp;&amp;runable;    uint64_t operator()() const noexcept    &#123;        auto result = __rdtsc();        runable();        return __rdtsc() - result;    &#125;&#125;;void test01()&#123;    for (size_t i = 0; i &lt; 100; i++)    &#123;        auto data = new char[8 * 1024 * 1024];        delete[] data;    &#125;&#125;void test02()&#123;    for (size_t i = 0; i &lt; 100; i++)    &#123;        auto data = ::VirtualAlloc(nullptr, 8 * 1024 * 1024, MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE);        ::VirtualFree(data, 0, MEM_RELEASE);    &#125;&#125;void test03()&#123;    for (size_t i = 0; i &lt; 100; i++)    &#123;        auto data = g_memoryPool.alloc(8 * 1024 * 1024);        g_memoryPool.free(data);    &#125;&#125;void test04()&#123;    for (size_t i = 0; i &lt; 100; i++)        auto data = new char[8 * 1024 * 1024];&#125;void test05()&#123;    for (size_t i = 0; i &lt; 100; i++)        auto data = ::VirtualAlloc(nullptr, 8 * 1024 * 1024, MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE);&#125;void test06()&#123;    for (size_t i = 0; i &lt; 100; i++)        auto data = g_memoryPool.alloc(8 * 1024 * 1024);&#125;int main()&#123;    try    &#123;        std::cout &lt;&lt; &quot;[*] test 100 loop with allocating and freeing the memory of 8MB&quot; &lt;&lt; std::endl;        std::cout &lt;&lt; &quot;[=] std new-delete time: &quot; &lt;&lt; RunTickCount&lt;decltype(test01)&gt;&#123;test01&#125;() &lt;&lt; &quot; ticks&quot; &lt;&lt; std::endl;        std::cout &lt;&lt; &quot;[=] windows virtualAlloc-Free time: &quot; &lt;&lt; RunTickCount&lt;decltype(test02)&gt;&#123;test02&#125;() &lt;&lt; &quot; ticks&quot; &lt;&lt; std::endl;        std::cout &lt;&lt; &quot;[=] memory pool alloc-free time: &quot; &lt;&lt; RunTickCount&lt;decltype(test03)&gt;&#123;test03&#125;() &lt;&lt; &quot; ticks&quot; &lt;&lt; std::endl;        std::cout &lt;&lt; &quot;[=] std just new time: &quot; &lt;&lt; RunTickCount&lt;decltype(test04)&gt;&#123;test04&#125;() &lt;&lt; &quot; ticks&quot; &lt;&lt; std::endl;        std::cout &lt;&lt; &quot;[=] windows just virtualAlloc time: &quot; &lt;&lt; RunTickCount&lt;decltype(test05)&gt;&#123;test05&#125;() &lt;&lt; &quot; ticks&quot; &lt;&lt; std::endl;        std::cout &lt;&lt; &quot;[=] memory pool just alloc time: &quot; &lt;&lt; RunTickCount&lt;decltype(test06)&gt;&#123;test06&#125;() &lt;&lt; &quot; ticks&quot; &lt;&lt; std::endl;        std::cout &lt;&lt; &quot;[+] test passed&quot; &lt;&lt; std::endl;    &#125;    catch (const std::exception &amp;e)    &#123;        std::cerr &lt;&lt; &quot;[-] &quot; &lt;&lt; e.what() &lt;&lt; std::endl;    &#125;    return 0;&#125;</code></pre><p>编译使用的参数<code>cl .\test_memorypool.cc /O2 /EHsc /std:c++20</code></p><p><img src="/images/1650222097.jpg" alt="性能测试结果"></p><p>这里仅用WindowsAPI与内存池的性能做比较，对于<code>new</code>与<code>delete</code>就当看个乐呵。</p><p>可以看到，内存池在循环申请与释放的测试中一骑绝尘。<br>这是因为在<code>freeUnit</code>时我们并没有真的把内存还给系统，而是交给内存池来保管。<br>而第二次进入<code>allocUnit</code>时因为还有可用的内存，所以可以直接分配，不需要向系统申请新的内存！</p><p>但是内存池在仅申请内存不释放的测试中被WindowsAPI所击败，这是因为仅申请内存的话调用WindowsAPI仅需一次<code>VirtualAlloc</code>的费用。<br>而内存池每次进行动态扩容时，不仅需要一次<code>VirtualAlloc</code>的费用，还需要对内存池中的各项参数进行调整，所以导致费用升高。</p><p>那么是因为这个内存池太垃圾了？其实不然，我们默认设定了内存池的最小块大小时4MB，而每次申请的内存大小为8MB，这就导致了内存池需要不断地进行动态扩容。<br>如果我们这里把内存池的块内存大小设置的更大，或者说我们每次申请的内存大小并不超过默认块大小，那么情况又会有所不同。</p><p>我们把每次申请的内存大小修改为4KB</p><pre><code>void test05()&#123;    for (size_t i = 0; i &lt; 100; i++)        auto data = ::VirtualAlloc(nullptr, 4 * 1024, MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE);&#125;void test06()&#123;    for (size_t i = 0; i &lt; 100; i++)        auto data = g_memoryPool.alloc(4 * 1024);&#125;</code></pre><p>再来看结果</p><p><img src="/images/1650222098.jpg" alt="性能测试结果"></p><p>这次轮到WindowsAPI被内存池击败了。由此可见，并不是所有情况下内存池都是适用的，仅在特定情况下内存池能较好的发挥其作用。</p><p>接下来我们写一段程序来dump内存池的内存结构，了解一下在<code>freeUnit</code>时究竟发生了什么。</p><h2 id="内存池释放单元时的Graphviz图"><a href="#内存池释放单元时的Graphviz图" class="headerlink" title="内存池释放单元时的Graphviz图"></a>内存池释放单元时的Graphviz图</h2><p>先修改一下代码，创建一个新的类<code>MemoryPoolX</code>并继承<code>MemoryPool</code>，我们将在这里类里进行dump</p><pre><code>class MemoryPoolX final : public MemoryPool&#123;public:    MemoryPoolX(size_t poolMaxSize = 128 * 1024 * 1024, size_t blockMinSize = 4 * 1024 * 1024)        : MemoryPool(poolMaxSize, blockMinSize)    &#123;    &#125;    ~MemoryPoolX()    &#123;    &#125;    void dumpGraphviz()    &#123;        std::ofstream out(&quot;test_memorypool.dot&quot;);        out &lt;&lt; &quot;digraph DataStructure &#123;\n&quot;;        out &lt;&lt; &quot;node [shape=record];\n&quot;;        out &lt;&lt; &quot;\&quot;&quot; &lt;&lt; this &lt;&lt; &quot;\&quot; [label=\&quot;&#123;&lt;f0&gt;MemoryPool|&quot;            &lt;&lt; this &lt;&lt; &quot;|&quot;            &lt;&lt; &quot;&#123;systemPageSize|&quot; &lt;&lt; m_systemPageSize &lt;&lt; &quot;&#125;|&quot;            &lt;&lt; &quot;&#123;poolMaxSize|&quot; &lt;&lt; m_poolMaxSize &lt;&lt; &quot;&#125;|&quot;            &lt;&lt; &quot;&#123;blockMinSize|&quot; &lt;&lt; m_blockMinSize &lt;&lt; &quot;&#125;|&quot;            &lt;&lt; &quot;&#123;poolSize|&quot; &lt;&lt; m_poolSize &lt;&lt; &quot;&#125;|&quot;            &lt;&lt; &quot;&#123;&lt;f1&gt;blocks|&quot; &lt;&lt; m_blocks &lt;&lt; &quot;&#125;&quot;            &lt;&lt; &quot;&#125;\&quot; color=\&quot;#409eff\&quot;];\n&quot;;        block_t *block = m_blocks;        do        &#123;            out &lt;&lt; &quot;\&quot;&quot; &lt;&lt; block &lt;&lt; &quot;\&quot; [label=\&quot;&#123;&lt;f0&gt;MemoryBlock|&quot;                &lt;&lt; block &lt;&lt; &quot;|&quot;                &lt;&lt; &quot;&#123;data|&quot; &lt;&lt; block-&gt;data &lt;&lt; &quot;&#125;|&quot;                &lt;&lt; &quot;&#123;size|&quot; &lt;&lt; block-&gt;size &lt;&lt; &quot;&#125;|&quot;                &lt;&lt; &quot;&#123;freeTotal|&quot; &lt;&lt; block-&gt;freeTotal &lt;&lt; &quot;&#125;|&quot;                &lt;&lt; &quot;&#123;&lt;f1&gt;freeList|&quot; &lt;&lt; block-&gt;freeList &lt;&lt; &quot;&#125;|&quot;                &lt;&lt; &quot;&#123;&lt;f2&gt;usedList|&quot; &lt;&lt; block-&gt;usedList &lt;&lt; &quot;&#125;|&quot;                &lt;&lt; &quot;&#123;&lt;f3&gt;nextBlock|&quot; &lt;&lt; block-&gt;nextBlock &lt;&lt; &quot;&#125;|&quot;                &lt;&lt; &quot;&#123;&lt;f4&gt;prevBlock|&quot; &lt;&lt; block-&gt;prevBlock &lt;&lt; &quot;&#125;&quot;                &lt;&lt; &quot;&#125;\&quot; color=\&quot;#909399\&quot;];\n&quot;;            unit_t *unit = block-&gt;usedList;            do            &#123;                out &lt;&lt; &quot;\&quot;&quot; &lt;&lt; unit &lt;&lt; &quot;\&quot; [label=\&quot;&#123;&lt;f0&gt;MemoryUnit|&quot;                    &lt;&lt; unit &lt;&lt; &quot;|&quot;                    &lt;&lt; &quot;&#123;data|&quot; &lt;&lt; unit-&gt;data &lt;&lt; &quot;&#125;|&quot;                    &lt;&lt; &quot;&#123;size|&quot; &lt;&lt; unit-&gt;size &lt;&lt; &quot;&#125;|&quot;                    &lt;&lt; &quot;&#123;block|&quot; &lt;&lt; unit-&gt;block &lt;&lt; &quot;&#125;|&quot;                    &lt;&lt; &quot;&#123;&lt;f1&gt;nextUnit|&quot; &lt;&lt; unit-&gt;nextUnit &lt;&lt; &quot;&#125;|&quot;                    &lt;&lt; &quot;&#123;&lt;f2&gt;prevUnit|&quot; &lt;&lt; unit-&gt;prevUnit &lt;&lt; &quot;&#125;&quot;                    &lt;&lt; &quot;&#125;\&quot; color=\&quot;#f56c6c\&quot;];\n&quot;;                if (unit == block-&gt;usedList)                &#123;                    out &lt;&lt; &quot;subgraph cluster_&quot; &lt;&lt; unit &lt;&lt; &quot; &#123;\n&quot;                        &lt;&lt; &quot;label=\&quot;usedList\&quot;;\n&quot;;                    out &lt;&lt; &quot;\&quot;&quot; &lt;&lt; block &lt;&lt; &quot;\&quot;:f2 -&gt; \&quot;&quot; &lt;&lt; unit &lt;&lt; &quot;\&quot;:f0 [style=\&quot;dotted\&quot; color=\&quot;#0000ff\&quot;];\n&quot;;                &#125;                else                    out &lt;&lt; &quot;\&quot;&quot; &lt;&lt; unit-&gt;nextUnit &lt;&lt; &quot;\&quot;:f2 -&gt; \&quot;&quot; &lt;&lt; unit &lt;&lt; &quot;\&quot;:f0 [style=\&quot;dotted\&quot; color=\&quot;#0000ff\&quot;];\n&quot;;                unit = unit-&gt;nextUnit;            &#125; while (unit != block-&gt;usedList);            out &lt;&lt; &quot;&#125;\n&quot;;            unit = block-&gt;freeList;            do            &#123;                out &lt;&lt; &quot;\&quot;&quot; &lt;&lt; unit &lt;&lt; &quot;\&quot; [label=\&quot;&#123;&lt;f0&gt;MemoryUnit|&quot;                    &lt;&lt; unit &lt;&lt; &quot;|&quot;                    &lt;&lt; &quot;&#123;data|&quot; &lt;&lt; unit-&gt;data &lt;&lt; &quot;&#125;|&quot;                    &lt;&lt; &quot;&#123;size|&quot; &lt;&lt; unit-&gt;size &lt;&lt; &quot;&#125;|&quot;                    &lt;&lt; &quot;&#123;block|&quot; &lt;&lt; unit-&gt;block &lt;&lt; &quot;&#125;|&quot;                    &lt;&lt; &quot;&#123;&lt;f1&gt;nextUnit|&quot; &lt;&lt; unit-&gt;nextUnit &lt;&lt; &quot;&#125;|&quot;                    &lt;&lt; &quot;&#123;&lt;f2&gt;prevUnit|&quot; &lt;&lt; unit-&gt;prevUnit &lt;&lt; &quot;&#125;&quot;                    &lt;&lt; &quot;&#125;\&quot; color=\&quot;#67c23a\&quot;];\n&quot;;                if (unit == block-&gt;freeList)                &#123;                    out &lt;&lt; &quot;subgraph cluster_&quot; &lt;&lt; unit &lt;&lt; &quot; &#123;\n&quot;                        &lt;&lt; &quot;label=\&quot;freeList\&quot;;\n&quot;;                    out &lt;&lt; &quot;\&quot;&quot; &lt;&lt; block &lt;&lt; &quot;\&quot;:f1 -&gt; \&quot;&quot; &lt;&lt; unit &lt;&lt; &quot;\&quot;:f0 [style=\&quot;dashed\&quot; color=\&quot;#0000ff\&quot;];\n&quot;;                &#125;                else                    out &lt;&lt; &quot;\&quot;&quot; &lt;&lt; unit-&gt;nextUnit &lt;&lt; &quot;\&quot;:f1 -&gt; \&quot;&quot; &lt;&lt; unit &lt;&lt; &quot;\&quot;:f0 [style=\&quot;dashed\&quot; color=\&quot;#0000ff\&quot;];\n&quot;;                unit = unit-&gt;nextUnit;            &#125; while (unit != block-&gt;freeList);            out &lt;&lt; &quot;&#125;\n&quot;;            if (block == m_blocks)                out &lt;&lt; &quot;\&quot;&quot; &lt;&lt; this &lt;&lt; &quot;\&quot;:f1 -&gt; \&quot;&quot; &lt;&lt; block &lt;&lt; &quot;\&quot;:f0 [color=\&quot;#0000ff\&quot;];\n&quot;;            else                out &lt;&lt; &quot;\&quot;&quot; &lt;&lt; block-&gt;nextBlock &lt;&lt; &quot;\&quot;:f3 -&gt; \&quot;&quot; &lt;&lt; block &lt;&lt; &quot;\&quot;:f0 [color=\&quot;#0000ff\&quot;];\n&quot;;            block = block-&gt;nextBlock;        &#125; while (block != m_blocks);        out &lt;&lt; &quot;&#125;&quot;;        out.close();    &#125;&#125;;MemoryPoolX g_memoryPool(1 * 1024 * 1024 * 1024);void dumpGraphviz()&#123;    std::vector&lt;void *&gt; datas;    for (size_t i = 0; i &lt; 6; i++)        datas.push_back(g_memoryPool.alloc(i * 1024));    datas.push_back(g_memoryPool.alloc(8 * 1024 * 1024));    datas.push_back(g_memoryPool.alloc(8 * 1024 * 1024));    g_memoryPool.dumpGraphviz();    std::cout &lt;&lt; &quot;dump01&quot; &lt;&lt; std::endl;    getchar();    g_memoryPool.free(datas[2]);    g_memoryPool.dumpGraphviz();    std::cout &lt;&lt; &quot;dump02&quot; &lt;&lt; std::endl;    getchar();    g_memoryPool.free(datas[3]);    g_memoryPool.dumpGraphviz();    std::cout &lt;&lt; &quot;dump03&quot; &lt;&lt; std::endl;    getchar();&#125;</code></pre><p>然后在<code>main</code>函数中调用<code>dumpGraphviz</code>就好了，直接看结果(若看不清可对着图片右键，然后选择<code>在新标签页中打开图片</code>)</p><p>申请完内存后的内存布局情况，其中红色为已使用的，绿色为空闲的</p><p><img src="/images/1650222099.jpeg" alt="graphvizDump01"></p><p>释放大小为<code>2048</code>的这个内存单元后的内存布局情况</p><p><img src="/images/1650222100.jpeg" alt="graphvizDump02"></p><p>可以看到第一个内存块的空闲内存单元链表中多出了一个大小为<code>2048</code>的空闲内存单元，因为其与大小为<code>4178648</code>的空闲内存单元并不临近，所以并没有进行内存单元(碎片)的合并。</p><p>释放大小为<code>3072</code>的这个内存单元后的内存布局情况</p><p><img src="/images/1650222101.jpeg" alt="graphvizDump03"></p><p>在释放大小为<code>3072</code>的内存单元的同时检测到其与大小为<code>2048</code>的空闲内存单元为临近内存单元，所以会进行碎片的合并。<br>为什么会生成一个大小为<code>5160</code>的空闲内存单元而不是大小为<code>5120</code>的单元是因为合并成一个时需要丢弃被合并的内存单元的头部信息，而头部信息占用的内存大小为<code>40</code>字节，因此合并后就是<code>5160</code>字节。其他单元依此类推。</p><p>到这里，内存池的内容基本就讲完了，接下来我们来看看垃圾回收机制。</p><h2 id="Garbage-Collection"><a href="#Garbage-Collection" class="headerlink" title="Garbage Collection"></a>Garbage Collection</h2><p><strong>注意：</strong><code>这里所说的标记使用的是引用计数的方式</code></p><p>其实个人觉得在C++中使用GC的意义不大，虽然会更方便一点，但是使用智能指针与作用域限定进行自动内存管理其实也差不多，所以GC这里的内容就算是写着玩的了。</p><p>想要在C++中实现GC，我们要做的第一件事情是要对<code>raw pointer</code>进行封装，因为如果使用的是<code>raw pointer</code>的话，我们无法对数据的引用进行更新，也无法跟踪指针的使用。例如：GC运行后仍有未知代码对被GC的指针进行访问，造成程序的崩溃。</p><h3 id="原始指针的封装"><a href="#原始指针的封装" class="headerlink" title="原始指针的封装"></a>原始指针的封装</h3><p>我们这里使用引用计数的方式来跟踪指针，上代码。</p><p>先给内存单元添加三个属性</p><pre><code>// 内存单元struct MemoryUnit&#123;    uint8_t *data;        // 内存单元的数据地址    size_t size;          // 内存的数据大小    size_t refIndex;      // 内存单元引用表的对应的索引(用于内存整理算法更新引用)    size_t refCount;      // 内存单元引用计数(用于内存标记算法)    size_t aliveCount;    // 内存单元的GC存活计数(用于分代理论)    MemoryBlock *block;   // 内存单元所属的内存块    MemoryUnit *nextUnit; // 下一个内存单元    MemoryUnit *prevUnit; // 上一个内存单元&#125;;</code></pre><p>然后给<code>MemoryPool</code>添加一个成员<code>std::unordered_map&lt;size_t, unit_t *&gt; m_refUnits</code>，用来记录用于整理算法的指针引用。并添加一个<code>[]</code>运算符的重载</p><pre><code>unit_t *operator[](size_t index)&#123;    return m_refUnits[index];&#125;</code></pre><p>方便对于内存单元的访问。</p><p>原始指针的封装类</p><pre><code>class GCMemory&#123;public:    friend MemoryPool;public:    GCMemory(MemoryPool *pool, size_t unitIndex)        : m_pool(pool),          m_unitIndex(unitIndex)    &#123;        (*m_pool)[m_unitIndex]-&gt;refCount++;    &#125;    GCMemory()        : m_pool(nullptr),          m_unitIndex(0)    &#123;    &#125;    ~GCMemory()    &#123;        if (nullptr == m_pool)            return;        auto unit = (*m_pool)[m_unitIndex];        if (nullptr != unit)            unit-&gt;refCount--;    &#125;    GCMemory(GCMemory &amp;other)        : m_pool(other.m_pool)    &#123;        (*m_pool)[m_unitIndex]-&gt;refCount++;    &#125;    GCMemory(GCMemory &amp;&amp;other)        : m_pool(other.m_pool)    &#123;        other.m_pool = nullptr;    &#125;    GCMemory &amp;operator=(GCMemory &amp;other)    &#123;        m_pool = other.m_pool;        (*m_pool)[m_unitIndex]-&gt;refCount++;        return *this;    &#125;    GCMemory &amp;operator=(GCMemory &amp;&amp;other)    &#123;        m_pool = other.m_pool;        other.m_pool = nullptr;        return *this;    &#125;    GCMemory &amp;operator++()    &#123;        (*m_pool)[m_unitIndex]-&gt;refCount++;        return *this;    &#125;    GCMemory &amp;operator--()    &#123;        auto unit = (*m_pool)[m_unitIndex];        if (unit-&gt;refCount &gt; 0)            unit-&gt;refCount--;        return *this;    &#125;    operator bool() const    &#123;        auto unit = (*m_pool)[m_unitIndex];        return nullptr != m_pool &amp;&amp; nullptr != unit &amp;&amp; unit-&gt;refCount &gt; 0;    &#125;    operator void *() const noexcept    &#123;        auto unit = (*m_pool)[m_unitIndex];        return nullptr == unit ? nullptr : unit-&gt;data;    &#125;    operator uint8_t *() const noexcept    &#123;        auto unit = (*m_pool)[m_unitIndex];        return nullptr == unit ? nullptr : unit-&gt;data;    &#125;private:    MemoryPool *m_pool;    size_t m_unitIndex;&#125;;using gc_t = GCMemory;</code></pre><p>对于<code>MemoryPool::allocGC</code>方法的实现</p><pre><code>MemoryPool::gc_t MemoryPool::allocGC(size_t size)&#123;    if (0 == size)        return &#123;&#125;;    if (nullptr == m_blocks)        m_blocks = allocBlock(size);    auto unit = allocUnit(size);    if (nullptr == unit)    &#123;        if (size + m_poolSize &gt; m_poolMaxSize)            throw std::bad_alloc();        auto block = allocBlock(size);        if (nullptr == block)            return &#123;&#125;;        unit = allocUnit(size);        if (nullptr == unit)            return &#123;&#125;;    &#125;    static size_t unitIndex = 0;    m_refUnits[unitIndex] = unit;    unit-&gt;refIndex = unitIndex++;    unit-&gt;refCount = 0;    unit-&gt;aliveCount = 0;    return gc_t(this, unit-&gt;refIndex);&#125;</code></pre><p>那么来稍微测试一下</p><p><img src="/images/1650222102.jpeg" alt="作用域测试01"></p><p><img src="/images/1650222103.jpeg" alt="作用域测试01"></p><p>可以看到，在刚申请完的时候引用计数为<code>1</code>，并在走出作用域后变为了<code>0</code>。</p><h3 id="内存标记算法"><a href="#内存标记算法" class="headerlink" title="内存标记算法"></a>内存标记算法</h3><pre><code>void MemoryPool::markedGC()&#123;    for (auto &amp;unit : m_refUnits)    &#123;        if (0 != unit.second-&gt;refCount)            continue;        freeUnit(unit.second);        unit.second = nullptr;    &#125;&#125;</code></pre><p>这个其实没什么好说的，当发生GC的时候检查内存单元的引用计数，若为<code>0</code>则表示没有使用，进行内存的回收。</p><p>看一下效果</p><p><img src="/images/1650222104.jpeg" alt="内存标记算法结果"></p><p>在这里我们手动将<code>data02</code>的引用计数<code>-1</code>来模拟无引用的情况。</p><p>可以看到，在执行GC之后引用计数为<code>0</code>的<code>data02</code>的引用指针变成了<code>nullptr</code>，说明GC运行成功。正常情况下只论标记回收算法的话内存池会产生大量的内存碎片，但我们这里在释放的时候会自动进行临近碎片的合并，所以情况其实还好。</p><p>看一下内存结构变化的<code>Graphviz</code>图，对应代码中两处<code>g_memoryPool.dumpGraphviz()</code>的调用。</p><table><thead><tr><th><img src="/images/1650222105.jpeg" alt="内存标记算法内存结构变化01"></th><th><img src="/images/1650222106.jpeg" alt="内存标记算法内存结构变化02"></th></tr></thead></table><p><strong>注意：</strong><code>对于后面将要说的两种算法来说，当前的线程池模型属于冗余设计。实际设计时因为存在整理算法，所以freeList、usedList这些都可以不要，直接使用一个成员标记最后申请的位置即可。在下次进入申请内存时仅需判断当前块是否有足够的空闲内存，如果没有则动态扩容，否则可直接返回最后申请的位置，在这种情况下算法的时间复杂度仅为O(1)</code></p><h3 id="内存标记整理算法"><a href="#内存标记整理算法" class="headerlink" title="内存标记整理算法"></a>内存标记整理算法</h3><p>在实现整理算法之前还需要两个特别重要的方法需要实现，分别是<code>suspendTheWorld</code>与<code>resumeTheWorld</code>。</p><p>在我们进行内存整理之前需要先对当前进程的除当前线程外的所有线程进行暂停，因为在我们进行整理的过程中不允许出现被整理内存被其他线程访问的情况，否则可能会导致出现数据错误甚至崩溃等问题。</p><p>上代码</p><pre><code>std::vector&lt;HANDLE&gt; MemoryPool::suspendTheWorld()&#123;    std::vector&lt;HANDLE&gt; threadHandles;    auto currentProcessId = ::GetCurrentProcessId();    auto currentThreadId = ::GetCurrentThreadId();    auto snapshotHandle = ::CreateToolhelp32Snapshot(TH32CS_SNAPTHREAD, 0);    if (nullptr != snapshotHandle)    &#123;        THREADENTRY32 threadEntry&#123;&#125;;        threadEntry.dwSize = sizeof(threadEntry);        if (!::Thread32First(snapshotHandle, &amp;threadEntry))            return threadHandles;        do        &#123;            if (currentProcessId != threadEntry.th32OwnerProcessID || currentThreadId == threadEntry.th32ThreadID)                continue;            auto handle = ::OpenThread(THREAD_ALL_ACCESS, false, threadEntry.th32ThreadID);            if (nullptr == handle)                throw std::exception(&quot;OpenThread failed&quot;);            if (-1 == ::SuspendThread(handle))                throw std::exception(&quot;SuspendThread failed&quot;);            threadHandles.push_back(handle);        &#125; while (::Thread32Next(snapshotHandle, &amp;threadEntry));        ::CloseHandle(snapshotHandle);    &#125;    return threadHandles;&#125;void MemoryPool::resumeTheWorld(std::vector&lt;HANDLE&gt; &amp;handles)&#123;    for (auto &amp;handle : handles)    &#123;        if (-1 == ::ResumeThread(handle))            throw std::exception(&quot;ResumeThread failed&quot;);        ::CloseHandle(handle);    &#125;&#125;</code></pre><p>这两个方法实现之后再来实现内存标记整理算法</p><pre><code>void MemoryPool::markedTidyingGC()&#123;    std::set&lt;unit_t *&gt; aliveUnits;    std::vector&lt;unit_t *&gt; deadUnits;    auto threadHandles = suspendTheWorld(); // 砸瓦鲁多    auto block = m_blocks;    do    &#123;        aliveUnits.clear();        deadUnits.clear();        auto unit = block-&gt;usedList;        do        &#123;            if (0 != unit-&gt;refCount)                aliveUnits.insert(unit);            else                deadUnits.push_back(unit);            unit = unit-&gt;nextUnit;        &#125; while (unit != block-&gt;usedList);        // check if alive units is empty        if (aliveUnits.empty())        &#123;            // free all dead units            for (auto &amp;unit : deadUnits)            &#123;                m_refUnits[unit-&gt;refIndex] = nullptr;                freeUnit(unit);            &#125;        &#125;        else        &#123;            // update dead unit reference            for (const auto &amp;unit : deadUnits)                m_refUnits[unit-&gt;refIndex] = nullptr;            // move alive units to the front of the block            auto unitMoveToPosition = reinterpret_cast&lt;unit_t *&gt;(block-&gt;data);            size_t usedTotalSize = 0;            for (auto &amp;unit : aliveUnits)            &#123;                memcpy(unitMoveToPosition, unit, sizeof(unit_t) + unit-&gt;size);                unitMoveToPosition-&gt;data = reinterpret_cast&lt;uint8_t *&gt;(unitMoveToPosition) + sizeof(unit_t);                if (0 == usedTotalSize)                &#123;                    block-&gt;usedList = unitMoveToPosition;                    unitMoveToPosition-&gt;nextUnit = unitMoveToPosition;                    unitMoveToPosition-&gt;prevUnit = unitMoveToPosition;                &#125;                else                &#123;                    block-&gt;usedList-&gt;prevUnit-&gt;nextUnit = unitMoveToPosition;                    unitMoveToPosition-&gt;prevUnit = block-&gt;usedList-&gt;prevUnit;                    unitMoveToPosition-&gt;nextUnit = block-&gt;usedList;                    block-&gt;usedList-&gt;prevUnit = unitMoveToPosition;                &#125;                usedTotalSize += unitMoveToPosition-&gt;size + sizeof(unit_t);                unitMoveToPosition = reinterpret_cast&lt;unit_t *&gt;(unitMoveToPosition-&gt;data + unitMoveToPosition-&gt;size);            &#125;            // reset free unit list            block-&gt;freeTotal = block-&gt;size - usedTotalSize - sizeof(unit_t);            block-&gt;freeList = reinterpret_cast&lt;unit_t *&gt;(block-&gt;data + usedTotalSize);            block-&gt;freeList-&gt;data = reinterpret_cast&lt;uint8_t *&gt;(block-&gt;freeList) + sizeof(unit_t);            block-&gt;freeList-&gt;block = block;            block-&gt;freeList-&gt;size = block-&gt;freeTotal;            block-&gt;freeList-&gt;nextUnit = block-&gt;freeList;            block-&gt;freeList-&gt;prevUnit = block-&gt;freeList;            // update used unit reference            unit = block-&gt;usedList;            do            &#123;                m_refUnits[unit-&gt;refIndex] = unit;                unit = unit-&gt;nextUnit;            &#125; while (unit != block-&gt;usedList);        &#125;        block = block-&gt;nextBlock;    &#125; while (block != m_blocks);    resumeTheWorld(threadHandles); // 使用相同类型的替身&#125;</code></pre><p>可以看到整个整理的过程就是先暂停世界，然后记录在此次GC中仙去与存活的内存单元。</p><p>如果此次GC没有存活的内存单元则直接直接进行内存单元的释放，否则先进行仙去内存单元的指针引用更新，使其变为<code>nullptr</code>，接下来对存活内存单元进行数据移动，将整个内存单元移动至前一个内存单元的后面，使其紧密贴合，如果是第一个移动的话则移动的目标地址是当前内存块的数据地址。</p><p>你问我会不会后面的数据把前面的单元给覆盖了？自然是不会，这是为什么使用<code>std::set</code>而不是<code>std::vector、std::unordered_set</code>等容器来存放存活内存单元地址的原因，因为<code>std::set</code>会自动给我们进行排序，而只要我们保证存活内存单元的移动是顺序的，就不会发生数据覆盖的情况。<br><strong>小提示：</strong><code>std::set基于红黑树实现，如果不需要排序的功能可使用std::unordered_set，std::unordered_set的实现基于哈希表，在性能上可直接吊打</code></p><p>在移动完所有存活的内存单元之后我们需要更新空闲内存空间的信息，因为我们已将使用的内存单元移动到内存块首部，所以剩下的都是可使用的空闲内存，直接分配一个大块空闲内存单元就好了。</p><p>最后我们需要更新已使用的内存单元的指针引用信息并取消整个世界的暂停即可。</p><p>看效果</p><p><img src="/images/1650222107.jpeg" alt="内存标记整理算法结果"></p><p>运行过程内存结构变化的<code>Graphviz</code>图</p><table><thead><tr><th><img src="/images/1650222108.jpeg" alt="内存标记整理算法内存结构变化01"></th><th><img src="/images/1650222109.jpeg" alt="内存标记整理算法内存结构变化02"></th></tr></thead></table><p>可以看到<code>data02</code>被释放后原本使用的地址被<code>data03</code>拿去用了，说明移动整理成功。</p><h3 id="内存分代标记整理算法"><a href="#内存分代标记整理算法" class="headerlink" title="内存分代标记整理算法"></a>内存分代标记整理算法</h3><p><strong>提示：</strong><code>因当前内存池结构不太好实现分代，所以接下来会另外申请一块内存来当作老年代</code></p><p>代码</p><pre><code>void MemoryPool::generationalMarkedTidyingGC()&#123;    static unit_t *elderUnitList = reinterpret_cast&lt;unit_t *&gt;(::VirtualAlloc(nullptr, 32 * 1024 * 1024, MEM_RESERVE | MEM_COMMIT, PAGE_READWRITE));    static size_t elderUnitListIndex = 0;    if (nullptr == elderUnitList)        throw std::exception(&quot;Emulate elder block failed&quot;);    std::set&lt;unit_t *&gt; elderUnits;    std::set&lt;unit_t *&gt; aliveUnits;    std::vector&lt;unit_t *&gt; deadUnits;    auto threadHandles = suspendTheWorld(); // 砸瓦鲁多    auto block = m_blocks;    do    &#123;        if (nullptr == block-&gt;usedList)        &#123;            block = block-&gt;nextBlock;            continue;        &#125;        elderUnits.clear();        aliveUnits.clear();        deadUnits.clear();        auto unit = block-&gt;usedList;        do        &#123;            if (0 != unit-&gt;refCount)            &#123;                if (4 &lt;= ++unit-&gt;aliveCount)                    elderUnits.insert(unit);                else                    aliveUnits.insert(unit);            &#125;            else                deadUnits.push_back(unit);            unit = unit-&gt;nextUnit;        &#125; while (unit != block-&gt;usedList);        // check if alive units and elder units is empty        if (aliveUnits.empty() &amp;&amp; elderUnits.empty())        &#123;            // free all dead units            for (auto &amp;unit : deadUnits)            &#123;                m_refUnits[unit-&gt;refIndex] = nullptr;                freeUnit(unit);            &#125;        &#125;        else        &#123;            // update dead unit reference            for (const auto &amp;unit : deadUnits)                m_refUnits[unit-&gt;refIndex] = nullptr;            // move elder units to the front of the elder block            for (auto &amp;unit : elderUnits)            &#123;                memcpy(elderUnitList + elderUnitListIndex, unit, sizeof(unit_t) + unit-&gt;size);                auto elderUnit = reinterpret_cast&lt;unit_t *&gt;(elderUnitList + elderUnitListIndex);                elderUnit-&gt;data = reinterpret_cast&lt;uint8_t *&gt;(elderUnit) + sizeof(unit_t);                elderUnit-&gt;block = nullptr;                if (0 == elderUnitListIndex)                &#123;                    elderUnit-&gt;nextUnit = elderUnit;                    elderUnit-&gt;prevUnit = elderUnit;                &#125;                else                &#123;                    elderUnitList-&gt;prevUnit-&gt;nextUnit = elderUnit;                    elderUnit-&gt;prevUnit = elderUnitList-&gt;prevUnit;                    elderUnit-&gt;nextUnit = elderUnitList;                    elderUnitList-&gt;prevUnit = elderUnit;                &#125;                // update elder unit reference                m_refUnits[elderUnit-&gt;refIndex] = elderUnit;                elderUnitListIndex += sizeof(unit_t) + elderUnit-&gt;size;            &#125;            // move alive units to the front of the block            auto unitMoveToPosition = reinterpret_cast&lt;unit_t *&gt;(block-&gt;data);            size_t usedTotalSize = 0;            if (0 == aliveUnits.size())                block-&gt;usedList = nullptr;            for (auto &amp;unit : aliveUnits)            &#123;                memcpy(unitMoveToPosition, unit, sizeof(unit_t) + unit-&gt;size);                unitMoveToPosition-&gt;data = reinterpret_cast&lt;uint8_t *&gt;(unitMoveToPosition) + sizeof(unit_t);                if (0 == usedTotalSize)                &#123;                    block-&gt;usedList = unitMoveToPosition;                    unitMoveToPosition-&gt;nextUnit = unitMoveToPosition;                    unitMoveToPosition-&gt;prevUnit = unitMoveToPosition;                &#125;                else                &#123;                    block-&gt;usedList-&gt;prevUnit-&gt;nextUnit = unitMoveToPosition;                    unitMoveToPosition-&gt;prevUnit = block-&gt;usedList-&gt;prevUnit;                    unitMoveToPosition-&gt;nextUnit = block-&gt;usedList;                    block-&gt;usedList-&gt;prevUnit = unitMoveToPosition;                &#125;                usedTotalSize += unitMoveToPosition-&gt;size + sizeof(unit_t);                unitMoveToPosition = reinterpret_cast&lt;unit_t *&gt;(unitMoveToPosition-&gt;data + unitMoveToPosition-&gt;size);            &#125;            // reset free unit list            block-&gt;freeTotal = block-&gt;size - usedTotalSize - sizeof(unit_t);            block-&gt;freeList = reinterpret_cast&lt;unit_t *&gt;(block-&gt;data + usedTotalSize);            block-&gt;freeList-&gt;data = reinterpret_cast&lt;uint8_t *&gt;(block-&gt;freeList) + sizeof(unit_t);            block-&gt;freeList-&gt;block = block;            block-&gt;freeList-&gt;size = block-&gt;freeTotal;            block-&gt;freeList-&gt;nextUnit = block-&gt;freeList;            block-&gt;freeList-&gt;prevUnit = block-&gt;freeList;            // update used unit reference            if (nullptr != block-&gt;usedList)            &#123;                unit = block-&gt;usedList;                do                &#123;                    m_refUnits[unit-&gt;refIndex] = unit;                    unit = unit-&gt;nextUnit;                &#125; while (unit != block-&gt;usedList);            &#125;        &#125;        block = block-&gt;nextBlock;    &#125; while (block != m_blocks);    resumeTheWorld(threadHandles); // 使用相同类型的替身&#125;</code></pre><p>其中<code>elderUnitList</code>就是我们用来模拟老年代的另外申请的内存块。</p><p>另外在内存标记整理算法的基础上加了个判断，当内存单元的GC存活次数<code>&gt;= 4</code>的时候，我们就把它移动到老年代的内存块上，并更新内存单元的指针引用。</p><p>当在所有的已使用内存单元都成为老年代的情况下，我们还需要将当前内存块的已使用内存单元链表设置为<code>nullptr</code>。</p><p>这里分代的基本思路就是将内存分为新生代与老年代，其中新生代就是我们当前的内存池，老年代就是另外申请的那一块大小<code>32MB</code>的内存。发生GC时我们只对新生代做操作，而进入老年代的内存单元基本移动到老年代的内存块上之后就放手不管了，并且设定进入老年代的条件是内存单元能活过<code>4</code>次GC的调用（GC的调用基本只会发生在内存池无法再申请内存的情况下，除非手动调用）。</p><p>写段代码来看看效果</p><p><img src="/images/1650222110.jpeg" alt="内存分代标记整理算法结果"></p><p>可以看到第一次GC之后进行了一次内存整理，并回收了引用计数为<code>0</code>的<code>data02</code>。接下来再进行4次GC，但真正执行的其实只有3次，第4次进去后因为判断到内存块的<code>usedList</code>为<code>nullptr</code>，所以就直接进行了返回。这表明前3次已经将存活次数<code>&gt;= 4</code>的<code>test01</code>与<code>test03</code>两个对应的内存单元移动到了老年代内存块上了。</p><p>来看一下内存结构变化的<code>Graphviz</code>图</p><table><thead><tr><th><img src="/images/1650222111.jpeg" alt="内存分代标记整理算法内存结构变化01"></th><th><img src="/images/1650222112.jpeg" alt="内存分代标记整理算法内存结构变化02"></th><th><img src="/images/1650222113.jpeg" alt="内存分代标记整理算法内存结构变化03"></th></tr></thead></table><p>可以看到运行到最后内存池已不存在使用中的内存单元，所有的内存均已归还，而被使用了的内存单元则被转移到了老年代内存块之上，那么来看一下老年代内存块的<code>Graphviz</code>图</p><p><img src="/images/1650222114.jpeg" alt="老年代内存块结构"></p><p>这两个内存单元就是我们的<code>test01</code>与<code>test03</code>，移动正确。</p><h2 id="GC前后的操作"><a href="#GC前后的操作" class="headerlink" title="GC前后的操作"></a>GC前后的操作</h2><p>在没有必要的时候我们要尽量避免GC的调用，可在仅当内存池超过限定最大可向系统申请的内存大小时才启动GC进行垃圾回收，并且避免手动的去调用GC。</p><p>在GC后若仍无法分配内存则抛出异常<code>std::bad_alloc</code>。</p><p>以上说的两个操作只需要在运行时做一些判断即可，在这里就不实现了，那么到这里我们所要探讨的几种垃圾回收机制就整完了，接下来我们回到GC之前。</p><h2 id="C-使用特化"><a href="#C-使用特化" class="headerlink" title="C++使用特化"></a>C++使用特化</h2><p>为了方便使用，来实现两个简单的包装函数。</p><pre><code>template &lt;typename class_t&gt;class_t &amp;object() requires std::is_pod_v&lt;class_t&gt;&#123;    return *reinterpret_cast&lt;class_t *&gt;(alloc(sizeof(class_t)));&#125;template &lt;typename class_t, typename... params_t&gt;class_t &amp;object(params_t &amp;&amp;...params)&#123;    class_t *placement = (class_t *)alloc(sizeof(class_t));    if (nullptr == placement)        throw std::bad_alloc();    new (placement) class_t(std::forward&lt;params_t&gt;(params)...);    return *placement;&#125;</code></pre><p>然后测试一下</p><table><thead><tr><th><img src="/images/1650222115.jpeg" alt="结构"></th><th><img src="/images/1650222116.jpeg" alt="测试"></th></tr></thead></table><p>然后我这里不需要容器的支持（主要是懒得实现<code>std::allocator</code>），直接对其禁用。</p><p>先在外部声明一个<code>concept</code></p><pre><code>template &lt;typename any_t&gt;concept is_container = requires(any_t any)&#123;    &#123;any.size()&#125;;    &#123;any.begin()&#125;;    &#123;any.end()&#125;;&#125;;</code></pre><p>然后再实现函数</p><pre><code>template &lt;typename class_t, typename... params_t&gt;class_t &amp;object(params_t &amp;&amp;...params) requires is_container&lt;class_t&gt;&#123;    static_assert(false, &quot;Unsupported type of container.&quot;);    return &#123;&#125;;&#125;</code></pre><p>测试</p><p><img src="/images/1650222117.jpeg" alt="测试"></p><p>差不多就这样了。</p><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>想起还有一件事没做，就是在<code>allocUnit</code>的时候需要对齐<code>sizeof(void*)</code>，不过在这里就不再实现了，鸭蛋莫鸭蛋。</p><p>那就这样了，有缘再见~</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;在特定情况下使用内存池可显著提高性能。&lt;/p&gt;
&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;本文仅供学习探讨之用，如果侵犯了您的权益请联系我删除。&lt;/p&gt;
&lt;h2 id=&quot;工具&quot;</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>[逆向] 记录小黑盒签名算法的逆向过程</title>
    <link href="http://example.com/2022/04/18/%E9%80%86%E5%90%91-%E8%AE%B0%E5%BD%95%E5%B0%8F%E9%BB%91%E7%9B%92%E7%AD%BE%E5%90%8D%E7%AE%97%E6%B3%95%E7%9A%84%E9%80%86%E5%90%91%E8%BF%87%E7%A8%8B/"/>
    <id>http://example.com/2022/04/18/%E9%80%86%E5%90%91-%E8%AE%B0%E5%BD%95%E5%B0%8F%E9%BB%91%E7%9B%92%E7%AD%BE%E5%90%8D%E7%AE%97%E6%B3%95%E7%9A%84%E9%80%86%E5%90%91%E8%BF%87%E7%A8%8B/</id>
    <published>2022-04-17T18:45:42.000Z</published>
    <updated>2022-04-19T18:00:17.147Z</updated>
    
    <content type="html"><![CDATA[<p>白嫖的动力是无限的。</p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本文仅供学习探讨之用，如果侵犯了您的权益请联系我删除。</p><h2 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h2><ol><li><a href="https://www.telerik.com/fiddler" title="Fiddler Official">Fiddler</a></li><li><a href="https://github.com/skylot/jadx" title="JADX Official">JADX</a></li><li><a href="https://hex-rays.com/" title="IDA Official">IDA</a></li><li><a href="https://github.com/frida/frida" title="Frida Official">Frida</a></li></ol><h2 id="抓包"><a href="#抓包" class="headerlink" title="抓包"></a>抓包</h2><p><img src="/images/1650222076.jpg" alt="签到包内容"></p><h2 id="重放测试"><a href="#重放测试" class="headerlink" title="重放测试"></a>重放测试</h2><p>使用<code>Shift + R</code>进行一个包的重放。</p><p><img src="/images/1650222077.jpg" alt="重放测试结果"></p><p>好家伙，那么改一下<code>_time</code>参数试试。</p><p><img src="/images/1650222078.jpg" alt="重放测试结果"></p><p>嗯，看来有签名校验，经过测试后确定是<code>hkey</code>这个参数。</p><h2 id="JADX"><a href="#JADX" class="headerlink" title="JADX"></a>JADX</h2><p>打开<code>jadx</code>并把下载好的<code>.apk</code>文件拖入软件中，等待分析完成。分析完成之后直接打开搜索窗口，输入关键字<code>hkey</code>进行搜索。</p><p><img src="/images/1650222079.jpg" alt="搜索结果"></p><p>发现没有可疑的类，那就用请求路径搜索试试。</p><p><img src="/images/1650222080.jpg" alt="搜索结果"></p><p>嗯，找到目标了，但发现这是一个接口，没有直接进行定义。那么就按下<code>x</code>键跟踪到引用那边。  </p><p><img src="/images/1650222081.jpg" alt="跟踪结果"></p><p>到了这里之后基本就没事，继续往下跟就行，过程省略…</p><p><img src="/images/1650222082.jpg" alt="最终结果"></p><p>最终到了这么一个地方，其中<code>NDKTools.encode</code>就是生成<code>hkey</code>的函数。但是在这里并没有看到<code>hkey</code>这个字段，经过了一番检查之后发现是这么生成的。  </p><pre><code>name = &quot;hey&quot;.replace(&quot;e&quot;, &quot;ke&quot;)</code></pre><p>好，那就没问题了，再来看<code>NDKTools.encode</code>函数，发现其进入了<code>so</code>中。好家伙，那这层就算完了。</p><h2 id="IDA"><a href="#IDA" class="headerlink" title="IDA"></a>IDA</h2><p>找函数的那些过程就省略了，这里直接上伪代码分析结果。</p><pre><code>v11 = (unsigned __int8 *)((__int64 (__fastcall *)(JNIEnv *, __int64, _QWORD))(*v10)-&gt;GetStringUTFChars)(v10, v9, 0LL);// 请求的API路径v12 = ((__int64 (__fastcall *)(JNIEnv *, __int64, _QWORD))(*v10)-&gt;GetStringUTFChars)(v10, v8, 0LL);// 当前时间(1649327297)v13 = (unsigned __int8 *)((__int64 (__fastcall *)(JNIEnv *, __int64, _QWORD))(*v10)-&gt;GetStringUTFChars)(v10, v7, 0LL);// 随机生成的字符串([\da-zA-Z]&#123;32,32&#125;)result = 0LL;// 判断3个参数是否为空if ( v11 &amp;&amp; v12 &amp;&amp; v13 )&#123;    // 参数不为空    v93 = 22872;    v91 = xmmword_3E60;    v92 = 6293310241825115725LL;    v95 = 0;    v15 = strlen(v13);    if ( v15 &lt; 1 )                              // 判断随机字符串长度是否小于1    &#123;    v16 = 0;    &#125;    else    &#123;    // 随机字符串大于1    v16 = 0;                                  // 计数随机字符串中出现0-9的次数    v17 = (unsigned int)v15;                  // 随机字符串的长度    v18 = v94;    do    &#123;        v20 = *v13++;        v19 = v20;        v21 = v20 - 97;        v22 = v20 - 32;        if ( (unsigned int)(v20 - 48) &lt; 0xA )        ++v16;        if ( v21 &lt; 0x1A )        v19 = v22;        --v17;        *v18++ = v19;    &#125;    while ( v17 );    &#125;    v36 = atoi(v12);                            // 当前时间(整型)    dword_6110 = ((unsigned int)(v36 + v16) &gt;&gt; 16) &amp; 0xFF;    dword_6114 = (unsigned __int16)(v36 + v16) &gt;&gt; 8;    v90 = v36 + v16;    v86 = 0;                                    // 存储包含当前时间的向量    v84 = 0u;    v85 = 0u;    v82 = 0u;    v83 = 0u;    v80 = 0u;    v81 = 0u;    v78 = 0u;    v79 = 0u;    v76 = 0u;    v77 = 0u;    v74 = 0u;    v75 = 0u;    v72 = 0u;    v73 = 0u;    dword_6118 = (unsigned int)(v36 + v16) &gt;&gt; 24;    dword_611C = (v36 + v16) &amp; 0xFF;    v87 = (unsigned int)(v36 + v16) &gt;&gt; 24;      // 往向量中存储当前时间以供稍后sub_2BF0函数进行计算，时间是转换成大端存储的时间    v88 = (unsigned int)(v36 + v16) &gt;&gt; 16;    v89 = (unsigned __int16)(v36 + v16) &gt;&gt; 8;    v70 = 0u;    v71 = 0u;    v37 = strlen(v11);    v38 = (unsigned __int8 *)malloc(2                                * (unsigned int)((unsigned __int64)(v37 + 2) * (unsigned __int128)0xAAAAAAAAAAAAAAABLL &gt;&gt; 64) &amp; 0xFFFFFFFC | 1LL);    v39 = strlen(v11);    sub_29F8(v11, v39, v38);                // 将请求的API路径进行Base64编码    v40 = strlen(v38);    sub_2BF0((unsigned __int8 *)&amp;v70, v38, (__int64)&amp;v86, v40, 8LL);// 计算Base64编码后的请求的API路径与时间的哈希值，20字节    v41 = *(_DWORD *)((unsigned __int64)&amp;v70 &amp; 0xFFFFFFFFFFFFFFF0LL | BYTE3(v71) &amp; 0xF);    dword_6124 = BYTE3(v71);    dword_6108 = BYTE3(v71) &amp; 0xF;    dword_610C = v41;    v42 = bswap32(v41);    v43 = v42 &amp; 0x7FFFFFFF;    dword_6104 = (v42 &amp; 0x7FFFFFFF) / 0x271F35A0;    v67 = 15540725856023089LL;    dword_6120 = v42;    v44 = 1307386003LL * ((v42 &gt;&gt; 2) &amp; 0x1FFFFFFF);    v45 = (v42 &amp; 0x7FFFFFFF) / 0x3AuLL;    v46 = *((_BYTE *)&amp;v91 + v43 - 58 * (_DWORD)v45);    v47 = *((unsigned __int8 *)&amp;v91 + (unsigned int)v45 - 58 * (2369637129u * v45 &gt;&gt; 37));    LODWORD(v44) = *((unsigned __int8 *)&amp;v91 + (v44 &gt;&gt; 40) - 58 * (unsigned int)(2369637129u * (v44 &gt;&gt; 40) &gt;&gt; 37));    v48 = *((unsigned __int8 *)&amp;v91 + v43 / 0x2FA28 - 58 * (2369637129u * (v43 / 0x2FA28uLL) &gt;&gt; 37));    v49 = *((unsigned __int8 *)&amp;v91 + v43 / 0xACAD10 - 58 * (2369637129u * (v43 / 0xACAD10uLL) &gt;&gt; 37));    v69 = 0;    LOBYTE(v67) = v46;                          // HKey第一位字节    BYTE1(v67) = v47;                           // HKey第三位字节    BYTE2(v67) = v44;                           // HKey第二位字节    BYTE3(v67) = v48;                           // HKey第五位字节    BYTE4(v67) = v49;                           // HKey第四位字节    v66.n128_u64[0] = __PAIR__(v44, v47);    v66.n128_u64[1] = __PAIR__(v49, v48);    v68 = 0;    sub_23FC((int *)&amp;v66);                      // 计算最后两位校验码数据    v50 = vaddvq_s32(v66);    v51 = v50        - 100        * (((unsigned __int64)(1374389535LL * v50) &gt;&gt; 63)        + ((signed int)((unsigned __int64)(1374389535LL * v50) &gt;&gt; 32) &gt;&gt; 5));    sub_25F4((__int64)&amp;v68, v52, v53, (unsigned int)v51, v54, v55, v56, v57, v66.n128_i64[0]);    v58 = v68;    if ( v51 &gt;= 10 )    v59 = v68;    else    v59 = 48;    if ( v51 &gt;= 10 )    v58 = HIBYTE(v68);    BYTE5(v67) = v59;                           // HKey第六位字节    BYTE6(v67) = v58;                           // HKey第七位字节</code></pre><p>我们需要关注的几个重点是</p><ol><li><code>v11 v12 v13</code>这三个变量分别代表的是什么</li><li><code>sub_29F8</code>这个函数是做什么的</li><li><code>sub_2BF0</code>这个函数是做什么的</li><li>其中<code>sub_2BF0</code>函数中又包含了一个<code>sub_2D50</code>，那么这个函数又是做什么的</li><li><code>sub_23FC</code>这个函数是做什么的</li></ol><p>通过对上下文进行比对，可以发现其实<code>v11 v12 v13</code>这三个变量其实就是在<code>Java</code>层传进来的<code>JString</code>转换成<code>CString</code>后的结果。打上注释。</p><p>再来看<code>sub_29F8</code>这个函数，进入之后发现其对着一个变量疯狂读取。</p><p><img src="/images/1650222085.jpg" alt="sub_29F8"></p><p>有啥这么好看的？来，让我康康！</p><p><img src="/images/1650222086.jpg" alt="byte_41D4"></p><p>过来之后可以看到是个字节数组，那就看看十六进制视图。</p><p><img src="/images/1650222087.jpg" alt="byte_41D4"></p><p>好，<code>base64Encode</code>没跑了，打上注释。</p><p>接下来是<code>sub_2BF0</code>，进入之后看到做了一些没看懂的操作</p><p><img src="/images/1650222088.jpg" alt="sub_2BF0"></p><p><a href="https://developer.arm.com/architectures/instruction-sets/intrinsics/#q=veorq_s8"><img src="/images/1650222089.jpg" alt="veorq_s8"></a></p><p>查了一下指令的<a href="https://developer.arm.com/architectures/instruction-sets/intrinsics/#q=veorq_s8" title="ARM SIMD指令集文档">文档</a>，原来是对一个向量进行异或操作，那就没事了，我们继续。<br>再往下之后又进行了两次函数的调用，这个函数就是<code>sub_2D50</code>。没办法，点进去看看。<br>好像没看到有什么…<br>往下滑到底看一下，这时可以看到返回值是个20字节的数组</p><p><img src="/images/1650222090.jpg" alt="result"></p><p>说到20字节的返回值能有什么呢，第一反应就是<code>sha1</code>啊。不过这里好像也没有看到有<code>initialize values</code>…<br>说到这里，我翻看了《加密与跳楼（第4版）》第6章 找<code>sha1</code>的初始参数。</p><p><img src="/images/1650222091.jpg" alt="book"><br><img src="/images/1650222096.jpg" alt="book"></p><p>嗯…确实没有，直到我把它的参数放入计算器</p><p><img src="/images/1650222092.jpg" alt="calc"></p><p>好家伙，原来是这样！打上注释。</p><p>突然想发个图：<code>TNND，给我玩阴滴是吧.jpg</code></p><p>接下来是<code>sub_23FC</code>，进入之后发现就是对我们传进去的参数进行一堆的运算，然后原路返回，那就没事了，打上注释。</p><h2 id="Frida"><a href="#Frida" class="headerlink" title="Frida"></a>Frida</h2><p>现在来<code>Hook</code>一下我们上面分析的几个函数</p><p><img src="/images/1650222093.jpg" alt="frida"></p><p><img src="/images/1650222094.jpg" alt="hookresult"></p><p><img src="/images/1650222095.jpg" alt="hookresult"></p><p>没得毛病，进入下一步</p><p><img src="/images/sticker_nice.jpg" alt="nice"></p><h2 id="计算过程"><a href="#计算过程" class="headerlink" title="计算过程"></a>计算过程</h2><p>总结一下<code>hkey</code>的计算过程大概就是这样</p><pre><code>input requestPathinput timestampinput randomStringoutput encodedRequestPath = base64Encode(requestPath)process bias = getNumberCount(randomString)output encodedTimestamp = byteSwap(timestamp + bias)alloc timestampBuffer[72]alloc requestPathBuffer[84]process memcpy(timestampBuffer, encodedRequestPath, encodedRequestPath.length)process vectorXor(timestampBuffer, &quot;6666666666666666&quot;)process memcpy(timestampBuffer + 68, encodedTimestamp, 4)output timestampSha1Result = sha1(timestampBuffer, 72)process memcpy(requestPathBuffer, encodedRequestPath, encodedRequestPath.length)process vectorXor(requestPathBuffer, &quot;\\\\\\\\\\\\\\\\&quot;)process memcpy(requestPathBuffer + 64, timestampSha1Result, 20)output requestPathSha1Result = sha1(requestPathBuffer, 84)alloc characterMapping[58] = &quot;23456789BCDFGHJKMNPQRTVWXY&quot; + randomString.toUpperCase()alloc checkSumBuffer[16]alloc hkeyBuffer[7]output indexFactor = byteSwap(requestPathSha1Result[19] &amp; 0xF) &amp; 0x7FFFFFFFprocess hkeyBuffer[0] = characterMapping[indexFactor % 0x3A]process hkeyBuffer[1] = characterMapping[indexFactor / 0x3A % 0x3A]process hkeyBuffer[2] = characterMapping[indexFactor / 0xD24 % 0x3A]process hkeyBuffer[3] = characterMapping[indexFactor / 0x2FA28 % 0x3A]process hkeyBuffer[4] = characterMapping[indexFactor / 0xACAD10 % 0x3A]process memcpy(checkSumBuffer, hkeyBuffer + 1, 4)process checkSumBuffer = calcCheckSum(checkSumBuffer) // 纯数值计算process checkSum = (vectorAdd(checkSumBuffer) % 100).toFixedWidthHexString(2)process hkeyBuffer[5] = checkSum[0]process hkeyBuffer[6] = checkSum[1]output hkey = hkeyBuffer</code></pre><p>其中<code>calcCheckSum</code>函数就是伪代码中的<code>sub_23FC</code>函数。由于函数是纯数值计算，所以直接套用就好了。</p><h2 id="代码验证"><a href="#代码验证" class="headerlink" title="代码验证"></a>代码验证</h2><p>写一份代码验证一下。</p><p><img src="/images/1650222083.jpg" alt="验证代码"></p><p><img src="/images/1650222084.jpg" alt="验证结果"></p><p>可以看到结果符合我们的预期。</p><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>其实过程中在很多地方踩了坑，调试了好几次才懂了233。<br>那就这样了，有缘再见~</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;白嫖的动力是无限的。&lt;/p&gt;
&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;本文仅供学习探讨之用，如果侵犯了您的权益请联系我删除。&lt;/p&gt;
&lt;h2 id=&quot;工具&quot;&gt;&lt;a href=</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>[学习] 整理并记录一下Markdown的基本语法</title>
    <link href="http://example.com/2022/04/17/%E5%AD%A6%E4%B9%A0-%E6%95%B4%E7%90%86%E5%B9%B6%E8%AE%B0%E5%BD%95%E4%B8%80%E4%B8%8BMarkdown%E7%9A%84%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/"/>
    <id>http://example.com/2022/04/17/%E5%AD%A6%E4%B9%A0-%E6%95%B4%E7%90%86%E5%B9%B6%E8%AE%B0%E5%BD%95%E4%B8%80%E4%B8%8BMarkdown%E7%9A%84%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/</id>
    <published>2022-04-17T11:00:04.000Z</published>
    <updated>2022-04-18T09:52:17.739Z</updated>
    
    <content type="html"><![CDATA[<p>Markdown 是一种轻量级标记语言，它允许人们使用易读易写的纯文本格式编写文档，Markdown文件的后缀名便是“.md”。</p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本文仅供学习探讨之用，如果侵犯了您的权益请联系我删除。</p><h2 id="普通文字"><a href="#普通文字" class="headerlink" title="普通文字"></a>普通文字</h2><p><strong>语法符号</strong>：<code>无</code></p><p>普通文字</p><hr><h2 id="标题"><a href="#标题" class="headerlink" title="标题"></a>标题</h2><p><strong>语法符号</strong>：<code># == --</code></p><!-- > # 一级标题> ## 二级标题> ### 三级标题> #### 四级标题> ##### 五级标题> ###### 六级标题>> 可选语法一级标题> ==> 可选语法二级标题> -- --><p><strong>效果</strong></p><p><img src="/images/1650196000.jpg" alt="标题" title="标题"></p><p><strong>代码</strong></p><pre><code># 一级标题## 二级标题### 三级标题#### 四级标题##### 五级标题###### 六级标题可选语法一级标题==可选语法二级标题--</code></pre><hr><h2 id="段落"><a href="#段落" class="headerlink" title="段落"></a>段落</h2><p><strong>语法符号</strong>：<code>\n\n</code></p><p><strong>效果</strong></p><p>段落文本，每段之间用空行进行分隔。</p><p>I think maybe I should use it to format all of my documents.</p><p><strong>代码</strong></p><pre><code>段落文本，每段之间用空行进行分隔。I think maybe I should use it to format all of my documents.</code></pre><hr><h2 id="换行"><a href="#换行" class="headerlink" title="换行"></a>换行</h2><p><strong>语法符号</strong>：<code>两个空格</code></p><p><strong>效果</strong></p><p>使用空格进行换行<br>这是第二行</p><p>使用<code>&lt;br&gt;</code>进行换行<br /><br>这是第二行</p><p><strong>代码</strong></p><pre><code>使用空格进行换行  这是第二行使用`&lt;br&gt;`进行换行&lt;br /&gt;这是第二行</code></pre><hr><h2 id="强调与斜体"><a href="#强调与斜体" class="headerlink" title="强调与斜体"></a>强调与斜体</h2><p><strong>语法符号</strong>：<code>*</code></p><p><strong>效果</strong></p><p><em>斜体</em><br><strong>强调</strong><br><em><strong>强调且斜体</strong></em></p><p><strong>代码</strong></p><pre><code>*斜体***强调*****强调且斜体***</code></pre><hr><h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><p><strong>语法符号</strong>：<code>&gt;</code></p><p><strong>效果</strong></p><blockquote><p>普通引用</p><p><em>引用中使用其他元素</em></p><blockquote><p>嵌套引用</p><blockquote><p>嵌套引用</p><blockquote><p>嵌套引用</p></blockquote></blockquote></blockquote><p><strong>多段落引用</strong></p></blockquote><p><strong>代码</strong></p><pre><code>&gt; 普通引用&gt;&gt; *引用中使用其他元素*&gt;&gt;&gt; 嵌套引用&gt;&gt;&gt; 嵌套引用&gt;&gt;&gt;&gt; 嵌套引用&gt;&gt; **多段落引用**</code></pre><hr><h2 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h2><p><strong>语法符号</strong>：<code>1-inf +</code></p><p><strong>效果</strong></p><ol><li>有序列表第一个元素<ol><li>有序列表嵌套</li></ol></li><li>有序列表第二个元素<ul><li>无序列表第一个元素<ul><li>无序列表嵌套</li></ul></li><li>无序列表第二个元素</li></ul></li><li>有序列表第三个元素</li></ol><p><strong>代码</strong></p><pre><code>1. 有序列表第一个元素    1. 有序列表嵌套2. 有序列表第二个元素    + 无序列表第一个元素        + 无序列表嵌套    + 无序列表第二个元素3. 有序列表第三个元素</code></pre><hr><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p><strong>语法符号</strong>：<code> ` 每行缩进四个空格</code></p><p><strong>效果</strong></p><p><code>使用 ` 创建的代码块</code></p><pre><code>使用缩进四个空格创建的代码块可以多行使用  </code></pre><p>可以在段落文本中使用<code>`</code>来创建局部代码块，比<code>如这</code>样。</p><p><strong>代码</strong></p><pre><code>``使用 ` 创建的代码块``    使用缩进四个空格创建的代码块    可以多行使用  可以在段落文本中使用`` ` ``来创建局部代码块，比`如这`样。</code></pre><hr><h2 id="分隔线"><a href="#分隔线" class="headerlink" title="分隔线"></a>分隔线</h2><p><strong>语法符号</strong>：<code>---</code></p><p><strong>效果</strong></p><hr><p><strong>代码</strong></p><pre><code>---</code></pre><hr><h2 id="删除线"><a href="#删除线" class="headerlink" title="删除线"></a>删除线</h2><p><strong>语法符号</strong>：<code>~~内容~~</code></p><p><strong>效果</strong></p><p><del>我喜欢学习</del></p><p><strong>代码</strong></p><pre><code>~~我喜欢学习~~</code></pre><hr><h2 id="待办事项"><a href="#待办事项" class="headerlink" title="待办事项"></a>待办事项</h2><p><strong>语法符号</strong>：<code>- []</code></p><p><strong>效果</strong></p><ul><li><input checked="" disabled="" type="checkbox"> 待办事项1</li><li><input disabled="" type="checkbox"> 待办事项2</li></ul><p><strong>代码</strong></p><pre><code>- [x] 待办事项1- [ ] 待办事项2</code></pre><hr><h2 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h2><p><strong>语法符号</strong>：<code>[超链接显示名](超链接地址 &quot;超链接title&quot;)</code></p><p><strong>效果</strong></p><p>这是一个链接 <a href="https://markdown.com.cn/" title="最好的markdown教程">Markdown语法</a>。</p><p>可以使用<code>&lt;&gt;</code>括起来链接或邮箱地址：<a href="mailto:&#x72;&#111;&#115;&#x65;&#x62;&#122;&#x69;&#64;&#x66;&#111;&#120;&#109;&#97;&#x69;&#108;&#46;&#99;&#x6f;&#109;">&#x72;&#111;&#115;&#x65;&#x62;&#122;&#x69;&#64;&#x66;&#111;&#120;&#109;&#97;&#x69;&#108;&#46;&#99;&#x6f;&#109;</a></p><p><a href="https://bzi-han.github.io/" title="Bzi-Han&#39;s blog">占位链接</a></p><p>引用导航1<a href="%E8%BF%99%E9%87%8C%E5%8F%AF%E4%BB%A5%E5%86%99%E5%9C%A8%E9%A1%B5%E9%9D%A2%E4%B8%AD%E7%9A%84%E4%BB%BB%E4%BD%95%E5%9C%B0%E6%96%B9">^1</a><br>引用导航2<a href="https://bzi-han.github.io/">^2</a></p><p><strong>代码</strong></p><pre><code>这是一个链接 [Markdown语法](https://markdown.com.cn &quot;最好的markdown教程&quot;)。可以使用`&lt;&gt;`括起来链接或邮箱地址：&lt;rosebzi@foxmail.com&gt;[占位链接][reservelink][reservelink]: https://bzi-han.github.io/ &quot;Bzi-Han&#39;s blog&quot;引用导航1[^1]引用导航2[^2][^1]: 这里可以写在页面中的任何地方[^2]: https://bzi-han.github.io/</code></pre><hr><h2 id="图片"><a href="#图片" class="headerlink" title="图片"></a>图片</h2><p><strong>语法符号</strong>：<code>![图片alt](图片链接 &quot;图片title&quot;)</code></p><p><strong>效果</strong></p><p>只显示图片</p><p><img src="https://s1.ax1x.com/2020/08/27/dfT9Dx.gif" alt="插画" title="image"></p><p>链接与图片并用，点击图片可跳转</p><p><a href="https://baike.baidu.com/item/ASCII/309296"><img src="https://s1.ax1x.com/2022/04/17/LU1KxI.md.png" alt="ASCII" title="ascii"></a></p><p><strong>代码</strong></p><pre><code>只显示图片![插画](https://s1.ax1x.com/2020/08/27/dfT9Dx.gif &quot;image&quot;)链接与图片并用，点击图片可跳转[![ASCII](https://s1.ax1x.com/2022/04/17/LU1KxI.md.png &quot;ascii&quot;)](https://baike.baidu.com/item/ASCII/309296)</code></pre><hr><h2 id="转义"><a href="#转义" class="headerlink" title="转义"></a>转义</h2><p><strong>语法符号</strong>：<code>\ &amp;xxx;</code></p><p><strong>效果</strong></p><p>&amp;nbsp;普通空格 <code>&amp;nbsp;</code><br>&amp;ensp;半角空格 <code>&amp;ensp;</code><br>&amp;emsp;全角空格 <code>&amp;emsp;</code></p><p>* 这里使用<code>\</code>转义了<code>*</code>符号</p><p><strong>代码</strong></p><pre><code>&amp;nbsp;普通空格 `&amp;nbsp;`  &amp;ensp;半角空格 `&amp;ensp;`  &amp;emsp;全角空格 `&amp;emsp;`\* 这里使用`\`转义了`*`符号</code></pre><hr><h2 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h2><p><strong>语法符号</strong>：<code>| : -</code></p><p><strong>效果</strong></p><table><thead><tr><th align="center">第一列</th><th align="left">第二列</th><th align="right">第三列</th></tr></thead><tbody><tr><td align="center">center aligment</td><td align="left">left aligment</td><td align="right">right aligment</td></tr><tr><td align="center">data1</td><td align="left">data2</td><td align="right">data3</td></tr><tr><td align="center">data1</td><td align="left">data2</td><td align="right">data3</td></tr><tr><td align="center">data1</td><td align="left">data2</td><td align="right">data3</td></tr><tr><td align="center">data1</td><td align="left">data2</td><td align="right">data3</td></tr><tr><td align="center">data1</td><td align="left">data2</td><td align="right">data3</td></tr></tbody></table><p><strong>代码</strong></p><pre><code>| 第一列 | 第二列 | 第三列 || :-: | :- | -: || center aligment | left aligment | right aligment || data1 | data2 | data3 || data1 | data2 | data3 || data1 | data2 | data3 || data1 | data2 | data3 || data1 | data2 | data3 |</code></pre><hr><h2 id="内嵌HTML"><a href="#内嵌HTML" class="headerlink" title="内嵌HTML"></a>内嵌HTML</h2><p><strong>效果</strong></p><p><i>label i</i><br><a src="https://bzi-han.github.io/" style="color:#dd001b;cursor:pointer;">超链接</a></p><p><strong>代码</strong></p><pre><code>&lt;i&gt;label i&lt;/i&gt;  &lt;a src=&quot;https://bzi-han.github.io/&quot; style=&quot;color:#dd001b;cursor:pointer;&quot;&gt;超链接&lt;/a&gt;</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Markdown 是一种轻量级标记语言，它允许人们使用易读易写的纯文本格式编写文档，Markdown文件的后缀名便是“.md”。&lt;/p&gt;
&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="http://example.com/2022/03/30/hello-world/"/>
    <id>http://example.com/2022/03/30/hello-world/</id>
    <published>2022-03-30T02:06:52.211Z</published>
    <updated>2022-03-30T02:06:52.212Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre><code class="bash">$ hexo new &quot;My New Post&quot;</code></pre><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre><code class="bash">$ hexo server</code></pre><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre><code class="bash">$ hexo generate</code></pre><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre><code class="bash">$ hexo deploy</code></pre><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.io/docs/&quot;&gt;documentation&lt;/a&gt; for</summary>
      
    
    
    
    
  </entry>
  
</feed>
